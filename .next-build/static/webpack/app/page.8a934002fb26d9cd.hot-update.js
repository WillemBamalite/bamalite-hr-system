"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/use-supabase-data.ts":
/*!************************************!*\
  !*** ./hooks/use-supabase-data.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateWorkDays: () => (/* binding */ calculateWorkDays),\n/* harmony export */   calculateWorkDaysVasteDienst: () => (/* binding */ calculateWorkDaysVasteDienst),\n/* harmony export */   useSupabaseData: () => (/* binding */ useSupabaseData)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n\n\n// Function to calculate work days for vaste dienst aflossers based on hours\n// Uses 12-hour increments: 0-12h = 0.5 day, 12-24h = 1.0 day, etc.\nfunction calculateWorkDaysVasteDienst(startDate, startTime, endDate, endTime) {\n    if (!startDate || !endDate || !startTime || !endTime) return 0;\n    // Parse both DD-MM-YYYY and ISO format dates\n    const parseDate = (dateStr)=>{\n        if (!dateStr || typeof dateStr !== 'string') {\n            console.error('Invalid date string:', dateStr);\n            return new Date() // Return current date as fallback\n            ;\n        }\n        // Check if it's already an ISO date (contains T or has 4-digit year at start)\n        if (dateStr.includes('T') || /^\\d{4}-\\d{2}-\\d{2}/.test(dateStr)) {\n            // It's already an ISO date, use it directly\n            const date = new Date(dateStr);\n            if (isNaN(date.getTime())) {\n                console.error('Invalid ISO date:', dateStr);\n                return new Date() // Return current date as fallback\n                ;\n            }\n            return date;\n        }\n        // Otherwise, parse as DD-MM-YYYY format\n        const parts = dateStr.split('-');\n        if (parts.length !== 3) {\n            console.error('Invalid date format:', dateStr);\n            return new Date() // Return current date as fallback\n            ;\n        }\n        const day = parseInt(parts[0], 10);\n        const month = parseInt(parts[1], 10) - 1 // JavaScript months are 0-based\n        ;\n        const year = parseInt(parts[2], 10);\n        const date = new Date(year, month, day);\n        if (isNaN(date.getTime())) {\n            console.error('Invalid parsed date:', dateStr);\n            return new Date() // Return current date as fallback\n            ;\n        }\n        return date;\n    };\n    // Parse time string (HH:MM:SS or HH:MM format)\n    const parseTime = (timeStr)=>{\n        if (!timeStr || typeof timeStr !== 'string') {\n            console.error('Invalid time string:', timeStr);\n            return 0;\n        }\n        const timeParts = timeStr.split(':');\n        if (timeParts.length < 2) {\n            console.error('Invalid time format:', timeStr);\n            return 0;\n        }\n        const hours = parseInt(timeParts[0], 10);\n        const minutes = parseInt(timeParts[1], 10);\n        if (isNaN(hours) || isNaN(minutes)) {\n            console.error('Invalid time values:', timeStr);\n            return 0;\n        }\n        return hours + minutes / 60;\n    };\n    const start = parseDate(startDate);\n    const end = parseDate(endDate);\n    const startTimeHours = parseTime(startTime);\n    const endTimeHours = parseTime(endTime);\n    if (end < start) {\n        console.error('Error: end date is before start date');\n        return 0;\n    }\n    // Create full datetime objects\n    const startDateTime = new Date(start);\n    startDateTime.setHours(Math.floor(startTimeHours), startTimeHours % 1 * 60, 0, 0);\n    const endDateTime = new Date(end);\n    endDateTime.setHours(Math.floor(endTimeHours), endTimeHours % 1 * 60, 0, 0);\n    // Calculate duration in hours\n    const timeDiffMs = endDateTime.getTime() - startDateTime.getTime();\n    const totalHours = timeDiffMs / (1000 * 60 * 60);\n    // Convert to day credits using 12-hour increments\n    // Formula: credits = ceil(hours / 12) * 0.5\n    const dayCredits = Math.ceil(totalHours / 12) * 0.5;\n    return dayCredits;\n}\n// Functie om automatisch crew members te activeren op hun startdatum\nasync function autoActivateCrewMembers(crewData) {\n    const today = new Date();\n    today.setHours(0, 0, 0, 0) // Reset naar start van de dag\n    ;\n    for (const member of crewData){\n        // Check of deze persoon moet worden geactiveerd\n        // Status kan \"thuis\" zijn (wachtend op startdatum) of \"nog-in-te-delen\"\n        if ((member.status === 'thuis' || member.status === 'nog-in-te-delen') && member.expected_start_date && member.ship_id && member.regime) {\n            const startDate = new Date(member.expected_start_date);\n            startDate.setHours(0, 0, 0, 0);\n            // Is vandaag >= startdatum?\n            if (today >= startDate) {\n                console.log(\"\\uD83D\\uDE80 Auto-activating \".concat(member.first_name, \" \").concat(member.last_name, \" - Start date reached!\"));\n                try {\n                    // Update naar \"aan-boord\" status\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').update({\n                        status: 'aan-boord',\n                        on_board_since: member.expected_start_date,\n                        thuis_sinds: null,\n                        expected_start_date: null,\n                        sub_status: null // Clear sub_status\n                    }).eq('id', member.id);\n                    if (error) {\n                        console.error('Error auto-activating crew member:', error);\n                    } else {\n                        console.log(\"âœ… \".concat(member.first_name, \" \").concat(member.last_name, \" is now active!\"));\n                    }\n                } catch (err) {\n                    console.error('Error in auto-activation:', err);\n                }\n            }\n        }\n    }\n}\n// Functie om automatisch rotaties uit te voeren\nasync function autoRotateCrewMembers(crewData) {\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    for (const member of crewData){\n        // Skip als geen regime, ziek, of \"Altijd\"\n        if (!member.regime || member.status === 'ziek' || member.regime === 'Altijd') {\n            continue;\n        }\n        const regimeWeeks = parseInt(member.regime.split('/')[0]);\n        const regimeDays = regimeWeeks * 7;\n        // Check of iemand van aan-boord naar thuis moet\n        if (member.status === 'aan-boord' && member.on_board_since) {\n            const onBoardDate = new Date(member.on_board_since);\n            onBoardDate.setHours(0, 0, 0, 0);\n            const daysSinceOnBoard = Math.floor((today.getTime() - onBoardDate.getTime()) / (1000 * 60 * 60 * 24));\n            if (daysSinceOnBoard >= regimeDays) {\n                const thuisSinds = new Date(onBoardDate);\n                thuisSinds.setDate(thuisSinds.getDate() + regimeDays);\n                console.log(\"\\uD83D\\uDD04 Auto-rotating \".concat(member.first_name, \" \").concat(member.last_name, \" to THUIS\"));\n                try {\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').update({\n                        status: 'thuis',\n                        thuis_sinds: thuisSinds.toISOString().split('T')[0],\n                        on_board_since: null\n                    }).eq('id', member.id);\n                    if (error) {\n                        console.error('Error rotating to thuis:', error);\n                    } else {\n                        console.log(\"âœ… \".concat(member.first_name, \" is now thuis\"));\n                    }\n                } catch (err) {\n                    console.error('Error in rotation:', err);\n                }\n            }\n        }\n        // Check of iemand van thuis naar aan-boord moet\n        if (member.status === 'thuis' && member.thuis_sinds) {\n            const thuisDate = new Date(member.thuis_sinds);\n            thuisDate.setHours(0, 0, 0, 0);\n            const daysSinceThuis = Math.floor((today.getTime() - thuisDate.getTime()) / (1000 * 60 * 60 * 24));\n            if (daysSinceThuis >= regimeDays) {\n                const onBoardSince = new Date(thuisDate);\n                onBoardSince.setDate(onBoardSince.getDate() + regimeDays);\n                console.log(\"\\uD83D\\uDD04 Auto-rotating \".concat(member.first_name, \" \").concat(member.last_name, \" to AAN-BOORD\"));\n                try {\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').update({\n                        status: 'aan-boord',\n                        on_board_since: onBoardSince.toISOString().split('T')[0],\n                        thuis_sinds: null\n                    }).eq('id', member.id);\n                    if (error) {\n                        console.error('Error rotating to aan-boord:', error);\n                    } else {\n                        console.log(\"âœ… \".concat(member.first_name, \" is now aan-boord\"));\n                    }\n                } catch (err) {\n                    console.error('Error in rotation:', err);\n                }\n            }\n        }\n    }\n}\n// Functie om automatisch vaste dienst records te beheren\nasync function autoManageVasteDienstRecords(crewData, vasteDienstRecords, tripsData) {\n    const today = new Date();\n    const currentYear = today.getFullYear();\n    const currentMonth = today.getMonth() + 1 // JavaScript months are 0-based\n    ;\n    console.log(\"\\uD83D\\uDD27 Auto-managing vaste dienst records for \".concat(currentYear, \"-\").concat(currentMonth));\n    // Get all aflossers in vaste dienst\n    const vasteDienstAflossers = crewData.filter((member)=>member.vaste_dienst === true);\n    for (const aflosser of vasteDienstAflossers){\n        console.log(\"\\uD83D\\uDCCB Processing vaste dienst aflosser: \".concat(aflosser.first_name, \" \").concat(aflosser.last_name));\n        // Check if current month record exists\n        const existingRecord = vasteDienstRecords.find((record)=>record.aflosser_id === aflosser.id && record.year === currentYear && record.month === currentMonth);\n        if (!existingRecord) {\n            // Create new monthly record\n            console.log(\"\\uD83D\\uDCC5 Creating new monthly record for \".concat(aflosser.first_name, \" \").concat(aflosser.last_name));\n            try {\n                const newRecord = {\n                    aflosser_id: aflosser.id,\n                    year: currentYear,\n                    month: currentMonth,\n                    required_days: 15,\n                    actual_days: 0,\n                    balance_days: 0,\n                    notes: \"Automatisch aangemaakt voor \".concat(currentYear, \"-\").concat(currentMonth)\n                };\n                const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').insert([\n                    newRecord\n                ]).select().single();\n                if (error) {\n                    console.error('Error creating vaste dienst record:', error);\n                } else {\n                    console.log(\"âœ… Created monthly record for \".concat(aflosser.first_name));\n                }\n            } catch (err) {\n                console.error('Error in vaste dienst record creation:', err);\n            }\n        }\n        // Calculate actual days from completed trips for current month\n        const currentMonthTrips = tripsData.filter((trip)=>trip.aflosser_id === aflosser.id && trip.status === 'voltooid' && trip.eind_datum && new Date(trip.eind_datum).getFullYear() === currentYear && new Date(trip.eind_datum).getMonth() + 1 === currentMonth);\n        let totalWorkDays = 0;\n        for (const trip of currentMonthTrips){\n            const workDays = calculateWorkDays(trip.start_datum, trip.start_tijd, trip.eind_datum, trip.eind_tijd);\n            totalWorkDays += workDays;\n        }\n        // Update the record with actual days and balance\n        if (existingRecord) {\n            const requiredDays = 15;\n            // CORRECTE BEREKENING: Eindsaldo = Beginsaldo + (Gewerkt - 15)\n            // Voor eerste maand: Beginsaldo = -15 + startsaldo\n            let beginsaldo = existingRecord.balance_days || 0;\n            // Als dit de eerste maand is en er is geen beginsaldo, gebruik -15 + startsaldo\n            if (beginsaldo === 0 && currentMonth === 1) {\n                var _aflosser_notes;\n                // Probeer startsaldo uit notes te halen\n                const startsaldoNote = (_aflosser_notes = aflosser.notes) === null || _aflosser_notes === void 0 ? void 0 : _aflosser_notes.find((note)=>note.text && (note.text.includes('startsaldo') || note.text.includes('Startsaldo')));\n                if (startsaldoNote) {\n                    const match = startsaldoNote.text.match(/(-?\\d+(?:\\.\\d+)?)/);\n                    if (match) {\n                        const startsaldo = parseFloat(match[1]);\n                        beginsaldo = -15 + startsaldo;\n                        console.log(\"\\uD83D\\uDCCA Eerste maand: startsaldo \".concat(startsaldo, \", beginsaldo \").concat(beginsaldo));\n                    }\n                }\n                if (beginsaldo === 0) beginsaldo = -15 // Fallback\n                ;\n            }\n            // Voor de eerste maand: toon het beginsaldo als huidig saldo\n            // Voor volgende maanden: bereken het eindsaldo\n            let balanceDays;\n            if (currentMonth === 1 && beginsaldo !== -15) {\n                // Eerste maand met startsaldo: toon beginsaldo\n                balanceDays = beginsaldo;\n            } else {\n                // Normale berekening: beginsaldo + (gewerkt - 15)\n                balanceDays = beginsaldo + (totalWorkDays - requiredDays);\n            }\n            // Cap values to fit in DECIMAL(4,1) - max 999.9\n            const cappedActualDays = Math.min(totalWorkDays, 999.9);\n            const cappedBalanceDays = Math.min(Math.max(balanceDays, -999.9), 999.9);\n            if (existingRecord.actual_days !== cappedActualDays || existingRecord.balance_days !== cappedBalanceDays) {\n                console.log(\"\\uD83D\\uDCCA Updating record for \".concat(aflosser.first_name, \": \").concat(cappedActualDays, \" days (balance: \").concat(cappedBalanceDays, \")\"));\n                try {\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').update({\n                        actual_days: cappedActualDays,\n                        balance_days: cappedBalanceDays\n                    }).eq('id', existingRecord.id);\n                    if (error) {\n                        console.error('âŒ Error updating vaste dienst record:', error);\n                        console.error('âŒ Error details:', JSON.stringify(error, null, 2));\n                        console.error('âŒ Record data:', {\n                            id: existingRecord.id,\n                            actual_days: totalWorkDays,\n                            balance_days: balanceDays\n                        });\n                    } else {\n                        console.log(\"âœ… Updated record for \".concat(aflosser.first_name));\n                    }\n                } catch (err) {\n                    console.error('Error updating vaste dienst record:', err);\n                }\n            }\n        }\n    }\n}\n// Helper function to calculate work days from trip data\nfunction calculateWorkDays(startDate, startTime, endDate, endTime) {\n    if (!startDate || !endDate) return 0;\n    // Parse both DD-MM-YYYY and ISO format dates\n    const parseDate = (dateStr)=>{\n        if (!dateStr || typeof dateStr !== 'string') {\n            console.error('Invalid date string:', dateStr);\n            return new Date() // Return current date as fallback\n            ;\n        }\n        // Check if it's already an ISO date (contains T or has 4-digit year at start)\n        if (dateStr.includes('T') || /^\\d{4}-\\d{2}-\\d{2}/.test(dateStr)) {\n            // It's already an ISO date, use it directly\n            const date = new Date(dateStr);\n            if (isNaN(date.getTime())) {\n                console.error('Invalid ISO date:', dateStr);\n                return new Date() // Return current date as fallback\n                ;\n            }\n            return date;\n        }\n        // Otherwise, parse as DD-MM-YYYY format\n        const parts = dateStr.split('-');\n        if (parts.length !== 3) {\n            console.error('Invalid date format:', dateStr);\n            return new Date() // Return current date as fallback\n            ;\n        }\n        const [day, month, year] = parts;\n        const isoDate = \"\".concat(year, \"-\").concat(month.padStart(2, '0'), \"-\").concat(day.padStart(2, '0'));\n        const date = new Date(isoDate);\n        if (isNaN(date.getTime())) {\n            console.error('Invalid date after parsing:', isoDate, 'from:', dateStr);\n            return new Date() // Return current date as fallback\n            ;\n        }\n        return date;\n    };\n    const start = parseDate(startDate);\n    const end = parseDate(endDate);\n    // Validatie: afstapdatum mag niet voor instapdatum liggen\n    if (end < start) {\n        console.error('Error: end date is before start date');\n        return 0;\n    }\n    // Simpele telling: tel kalenderdagen van start tot eind (inclusief beide)\n    const timeDiff = end.getTime() - start.getTime();\n    const daysDiff = Math.ceil(timeDiff / (1000 * 60 * 60 * 24)) + 1 // +1 omdat we beide datums inclusief tellen\n    ;\n    return daysDiff;\n}\n// Function to auto-update vaste dienst records when a trip is completed\nasync function autoUpdateVasteDienstFromTrip(completedTrip) {\n    try {\n        var _aflosser_notes;\n        console.log(\"\\uD83D\\uDD04 Auto-updating vaste dienst for completed trip: \".concat(completedTrip.id));\n        console.log(\"\\uD83D\\uDD04 Trip data:\", completedTrip);\n        // Get the aflosser\n        const { data: aflosser, error: aflosserError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').select('*').eq('id', completedTrip.aflosser_id).single();\n        if (aflosserError || !aflosser) {\n            console.error('Error fetching aflosser:', aflosserError);\n            return;\n        }\n        // Check if aflosser is in vaste dienst\n        if (!aflosser.vaste_dienst) {\n            console.log('Aflosser is not in vaste dienst, skipping auto-update');\n            return;\n        }\n        // Get the month/year of the trip completion\n        // Parse the date using our safe parseDate function\n        const parseDate = (dateStr)=>{\n            if (!dateStr || typeof dateStr !== 'string') {\n                console.error('Invalid date string:', dateStr);\n                return new Date();\n            }\n            // Check if it's already an ISO date (contains T or has 4-digit year at start)\n            if (dateStr.includes('T') || /^\\d{4}-\\d{2}-\\d{2}/.test(dateStr)) {\n                // It's already an ISO date, use it directly\n                const date = new Date(dateStr);\n                if (isNaN(date.getTime())) {\n                    console.error('Invalid ISO date:', dateStr);\n                    return new Date();\n                }\n                return date;\n            }\n            // Otherwise, parse as DD-MM-YYYY format\n            const parts = dateStr.split('-');\n            if (parts.length !== 3) {\n                console.error('Invalid date format:', dateStr);\n                return new Date();\n            }\n            const [day, month, year] = parts;\n            const isoDate = \"\".concat(year, \"-\").concat(month.padStart(2, '0'), \"-\").concat(day.padStart(2, '0'));\n            const date = new Date(isoDate);\n            if (isNaN(date.getTime())) {\n                console.error('Invalid date after parsing:', isoDate, 'from:', dateStr);\n                return new Date();\n            }\n            return date;\n        };\n        const endDate = parseDate(completedTrip.eind_datum);\n        const year = endDate.getFullYear();\n        const month = endDate.getMonth() + 1;\n        // Check if monthly record exists\n        const { data: existingRecord, error: recordError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').select('*').eq('aflosser_id', completedTrip.aflosser_id).eq('year', year).eq('month', month).single();\n        if (recordError && recordError.code !== 'PGRST116') {\n            console.error('Error fetching vaste dienst record:', recordError);\n            return;\n        }\n        let recordId = existingRecord === null || existingRecord === void 0 ? void 0 : existingRecord.id;\n        // Create record if it doesn't exist\n        if (!existingRecord) {\n            console.log(\"\\uD83D\\uDCC5 Creating new monthly record for \".concat(aflosser.first_name, \" \").concat(aflosser.last_name));\n            const newRecord = {\n                aflosser_id: completedTrip.aflosser_id,\n                year: year,\n                month: month,\n                required_days: 15,\n                actual_days: 0,\n                balance_days: 0,\n                notes: \"Automatisch aangemaakt voor \".concat(year, \"-\").concat(month)\n            };\n            const { data: createdRecord, error: createError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').insert([\n                newRecord\n            ]).select().single();\n            if (createError) {\n                console.error('Error creating vaste dienst record:', createError);\n                return;\n            }\n            recordId = createdRecord.id;\n        }\n        // Calculate work days for this trip\n        const workDays = calculateWorkDays(completedTrip.start_datum, completedTrip.start_tijd, completedTrip.eind_datum, completedTrip.eind_tijd);\n        // Get all completed trips for this month to calculate total\n        const { data: allTrips, error: tripsError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('trips').select('*').eq('aflosser_id', completedTrip.aflosser_id).eq('status', 'voltooid').not('eind_datum', 'is', null);\n        if (tripsError) {\n            console.error('Error fetching trips:', tripsError);\n            return;\n        }\n        // Calculate total work days for the month\n        let totalWorkDays = 0;\n        for (const trip of allTrips || []){\n            const tripEndDate = parseDate(trip.eind_datum);\n            if (tripEndDate.getFullYear() === year && tripEndDate.getMonth() + 1 === month) {\n                const tripWorkDays = calculateWorkDays(trip.start_datum, trip.start_tijd, trip.eind_datum, trip.eind_tijd);\n                totalWorkDays += tripWorkDays;\n            }\n        }\n        // Update the record\n        const requiredDays = 15;\n        // CORRECTE BEREKENING: Eindsaldo = Beginsaldo + (Gewerkt - 15)\n        // Voor eerste maand: Beginsaldo = -15 + startsaldo\n        let beginsaldo = 0;\n        // Probeer startsaldo uit notes te halen voor nieuwe aflossers\n        const startsaldoNote = (_aflosser_notes = aflosser.notes) === null || _aflosser_notes === void 0 ? void 0 : _aflosser_notes.find((note)=>note.text && (note.text.includes('startsaldo') || note.text.includes('Startsaldo')));\n        if (startsaldoNote) {\n            const match = startsaldoNote.text.match(/(-?\\d+(?:\\.\\d+)?)/);\n            if (match) {\n                const startsaldo = parseFloat(match[1]);\n                beginsaldo = -15 + startsaldo;\n                console.log(\"\\uD83D\\uDCCA Nieuwe aflosser: startsaldo \".concat(startsaldo, \", beginsaldo \").concat(beginsaldo));\n            }\n        }\n        if (beginsaldo === 0) beginsaldo = -15 // Fallback\n        ;\n        // Voor de eerste maand: toon het beginsaldo als huidig saldo\n        // Voor volgende maanden: bereken het eindsaldo\n        let balanceDays;\n        if (month === 1 && beginsaldo !== -15) {\n            // Eerste maand met startsaldo: toon beginsaldo\n            balanceDays = beginsaldo;\n        } else {\n            // Normale berekening: beginsaldo + (gewerkt - 15)\n            balanceDays = beginsaldo + (totalWorkDays - requiredDays);\n        }\n        // Cap values to fit in DECIMAL(4,1) - max 999.9\n        const cappedActualDays = Math.min(totalWorkDays, 999.9);\n        const cappedBalanceDays = Math.min(Math.max(balanceDays, -999.9), 999.9);\n        const { error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').update({\n            actual_days: cappedActualDays,\n            balance_days: cappedBalanceDays\n        }).eq('id', recordId);\n        if (updateError) {\n            console.error('âŒ Error updating vaste dienst record:', updateError);\n            console.error('âŒ Error details:', JSON.stringify(updateError, null, 2));\n            console.error('âŒ Record data:', {\n                id: recordId,\n                actual_days: totalWorkDays,\n                balance_days: balanceDays\n            });\n        } else {\n            console.log(\"âœ… Updated vaste dienst record for \".concat(aflosser.first_name, \": \").concat(totalWorkDays, \" days (balance: \").concat(balanceDays, \")\"));\n        }\n    } catch (err) {\n        console.error('Error in auto-update vaste dienst:', err);\n    }\n}\n// Function to force recalculate all vaste dienst records with new logic\nasync function forceRecalculateAllVasteDienstRecords(crewData, tripsData) {\n    try {\n        console.log('ðŸ”„ Force recalculating all vaste dienst records...');\n        console.log(\"\\uD83D\\uDCCA Crew data: \".concat(crewData.length, \" members\"));\n        console.log(\"\\uD83D\\uDCCA Trips data: \".concat(tripsData.length, \" trips\"));\n        // Get all vaste dienst records\n        const { data: allRecords, error: fetchError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').select('*');\n        if (fetchError) {\n            console.error('âŒ Error fetching vaste dienst records:', fetchError);\n            return;\n        }\n        if (!allRecords || allRecords.length === 0) {\n            console.log('âš ï¸ No vaste dienst records found to recalculate');\n            return;\n        }\n        console.log(\"\\uD83D\\uDCCB Found \".concat(allRecords.length, \" records to recalculate\"));\n        // Process each record\n        for (const record of allRecords){\n            try {\n                console.log(\"\\n\\uD83D\\uDD0D Processing record \".concat(record.id, \" for aflosser \").concat(record.aflosser_id));\n                // Find the aflosser\n                const aflosser = crewData.find((crew)=>crew.id === record.aflosser_id);\n                if (!aflosser) {\n                    console.log(\"âš ï¸ Aflosser not found for record \".concat(record.id));\n                    continue;\n                }\n                console.log(\"\\uD83D\\uDC64 Found aflosser: \".concat(aflosser.first_name, \" \").concat(aflosser.last_name));\n                // Get all completed trips for this aflosser\n                const allTrips = tripsData.filter((trip)=>trip.aflosser_id === record.aflosser_id && trip.status === 'voltooid' && trip.start_datum && trip.eind_datum && trip.start_tijd && trip.eind_tijd);\n                console.log(\"\\uD83D\\uDEA2 Found \".concat(allTrips.length, \" completed trips for this aflosser\"));\n                // Calculate total work days with new logic\n                let totalWorkDays = 0;\n                for (const trip of allTrips){\n                    const workDays = calculateWorkDays(trip.start_datum, trip.start_tijd, trip.eind_datum, trip.eind_tijd);\n                    console.log(\"  \\uD83D\\uDCC5 Trip \".concat(trip.id, \": \").concat(trip.start_datum, \" to \").concat(trip.eind_datum, \" = \").concat(workDays, \" days\"));\n                    totalWorkDays += workDays;\n                }\n                console.log(\"\\uD83D\\uDCCA Total work days calculated: \".concat(totalWorkDays));\n                // Cap values to fit in DECIMAL(4,1)\n                const requiredDays = 15;\n                // CORRECTE BEREKENING: Eindsaldo = Beginsaldo + (Gewerkt - 15)\n                // Voor eerste maand: Beginsaldo = -15 + startsaldo\n                let beginsaldo = record.balance_days || 0;\n                // Als dit de eerste maand is en er is geen beginsaldo, gebruik -15 + startsaldo\n                if (beginsaldo === 0 && record.month === 1) {\n                    var _aflosser_notes;\n                    // Probeer startsaldo uit notes te halen\n                    const startsaldoNote = (_aflosser_notes = aflosser.notes) === null || _aflosser_notes === void 0 ? void 0 : _aflosser_notes.find((note)=>note.text && (note.text.includes('startsaldo') || note.text.includes('Startsaldo')));\n                    if (startsaldoNote) {\n                        const match = startsaldoNote.text.match(/(-?\\d+(?:\\.\\d+)?)/);\n                        if (match) {\n                            const startsaldo = parseFloat(match[1]);\n                            beginsaldo = -15 + startsaldo;\n                            console.log(\"\\uD83D\\uDCCA Eerste maand herberekening: startsaldo \".concat(startsaldo, \", beginsaldo \").concat(beginsaldo));\n                        }\n                    }\n                    if (beginsaldo === 0) beginsaldo = -15 // Fallback\n                    ;\n                }\n                // Voor de eerste maand: toon het beginsaldo als huidig saldo\n                // Voor volgende maanden: bereken het eindsaldo\n                let balanceDays;\n                if (record.month === 1 && beginsaldo !== -15) {\n                    // Eerste maand met startsaldo: toon beginsaldo\n                    balanceDays = beginsaldo;\n                } else {\n                    // Normale berekening: beginsaldo + (gewerkt - 15)\n                    balanceDays = beginsaldo + (totalWorkDays - requiredDays);\n                }\n                const cappedActualDays = Math.min(totalWorkDays, 999.9);\n                const cappedBalanceDays = Math.min(Math.max(balanceDays, -999.9), 999.9);\n                console.log(\"\\uD83D\\uDCBE Updating record: actual=\".concat(cappedActualDays, \", balance=\").concat(cappedBalanceDays));\n                // Update the record\n                const { error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').update({\n                    actual_days: cappedActualDays,\n                    balance_days: cappedBalanceDays\n                }).eq('id', record.id);\n                if (updateError) {\n                    console.error(\"âŒ Error updating record \".concat(record.id, \":\"), updateError);\n                } else {\n                    console.log(\"âœ… Successfully updated record for \".concat(aflosser.first_name, \": \").concat(cappedActualDays, \" days (balance: \").concat(cappedBalanceDays, \")\"));\n                }\n            } catch (err) {\n                console.error(\"âŒ Error processing record \".concat(record.id, \":\"), err);\n            }\n        }\n        console.log('ðŸŽ‰ Force recalculation completed!');\n    } catch (err) {\n        console.error('âŒ Error in force recalculate:', err);\n    }\n}\n// Function to reset all vaste dienst records to 0\nasync function resetAllVasteDienstRecords() {\n    try {\n        console.log('ðŸ§¹ Resetting all vaste dienst records to 0...');\n        // Get all vaste dienst records\n        const { data: allRecords, error: fetchError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').select('*');\n        if (fetchError) {\n            console.error('Error fetching vaste dienst records for reset:', fetchError);\n            return;\n        }\n        if (!allRecords || allRecords.length === 0) {\n            console.log('No vaste dienst records found to reset');\n            return;\n        }\n        console.log(\"Found \".concat(allRecords.length, \" records to reset\"));\n        // Reset each record to 0\n        for (const record of allRecords){\n            try {\n                const { error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').update({\n                    actual_days: 0,\n                    balance_days: -15 // -15 because required_days is 15\n                }).eq('id', record.id);\n                if (updateError) {\n                    console.error(\"âŒ Error resetting record \".concat(record.id, \":\"), updateError);\n                } else {\n                    console.log(\"âœ… Reset record \".concat(record.id, \" to 0\"));\n                }\n            } catch (err) {\n                console.error(\"Error resetting record \".concat(record.id, \":\"), err);\n            }\n        }\n        console.log('ðŸŽ‰ Reset completed!');\n    } catch (err) {\n        console.error('Error in reset all records:', err);\n    }\n}\nfunction useSupabaseData() {\n    const [ships, setShips] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [crew, setCrew] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [sickLeave, setSickLeave] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [standBackRecords, setStandBackRecords] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loans, setLoans] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [trips, setTrips] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [vasteDienstRecords, setVasteDienstRecords] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [tasks, setTasks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [crewColorTags, setCrewColorTags] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    // Load all data from Supabase\n    const loadData = async ()=>{\n        try {\n            setLoading(true);\n            setError(null);\n            console.log('Loading data from Supabase...');\n            // Check if user is authenticated\n            const { data: { session } } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.auth.getSession();\n            console.log('Current session:', session ? 'User logged in' : 'No user session');\n            if (!session) {\n                console.warn('No active session - user needs to login');\n                setShips([]);\n                setCrew([]);\n                setSickLeave([]);\n                setStandBackRecords([]);\n                setLoans([]);\n                setTrips([]);\n                setVasteDienstRecords([]);\n                setTasks([]);\n                setLoading(false);\n                return;\n            }\n            // Test Supabase connection\n            console.log('Testing Supabase connection...');\n            const { data: testData, error: testError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('sick_leave').select('id').limit(1);\n            if (testError) {\n                console.error('Supabase connection test failed:', testError);\n                console.error('Test error details:', JSON.stringify(testError, null, 2));\n            } else {\n                console.log('âœ… Supabase connection test successful');\n            }\n            // Load ships\n            console.log('Loading ships...');\n            const { data: shipsData, error: shipsError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('ships').select('*').order('name');\n            if (shipsError) {\n                console.error('Error loading ships:', shipsError);\n                console.error('Ships error details:', JSON.stringify(shipsError, null, 2));\n            } else {\n                console.log('Ships loaded:', (shipsData === null || shipsData === void 0 ? void 0 : shipsData.length) || 0);\n                setShips(shipsData || []);\n            }\n            // Load crew\n            console.log('Loading crew...');\n            const { data: crewData, error: crewError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').select('*').order('first_name');\n            if (crewError) {\n                console.error('Error loading crew:', crewError);\n                console.error('Crew error details:', JSON.stringify(crewError, null, 2));\n            } else {\n                console.log('Crew loaded:', (crewData === null || crewData === void 0 ? void 0 : crewData.length) || 0);\n                // Temporarily disable auto-activation and rotation to prevent infinite loops\n                // await autoActivateCrewMembers(crewData || [])\n                // await autoRotateCrewMembers(crewData || [])\n                // Set crew data directly without reloading\n                setCrew(crewData || []);\n            }\n            // Load sick leave\n            console.log('Loading sick leave...');\n            const { data: sickLeaveData, error: sickLeaveError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('sick_leave').select('*').order('start_date', {\n                ascending: false\n            });\n            if (sickLeaveError) {\n                console.error('Error loading sick leave:', sickLeaveError);\n            } else {\n                console.log('Sick leave loaded:', (sickLeaveData === null || sickLeaveData === void 0 ? void 0 : sickLeaveData.length) || 0);\n                setSickLeave(sickLeaveData || []);\n            }\n            // Load stand back records\n            console.log('Loading stand back records...');\n            const { data: standBackData, error: standBackError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('stand_back_records').select('*').order('created_at', {\n                ascending: false\n            });\n            if (standBackError) {\n                console.error('Error loading stand back records:', standBackError);\n                setStandBackRecords([]);\n            } else {\n                console.log('Stand back records loaded:', (standBackData === null || standBackData === void 0 ? void 0 : standBackData.length) || 0);\n                setStandBackRecords(standBackData || []);\n            }\n            // Load loans\n            console.log('Loading loans...');\n            const { data: loansData, error: loansError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('loans').select('*').order('created_at', {\n                ascending: false\n            });\n            if (loansError) {\n                console.error('Error loading loans:', loansError);\n                setLoans([]);\n            } else {\n                console.log('Loans loaded:', (loansData === null || loansData === void 0 ? void 0 : loansData.length) || 0);\n                setLoans(loansData || []);\n            }\n            // Load trips\n            console.log('Loading trips...');\n            const { data: tripsData, error: tripsError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('trips').select('*').order('created_at', {\n                ascending: false\n            });\n            if (tripsError) {\n                console.error('Error loading trips:', tripsError);\n                setTrips([]);\n            } else {\n                console.log('Trips loaded:', (tripsData === null || tripsData === void 0 ? void 0 : tripsData.length) || 0);\n                setTrips(tripsData || []);\n            }\n            // Load vaste dienst records\n            console.log('Loading vaste dienst records...');\n            const { data: vasteDienstData, error: vasteDienstError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').select('*').order('year', {\n                ascending: false\n            }).order('month', {\n                ascending: false\n            });\n            if (vasteDienstError) {\n                console.error('Error loading vaste dienst records:', vasteDienstError);\n                setVasteDienstRecords([]);\n            } else {\n                console.log('Vaste dienst records loaded:', (vasteDienstData === null || vasteDienstData === void 0 ? void 0 : vasteDienstData.length) || 0);\n                setVasteDienstRecords(vasteDienstData || []);\n                // Auto-manage vaste dienst records after loading all data\n                console.log('ðŸ”§ Auto-managing vaste dienst records...');\n                await autoManageVasteDienstRecords(crewData || [], vasteDienstData || [], tripsData || []);\n            }\n            // Load tasks\n            console.log('Loading tasks...');\n            const { data: tasksData, error: tasksError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('tasks').select('*').order('created_at', {\n                ascending: false\n            });\n            if (tasksError) {\n                console.error('Error loading tasks:', tasksError);\n                setTasks([]);\n            } else {\n                console.log('Tasks loaded:', (tasksData === null || tasksData === void 0 ? void 0 : tasksData.length) || 0);\n                setTasks(tasksData || []);\n            }\n            console.log('Data loading completed!');\n            // Load crew color tags last, non-blocking for main data\n            try {\n                const { data: colorRows, error: colorErr } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew_color_tags').select('crew_id, color');\n                if (colorErr) {\n                    const msg = (colorErr === null || colorErr === void 0 ? void 0 : colorErr.message) || String(colorErr);\n                    console.warn('Skipping crew_color_tags (table missing or no access):', msg);\n                    setCrewColorTags({});\n                } else {\n                    const map = {};\n                    for (const row of colorRows || []){\n                        if (row.crew_id && row.color) map[row.crew_id] = row.color;\n                    }\n                    setCrewColorTags(map);\n                }\n            } catch (e) {\n                console.warn('Error loading crew_color_tags:', (e === null || e === void 0 ? void 0 : e.message) || e);\n                setCrewColorTags({});\n            }\n        } catch (err) {\n            console.error('Error in loadData:', err);\n            setError(err instanceof Error ? err.message : 'Unknown error');\n        } finally{\n            setLoading(false);\n        }\n    };\n    // Load data on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSupabaseData.useEffect\": ()=>{\n            loadData();\n        // Temporarily disable daily check to prevent infinite loops\n        // const dailyCheck = setInterval(() => {\n        //   console.log('Running daily auto-activation check...')\n        //   loadData() // Dit zal autoActivateCrewMembers aanroepen\n        // }, 24 * 60 * 60 * 1000) // 24 uur\n        // return () => clearInterval(dailyCheck)\n        }\n    }[\"useSupabaseData.useEffect\"], []);\n    // Subscribe to real-time changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSupabaseData.useEffect\": ()=>{\n            // Subscribe to ships changes\n            const shipsSubscription = _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.channel('ships-changes').on('postgres_changes', {\n                event: '*',\n                schema: 'public',\n                table: 'ships'\n            }, {\n                \"useSupabaseData.useEffect.shipsSubscription\": ()=>{\n                    loadData();\n                }\n            }[\"useSupabaseData.useEffect.shipsSubscription\"]).subscribe();\n            // Subscribe to crew changes\n            const crewSubscription = _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.channel('crew-changes').on('postgres_changes', {\n                event: '*',\n                schema: 'public',\n                table: 'crew'\n            }, {\n                \"useSupabaseData.useEffect.crewSubscription\": ()=>{\n                    loadData();\n                }\n            }[\"useSupabaseData.useEffect.crewSubscription\"]).subscribe();\n            // Subscribe to sick leave changes\n            const sickLeaveSubscription = _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.channel('sick-leave-changes').on('postgres_changes', {\n                event: '*',\n                schema: 'public',\n                table: 'sick_leave'\n            }, {\n                \"useSupabaseData.useEffect.sickLeaveSubscription\": ()=>{\n                    loadData();\n                }\n            }[\"useSupabaseData.useEffect.sickLeaveSubscription\"]).subscribe();\n            // Subscribe to stand back records changes\n            const standBackSubscription = _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.channel('stand-back-changes').on('postgres_changes', {\n                event: '*',\n                schema: 'public',\n                table: 'stand_back_records'\n            }, {\n                \"useSupabaseData.useEffect.standBackSubscription\": ()=>{\n                    loadData();\n                }\n            }[\"useSupabaseData.useEffect.standBackSubscription\"]).subscribe();\n            // Subscribe to loans changes\n            const loansSubscription = _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.channel('loans-changes').on('postgres_changes', {\n                event: '*',\n                schema: 'public',\n                table: 'loans'\n            }, {\n                \"useSupabaseData.useEffect.loansSubscription\": ()=>{\n                    loadData();\n                }\n            }[\"useSupabaseData.useEffect.loansSubscription\"]).subscribe();\n            // Subscribe to trips changes\n            const tripsSubscription = _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.channel('trips-changes').on('postgres_changes', {\n                event: '*',\n                schema: 'public',\n                table: 'trips'\n            }, {\n                \"useSupabaseData.useEffect.tripsSubscription\": ()=>{\n                    loadData();\n                }\n            }[\"useSupabaseData.useEffect.tripsSubscription\"]).subscribe();\n            // Subscribe to tasks changes\n            const tasksSubscription = _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.channel('tasks-changes').on('postgres_changes', {\n                event: '*',\n                schema: 'public',\n                table: 'tasks'\n            }, {\n                \"useSupabaseData.useEffect.tasksSubscription\": ()=>{\n                    loadData();\n                }\n            }[\"useSupabaseData.useEffect.tasksSubscription\"]).subscribe();\n            return ({\n                \"useSupabaseData.useEffect\": ()=>{\n                    shipsSubscription.unsubscribe();\n                    crewSubscription.unsubscribe();\n                    sickLeaveSubscription.unsubscribe();\n                    standBackSubscription.unsubscribe();\n                    loansSubscription.unsubscribe();\n                    tripsSubscription.unsubscribe();\n                    tasksSubscription.unsubscribe();\n                }\n            })[\"useSupabaseData.useEffect\"];\n        }\n    }[\"useSupabaseData.useEffect\"], []);\n    // Add crew member\n    const addCrew = async (crewData)=>{\n        try {\n            console.log('Adding crew member to Supabase:', crewData);\n            console.log('Crew data details:', JSON.stringify(crewData, null, 2));\n            // Validate required fields\n            const requiredFields = [\n                'id',\n                'first_name',\n                'last_name',\n                'nationality',\n                'position'\n            ];\n            const missingFields = requiredFields.filter((field)=>!crewData[field]);\n            if (missingFields.length > 0) {\n                const error = new Error(\"Missing required fields: \".concat(missingFields.join(', ')));\n                console.error('Validation error:', error);\n                throw error;\n            }\n            // Check for duplicate crew member\n            const { data: existingCrew, error: checkError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').select('id').eq('first_name', crewData.first_name).eq('last_name', crewData.last_name).eq('nationality', crewData.nationality).single();\n            if (existingCrew && !checkError) {\n                const error = new Error(\"Crew member with name \".concat(crewData.first_name, \" \").concat(crewData.last_name, \" already exists\"));\n                console.error('Duplicate crew member:', error);\n                throw error;\n            }\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').insert([\n                crewData\n            ]).select().single();\n            if (error) {\n                console.error('Supabase error adding crew:', error);\n                console.error('Error details:', JSON.stringify(error, null, 2));\n                console.error('Error code:', error.code);\n                console.error('Error message:', error.message);\n                console.error('Error hint:', error.hint);\n                throw error;\n            }\n            console.log('Crew member added successfully:', data);\n            await loadData();\n            return data;\n        } catch (err) {\n            console.error('Error adding crew:', err);\n            console.error('Error details:', JSON.stringify(err, null, 2));\n            throw err;\n        }\n    };\n    // Update crew member\n    const updateCrew = async (id, updates)=>{\n        try {\n            console.log('Updating crew member in Supabase:', id, updates);\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').update(updates).eq('id', id).select().single();\n            if (error) {\n                console.error('Supabase error updating crew:', error);\n                throw error;\n            }\n            console.log('Crew member updated successfully');\n            await loadData();\n            return data;\n        } catch (err) {\n            console.error('Error updating crew:', err);\n            throw err;\n        }\n    };\n    // Delete crew member\n    const deleteCrew = async (id)=>{\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').delete().eq('id', id);\n            if (error) throw error;\n            await loadData() // Reload all data\n            ;\n        } catch (err) {\n            console.error('Error deleting crew:', err);\n            throw err;\n        }\n    };\n    // Add ship\n    const addShip = async (shipData)=>{\n        try {\n            console.log('Adding ship to Supabase:', shipData);\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('ships').insert([\n                shipData\n            ]).select().single();\n            if (error) {\n                console.error('Supabase error adding ship:', error);\n                console.error('Error details:', JSON.stringify(error, null, 2));\n                throw error;\n            }\n            console.log('Ship added successfully:', data);\n            await loadData();\n            return data;\n        } catch (err) {\n            console.error('Error adding ship:', err);\n            throw err;\n        }\n    };\n    // Update ship\n    const updateShip = async (id, updates)=>{\n        try {\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('ships').update(updates).eq('id', id).select().single();\n            if (error) throw error;\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error updating ship:', err);\n            throw err;\n        }\n    };\n    // Delete ship\n    const deleteShip = async (id)=>{\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('ships').delete().eq('id', id);\n            if (error) throw error;\n            await loadData() // Reload all data\n            ;\n        } catch (err) {\n            console.error('Error deleting ship:', err);\n            throw err;\n        }\n    };\n    // Add sick leave\n    const addSickLeave = async (sickLeaveData)=>{\n        try {\n            console.log('Adding sick leave to Supabase:', sickLeaveData);\n            // Ensure notes is not null\n            if (sickLeaveData.notes === null || sickLeaveData.notes === undefined) {\n                sickLeaveData.notes = \"\";\n            }\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('sick_leave').insert([\n                sickLeaveData\n            ]).select().single();\n            if (error) {\n                console.error('Supabase error adding sick leave:', error);\n                console.error('Error details:', JSON.stringify(error, null, 2));\n                throw error;\n            }\n            console.log('Sick leave added successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error adding sick leave:', err);\n            throw err;\n        }\n    };\n    // Update sick leave\n    const updateSickLeave = async (id, updates)=>{\n        try {\n            console.log('Updating sick leave in Supabase:', id, updates);\n            // Ensure notes is not null\n            if (updates.notes === null || updates.notes === undefined) {\n                updates.notes = \"\";\n            }\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('sick_leave').update(updates).eq('id', id).select().single();\n            if (error) {\n                console.error('Supabase error updating sick leave:', error);\n                console.error('Error details:', JSON.stringify(error, null, 2));\n                throw error;\n            }\n            console.log('Sick leave updated successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error updating sick leave:', err);\n            console.error('Error details:', JSON.stringify(err, null, 2));\n            throw err;\n        }\n    };\n    const addStandBackRecord = async (recordData)=>{\n        try {\n            console.log('=== ADDING STAND BACK RECORD ===');\n            console.log('Original record data:', recordData);\n            // Generate a UUID for the id field\n            const uuid = crypto.randomUUID();\n            console.log('Generated UUID:', uuid);\n            // Remove id if it exists and add our generated UUID\n            const { id, ...dataWithoutId } = recordData;\n            // Create a safe data object with only known database columns\n            const dataToInsert = {\n                id: uuid,\n                crew_member_id: dataWithoutId.crew_member_id,\n                start_date: dataWithoutId.start_date,\n                end_date: dataWithoutId.end_date,\n                days_count: dataWithoutId.days_count,\n                description: dataWithoutId.description,\n                stand_back_days_required: dataWithoutId.stand_back_days_required,\n                stand_back_days_completed: dataWithoutId.stand_back_days_completed,\n                stand_back_days_remaining: dataWithoutId.stand_back_days_remaining,\n                stand_back_status: dataWithoutId.stand_back_status,\n                stand_back_history: dataWithoutId.stand_back_history || []\n            };\n            // Add optional fields if they exist (for backward compatibility)\n            if (dataWithoutId.reason) {\n                dataToInsert.reason = dataWithoutId.reason;\n            }\n            if (dataWithoutId.notes) {\n                dataToInsert.notes = dataWithoutId.notes;\n            }\n            console.log('Data to insert (with generated UUID):', dataToInsert);\n            console.log('Data to insert JSON:', JSON.stringify(dataToInsert, null, 2));\n            // Validate required fields\n            const requiredFields = [\n                'id',\n                'crew_member_id',\n                'start_date',\n                'end_date',\n                'days_count',\n                'stand_back_days_required',\n                'stand_back_days_completed',\n                'stand_back_days_remaining',\n                'stand_back_status'\n            ];\n            const missingFields = requiredFields.filter((field)=>!dataToInsert[field] && dataToInsert[field] !== 0);\n            if (missingFields.length > 0) {\n                console.error('Missing required fields:', missingFields);\n                throw new Error(\"Missing required fields: \".concat(missingFields.join(', ')));\n            }\n            console.log('All required fields present, inserting to database...');\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('stand_back_records').insert([\n                dataToInsert\n            ]).select();\n            if (error) {\n                console.error('âŒ Supabase error adding stand back record:', error);\n                console.error('âŒ Error details:', JSON.stringify(error, null, 2));\n                console.error('âŒ Error code:', error.code);\n                console.error('âŒ Error message:', error.message);\n                console.error('âŒ Error hint:', error.hint);\n                throw error;\n            }\n            console.log('âœ… Stand back record added successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('âŒ Error adding stand back record:', err);\n            console.error('âŒ Error details:', JSON.stringify(err, null, 2));\n            throw err;\n        }\n    };\n    const updateStandBackRecord = async (recordId, updates)=>{\n        try {\n            console.log('Updating stand back record in Supabase:', recordId, updates);\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('stand_back_records').update(updates).eq('id', recordId).select();\n            if (error) {\n                console.error('Supabase error updating stand back record:', error);\n                throw error;\n            }\n            console.log('Stand back record updated successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error updating stand back record:', err);\n            throw err;\n        }\n    };\n    const addLoan = async (loanData)=>{\n        try {\n            console.log('Adding loan to Supabase:', loanData);\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('loans').insert([\n                loanData\n            ]).select();\n            if (error) {\n                console.error('Supabase error adding loan:', error);\n                throw error;\n            }\n            console.log('Loan added successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error adding loan:', err);\n            throw err;\n        }\n    };\n    const completeLoan = async (loanId, notes)=>{\n        try {\n            console.log('Completing loan in Supabase:', loanId);\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('loans').update({\n                status: 'voltooid',\n                completed_at: new Date().toISOString(),\n                notes: notes || \"\"\n            }).eq('id', loanId).select();\n            if (error) {\n                console.error('Supabase error completing loan:', error);\n                throw error;\n            }\n            console.log('Loan completed successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error completing loan:', err);\n            throw err;\n        }\n    };\n    const makePayment = async (loanId, paymentAmount, note)=>{\n        try {\n            console.log('Making payment for loan:', loanId, paymentAmount);\n            // First, get the current loan\n            const { data: loan, error: fetchError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('loans').select('*').eq('id', loanId).single();\n            if (fetchError || !loan) {\n                throw new Error('Loan not found');\n            }\n            // Calculate new values\n            const newPaid = (loan.amount_paid || 0) + paymentAmount;\n            const newRemaining = loan.amount - newPaid;\n            const newStatus = newRemaining <= 0 ? 'voltooid' : 'open';\n            // Create payment history entry\n            const paymentEntry = {\n                date: new Date().toISOString(),\n                amount: paymentAmount,\n                note: note || 'Betaling afgetekend',\n                paidBy: 'User'\n            };\n            // Update loan\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('loans').update({\n                amount_paid: newPaid,\n                amount_remaining: newRemaining,\n                status: newStatus,\n                completed_at: newStatus === 'voltooid' ? new Date().toISOString() : null,\n                payment_history: [\n                    ...loan.payment_history || [],\n                    paymentEntry\n                ]\n            }).eq('id', loanId).select();\n            if (error) {\n                console.error('Supabase error making payment:', error);\n                throw error;\n            }\n            console.log('Payment made successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error making payment:', err);\n            throw err;\n        }\n    };\n    // Trip functions\n    const addTrip = async (tripData)=>{\n        try {\n            console.log('Adding trip:', tripData);\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('trips').insert([\n                tripData\n            ]).select();\n            if (error) {\n                console.error('Error adding trip:', error);\n                throw error;\n            }\n            console.log('Trip added successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error adding trip:', err);\n            throw err;\n        }\n    };\n    const updateTrip = async (tripId, updates)=>{\n        try {\n            console.log('Updating trip:', tripId, updates);\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('trips').update({\n                ...updates,\n                updated_at: new Date().toISOString()\n            }).eq('id', tripId).select().single();\n            if (error) {\n                console.error('Error updating trip:', error);\n                throw error;\n            }\n            console.log('Trip updated successfully:', data);\n            // If trip is completed, auto-update vaste dienst records\n            if (updates.status === 'voltooid' && data.aflosser_id) {\n                console.log('ðŸš€ Trip completed - auto-updating vaste dienst records');\n                await autoUpdateVasteDienstFromTrip(data);\n            }\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error updating trip:', err);\n            throw err;\n        }\n    };\n    // Vaste dienst functions\n    const addVasteDienstRecord = async (recordData)=>{\n        try {\n            console.log('Adding vaste dienst record:', recordData);\n            console.log('Record data details:', JSON.stringify(recordData, null, 2));\n            // Validate required fields\n            const requiredFields = [\n                'aflosser_id',\n                'year',\n                'month',\n                'required_days',\n                'actual_days',\n                'balance_days'\n            ];\n            const missingFields = requiredFields.filter((field)=>recordData[field] === undefined || recordData[field] === null);\n            if (missingFields.length > 0) {\n                const error = new Error(\"Missing required fields: \".concat(missingFields.join(', ')));\n                console.error('Validation error:', error);\n                throw error;\n            }\n            // Check if record already exists for this aflosser/year/month combination\n            const { data: existingRecord, error: checkError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').select('id').eq('aflosser_id', recordData.aflosser_id).eq('year', recordData.year).eq('month', recordData.month).single();\n            if (existingRecord) {\n                console.log('Record already exists for this aflosser/year/month combination, updating instead');\n                // Update existing record instead of creating new one\n                const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').update({\n                    required_days: recordData.required_days,\n                    actual_days: recordData.actual_days,\n                    balance_days: recordData.balance_days,\n                    updated_at: new Date().toISOString()\n                }).eq('id', existingRecord.id).select();\n                if (error) {\n                    console.error('Error updating existing vaste dienst record:', error);\n                    throw error;\n                }\n                console.log('Vaste dienst record updated successfully:', data);\n                await loadData() // Reload all data\n                ;\n                return data;\n            }\n            // If no existing record, create new one\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').insert([\n                recordData\n            ]).select();\n            if (error) {\n                console.error('Supabase error adding vaste dienst record:', error);\n                console.error('Error details:', JSON.stringify(error, null, 2));\n                console.error('Error code:', error.code);\n                console.error('Error message:', error.message);\n                console.error('Error hint:', error.hint);\n                throw error;\n            }\n            console.log('Vaste dienst record added successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error adding vaste dienst record:', err);\n            console.error('Error details:', JSON.stringify(err, null, 2));\n            throw err;\n        }\n    };\n    const updateVasteDienstRecord = async (recordId, updates)=>{\n        try {\n            console.log('Updating vaste dienst record:', recordId, updates);\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').update({\n                ...updates,\n                updated_at: new Date().toISOString()\n            }).eq('id', recordId).select().single();\n            if (error) {\n                console.error('Error updating vaste dienst record:', error);\n                throw error;\n            }\n            console.log('Vaste dienst record updated successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error updating vaste dienst record:', err);\n            throw err;\n        }\n    };\n    const deleteVasteDienstRecord = async (recordId)=>{\n        try {\n            console.log('Deleting vaste dienst record:', recordId);\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').delete().eq('id', recordId);\n            if (error) {\n                console.error('Error deleting vaste dienst record:', error);\n                throw error;\n            }\n            console.log('Vaste dienst record deleted successfully');\n            await loadData() // Reload all data\n            ;\n        } catch (err) {\n            console.error('Error deleting vaste dienst record:', err);\n            throw err;\n        }\n    };\n    // Delete trip permanently\n    const deleteTrip = async (tripId)=>{\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('trips').delete().eq('id', tripId);\n            if (error) {\n                console.error('Supabase error deleting trip:', error);\n                throw error;\n            }\n            console.log('Trip deleted successfully');\n            await loadData() // Reload all data\n            ;\n        } catch (err) {\n            console.error('Error deleting trip:', err);\n            throw err;\n        }\n    };\n    // Delete aflosser permanently\n    const deleteAflosser = async (aflosserId)=>{\n        try {\n            // First delete all related records\n            await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').delete().eq('aflosser_id', aflosserId);\n            await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('trips').delete().eq('aflosser_id', aflosserId);\n            // Then delete the aflosser\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').delete().eq('id', aflosserId);\n            if (error) {\n                console.error('Supabase error deleting aflosser:', error);\n                throw error;\n            }\n            console.log('Aflosser deleted successfully');\n            await loadData() // Reload all data\n            ;\n        } catch (err) {\n            console.error('Error deleting aflosser:', err);\n            throw err;\n        }\n    };\n    // Notes functions\n    const addNoteToCrew = async (crewId, note)=>{\n        try {\n            // Get current crew member data\n            const { data: crewData, error: fetchError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').select('active_notes').eq('id', crewId).single();\n            if (fetchError) throw fetchError;\n            // Parse existing notes or initialize empty array\n            const currentNotes = (crewData === null || crewData === void 0 ? void 0 : crewData.active_notes) || [];\n            // Add new note with timestamp\n            const newNote = {\n                id: Date.now().toString(),\n                content: note,\n                createdAt: new Date().toISOString(),\n                createdBy: 'user' // You could get this from auth context\n            };\n            const updatedNotes = [\n                ...currentNotes,\n                newNote\n            ];\n            // Update crew member with new notes\n            const { error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').update({\n                active_notes: updatedNotes\n            }).eq('id', crewId);\n            if (updateError) throw updateError;\n            console.log('Note added successfully');\n            await loadData(); // Reload data\n        } catch (error) {\n            console.error('Error adding note:', error);\n            throw error;\n        }\n    };\n    const removeNoteFromCrew = async (crewId, noteId)=>{\n        try {\n            // Get current crew member data\n            const { data: crewData, error: fetchError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').select('active_notes, archived_notes').eq('id', crewId).single();\n            if (fetchError) throw fetchError;\n            const currentActiveNotes = (crewData === null || crewData === void 0 ? void 0 : crewData.active_notes) || [];\n            const currentArchivedNotes = (crewData === null || crewData === void 0 ? void 0 : crewData.archived_notes) || [];\n            // Find the note to remove\n            const noteToArchive = currentActiveNotes.find((note)=>note.id === noteId);\n            if (!noteToArchive) {\n                throw new Error('Note not found');\n            }\n            // Remove from active notes\n            const updatedActiveNotes = currentActiveNotes.filter((note)=>note.id !== noteId);\n            // Add to archived notes with archive timestamp\n            const archivedNote = {\n                ...noteToArchive,\n                archivedAt: new Date().toISOString()\n            };\n            const updatedArchivedNotes = [\n                ...currentArchivedNotes,\n                archivedNote\n            ];\n            // Update crew member\n            const { error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').update({\n                active_notes: updatedActiveNotes,\n                archived_notes: updatedArchivedNotes\n            }).eq('id', crewId);\n            if (updateError) throw updateError;\n            console.log('Note archived successfully');\n            await loadData(); // Reload data\n        } catch (error) {\n            console.error('Error removing note:', error);\n            throw error;\n        }\n    };\n    // Add task\n    const addTask = async (taskData)=>{\n        try {\n            console.log('ðŸ“ Adding task with data:', JSON.stringify(taskData, null, 2));\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('tasks').insert([\n                taskData\n            ]).select().single();\n            if (error) {\n                console.error('âŒ Supabase error adding task:', error);\n                console.error('âŒ Error code:', error.code);\n                console.error('âŒ Error message:', error.message);\n                console.error('âŒ Error details:', error.details);\n                console.error('âŒ Error hint:', error.hint);\n                throw error;\n            }\n            await loadData();\n            return data;\n        } catch (err) {\n            console.error('Error adding task:', err);\n            console.error('Error details:', JSON.stringify(err, null, 2));\n            throw err;\n        }\n    };\n    // Update task\n    const updateTask = async (taskId, updates)=>{\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('tasks').update(updates).eq('id', taskId);\n            if (error) throw error;\n            await loadData();\n        } catch (err) {\n            console.error('Error updating task:', err);\n            throw err;\n        }\n    };\n    // Delete task\n    const deleteTask = async (taskId)=>{\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('tasks').delete().eq('id', taskId);\n            if (error) throw error;\n            await loadData();\n        } catch (err) {\n            console.error('Error deleting task:', err);\n            throw err;\n        }\n    };\n    // Complete task\n    const completeTask = async (taskId)=>{\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('tasks').update({\n                completed: true,\n                completed_at: new Date().toISOString()\n            }).eq('id', taskId);\n            if (error) throw error;\n            await loadData();\n        } catch (err) {\n            console.error('Error completing task:', err);\n            throw err;\n        }\n    };\n    return {\n        ships,\n        crew,\n        sickLeave,\n        standBackRecords,\n        loans,\n        trips,\n        tasks,\n        loading,\n        error,\n        loadData,\n        crewColorTags,\n        async setCrewColorTag (crewId, color) {\n            try {\n                if (!crewId) return;\n                if (color) {\n                    // upsert color\n                    const { error: upsertError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew_color_tags').upsert({\n                        crew_id: crewId,\n                        color\n                    }, {\n                        onConflict: 'crew_id'\n                    });\n                    if (upsertError) throw upsertError;\n                } else {\n                    // delete color\n                    const { error: delError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew_color_tags').delete().eq('crew_id', crewId);\n                    if (delError) throw delError;\n                }\n                // update local state\n                setCrewColorTags((prev)=>{\n                    const next = {\n                        ...prev\n                    };\n                    if (color) next[crewId] = color;\n                    else delete next[crewId];\n                    return next;\n                });\n            } catch (e) {\n                const err = e;\n                const msg = (err === null || err === void 0 ? void 0 : err.message) || (typeof err === 'string' ? err : JSON.stringify(err));\n                console.error('Error setting crew color tag:', msg);\n                // If table missing, surface a clear hint once\n                if ((msg === null || msg === void 0 ? void 0 : msg.includes('relation')) && (msg === null || msg === void 0 ? void 0 : msg.includes('crew_color_tags'))) {\n                    console.warn('Hint: create table crew_color_tags (crew_id uuid primary key references crew(id), color text not null)');\n                }\n                throw e;\n            }\n        },\n        addCrew,\n        updateCrew,\n        deleteCrew,\n        addShip,\n        updateShip,\n        deleteShip,\n        addSickLeave,\n        updateSickLeave,\n        addStandBackRecord,\n        updateStandBackRecord,\n        addLoan,\n        completeLoan,\n        makePayment,\n        addTrip,\n        updateTrip,\n        deleteTrip,\n        deleteAflosser,\n        vasteDienstRecords,\n        addVasteDienstRecord,\n        updateVasteDienstRecord,\n        deleteVasteDienstRecord,\n        addNoteToCrew,\n        removeNoteFromCrew,\n        addTask,\n        updateTask,\n        deleteTask,\n        completeTask\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZS1zdXBhYmFzZS1kYXRhLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUEyQztBQUNGO0FBRXpDLDRFQUE0RTtBQUM1RSxtRUFBbUU7QUFDNUQsU0FBU0csNkJBQTZCQyxTQUFpQixFQUFFQyxTQUFpQixFQUFFQyxPQUFlLEVBQUVDLE9BQWU7SUFDakgsSUFBSSxDQUFDSCxhQUFhLENBQUNFLFdBQVcsQ0FBQ0QsYUFBYSxDQUFDRSxTQUFTLE9BQU87SUFFN0QsNkNBQTZDO0lBQzdDLE1BQU1DLFlBQVksQ0FBQ0M7UUFDakIsSUFBSSxDQUFDQSxXQUFXLE9BQU9BLFlBQVksVUFBVTtZQUMzQ0MsUUFBUUMsS0FBSyxDQUFDLHdCQUF3QkY7WUFDdEMsT0FBTyxJQUFJRyxPQUFPLGtDQUFrQzs7UUFDdEQ7UUFFQSw4RUFBOEU7UUFDOUUsSUFBSUgsUUFBUUksUUFBUSxDQUFDLFFBQVEscUJBQXFCQyxJQUFJLENBQUNMLFVBQVU7WUFDL0QsNENBQTRDO1lBQzVDLE1BQU1NLE9BQU8sSUFBSUgsS0FBS0g7WUFDdEIsSUFBSU8sTUFBTUQsS0FBS0UsT0FBTyxLQUFLO2dCQUN6QlAsUUFBUUMsS0FBSyxDQUFDLHFCQUFxQkY7Z0JBQ25DLE9BQU8sSUFBSUcsT0FBTyxrQ0FBa0M7O1lBQ3REO1lBQ0EsT0FBT0c7UUFDVDtRQUVBLHdDQUF3QztRQUN4QyxNQUFNRyxRQUFRVCxRQUFRVSxLQUFLLENBQUM7UUFDNUIsSUFBSUQsTUFBTUUsTUFBTSxLQUFLLEdBQUc7WUFDdEJWLFFBQVFDLEtBQUssQ0FBQyx3QkFBd0JGO1lBQ3RDLE9BQU8sSUFBSUcsT0FBTyxrQ0FBa0M7O1FBQ3REO1FBRUEsTUFBTVMsTUFBTUMsU0FBU0osS0FBSyxDQUFDLEVBQUUsRUFBRTtRQUMvQixNQUFNSyxRQUFRRCxTQUFTSixLQUFLLENBQUMsRUFBRSxFQUFFLE1BQU0sRUFBRSxnQ0FBZ0M7O1FBQ3pFLE1BQU1NLE9BQU9GLFNBQVNKLEtBQUssQ0FBQyxFQUFFLEVBQUU7UUFFaEMsTUFBTUgsT0FBTyxJQUFJSCxLQUFLWSxNQUFNRCxPQUFPRjtRQUNuQyxJQUFJTCxNQUFNRCxLQUFLRSxPQUFPLEtBQUs7WUFDekJQLFFBQVFDLEtBQUssQ0FBQyx3QkFBd0JGO1lBQ3RDLE9BQU8sSUFBSUcsT0FBTyxrQ0FBa0M7O1FBQ3REO1FBRUEsT0FBT0c7SUFDVDtJQUVBLCtDQUErQztJQUMvQyxNQUFNVSxZQUFZLENBQUNDO1FBQ2pCLElBQUksQ0FBQ0EsV0FBVyxPQUFPQSxZQUFZLFVBQVU7WUFDM0NoQixRQUFRQyxLQUFLLENBQUMsd0JBQXdCZTtZQUN0QyxPQUFPO1FBQ1Q7UUFFQSxNQUFNQyxZQUFZRCxRQUFRUCxLQUFLLENBQUM7UUFDaEMsSUFBSVEsVUFBVVAsTUFBTSxHQUFHLEdBQUc7WUFDeEJWLFFBQVFDLEtBQUssQ0FBQyx3QkFBd0JlO1lBQ3RDLE9BQU87UUFDVDtRQUVBLE1BQU1FLFFBQVFOLFNBQVNLLFNBQVMsQ0FBQyxFQUFFLEVBQUU7UUFDckMsTUFBTUUsVUFBVVAsU0FBU0ssU0FBUyxDQUFDLEVBQUUsRUFBRTtRQUV2QyxJQUFJWCxNQUFNWSxVQUFVWixNQUFNYSxVQUFVO1lBQ2xDbkIsUUFBUUMsS0FBSyxDQUFDLHdCQUF3QmU7WUFDdEMsT0FBTztRQUNUO1FBRUEsT0FBT0UsUUFBU0MsVUFBVTtJQUM1QjtJQUVBLE1BQU1DLFFBQVF0QixVQUFVSjtJQUN4QixNQUFNMkIsTUFBTXZCLFVBQVVGO0lBQ3RCLE1BQU0wQixpQkFBaUJQLFVBQVVwQjtJQUNqQyxNQUFNNEIsZUFBZVIsVUFBVWxCO0lBRS9CLElBQUl3QixNQUFNRCxPQUFPO1FBQ2ZwQixRQUFRQyxLQUFLLENBQUM7UUFDZCxPQUFPO0lBQ1Q7SUFFQSwrQkFBK0I7SUFDL0IsTUFBTXVCLGdCQUFnQixJQUFJdEIsS0FBS2tCO0lBQy9CSSxjQUFjQyxRQUFRLENBQUNDLEtBQUtDLEtBQUssQ0FBQ0wsaUJBQWlCLGlCQUFrQixJQUFLLElBQUksR0FBRztJQUVqRixNQUFNTSxjQUFjLElBQUkxQixLQUFLbUI7SUFDN0JPLFlBQVlILFFBQVEsQ0FBQ0MsS0FBS0MsS0FBSyxDQUFDSixlQUFlLGVBQWdCLElBQUssSUFBSSxHQUFHO0lBRTNFLDhCQUE4QjtJQUM5QixNQUFNTSxhQUFhRCxZQUFZckIsT0FBTyxLQUFLaUIsY0FBY2pCLE9BQU87SUFDaEUsTUFBTXVCLGFBQWFELGFBQWMsUUFBTyxLQUFLLEVBQUM7SUFFOUMsa0RBQWtEO0lBQ2xELDRDQUE0QztJQUM1QyxNQUFNRSxhQUFhTCxLQUFLTSxJQUFJLENBQUNGLGFBQWEsTUFBTTtJQUVoRCxPQUFPQztBQUNUO0FBRUEscUVBQXFFO0FBQ3JFLGVBQWVFLHdCQUF3QkMsUUFBZTtJQUNwRCxNQUFNQyxRQUFRLElBQUlqQztJQUNsQmlDLE1BQU1WLFFBQVEsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLDhCQUE4Qjs7SUFFekQsS0FBSyxNQUFNVyxVQUFVRixTQUFVO1FBQzdCLGdEQUFnRDtRQUNoRCx3RUFBd0U7UUFDeEUsSUFDRSxDQUFDRSxPQUFPQyxNQUFNLEtBQUssV0FBV0QsT0FBT0MsTUFBTSxLQUFLLGlCQUFnQixLQUNoRUQsT0FBT0UsbUJBQW1CLElBQzFCRixPQUFPRyxPQUFPLElBQ2RILE9BQU9JLE1BQU0sRUFDYjtZQUNBLE1BQU05QyxZQUFZLElBQUlRLEtBQUtrQyxPQUFPRSxtQkFBbUI7WUFDckQ1QyxVQUFVK0IsUUFBUSxDQUFDLEdBQUcsR0FBRyxHQUFHO1lBRTVCLDRCQUE0QjtZQUM1QixJQUFJVSxTQUFTekMsV0FBVztnQkFDdEJNLFFBQVF5QyxHQUFHLENBQUMsZ0NBQTJDTCxPQUFyQkEsT0FBT00sVUFBVSxFQUFDLEtBQW9CLE9BQWpCTixPQUFPTyxTQUFTLEVBQUM7Z0JBRXhFLElBQUk7b0JBQ0YsaUNBQWlDO29CQUNqQyxNQUFNLEVBQUUxQyxLQUFLLEVBQUUsR0FBRyxNQUFNVCxtREFBUUEsQ0FDN0JvRCxJQUFJLENBQUMsUUFDTEMsTUFBTSxDQUFDO3dCQUNOUixRQUFRO3dCQUNSUyxnQkFBZ0JWLE9BQU9FLG1CQUFtQjt3QkFDMUNTLGFBQWE7d0JBQ2JULHFCQUFxQjt3QkFDckJVLFlBQVksS0FBSyxtQkFBbUI7b0JBQ3RDLEdBQ0NDLEVBQUUsQ0FBQyxNQUFNYixPQUFPYyxFQUFFO29CQUVyQixJQUFJakQsT0FBTzt3QkFDVEQsUUFBUUMsS0FBSyxDQUFDLHNDQUFzQ0E7b0JBQ3RELE9BQU87d0JBQ0xELFFBQVF5QyxHQUFHLENBQUMsS0FBMEJMLE9BQXJCQSxPQUFPTSxVQUFVLEVBQUMsS0FBb0IsT0FBakJOLE9BQU9PLFNBQVMsRUFBQztvQkFDekQ7Z0JBQ0YsRUFBRSxPQUFPUSxLQUFLO29CQUNabkQsUUFBUUMsS0FBSyxDQUFDLDZCQUE2QmtEO2dCQUM3QztZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsZ0RBQWdEO0FBQ2hELGVBQWVDLHNCQUFzQmxCLFFBQWU7SUFDbEQsTUFBTUMsUUFBUSxJQUFJakM7SUFDbEJpQyxNQUFNVixRQUFRLENBQUMsR0FBRyxHQUFHLEdBQUc7SUFFeEIsS0FBSyxNQUFNVyxVQUFVRixTQUFVO1FBQzdCLDBDQUEwQztRQUMxQyxJQUFJLENBQUNFLE9BQU9JLE1BQU0sSUFBSUosT0FBT0MsTUFBTSxLQUFLLFVBQVVELE9BQU9JLE1BQU0sS0FBSyxVQUFVO1lBQzVFO1FBQ0Y7UUFFQSxNQUFNYSxjQUFjekMsU0FBU3dCLE9BQU9JLE1BQU0sQ0FBQy9CLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUN4RCxNQUFNNkMsYUFBYUQsY0FBYztRQUVqQyxnREFBZ0Q7UUFDaEQsSUFBSWpCLE9BQU9DLE1BQU0sS0FBSyxlQUFlRCxPQUFPVSxjQUFjLEVBQUU7WUFDMUQsTUFBTVMsY0FBYyxJQUFJckQsS0FBS2tDLE9BQU9VLGNBQWM7WUFDbERTLFlBQVk5QixRQUFRLENBQUMsR0FBRyxHQUFHLEdBQUc7WUFFOUIsTUFBTStCLG1CQUFtQjlCLEtBQUtDLEtBQUssQ0FBQyxDQUFDUSxNQUFNNUIsT0FBTyxLQUFLZ0QsWUFBWWhELE9BQU8sRUFBQyxJQUFNLFFBQU8sS0FBSyxLQUFLLEVBQUM7WUFFbkcsSUFBSWlELG9CQUFvQkYsWUFBWTtnQkFDbEMsTUFBTUcsYUFBYSxJQUFJdkQsS0FBS3FEO2dCQUM1QkUsV0FBV0MsT0FBTyxDQUFDRCxXQUFXRSxPQUFPLEtBQUtMO2dCQUUxQ3RELFFBQVF5QyxHQUFHLENBQUMsOEJBQXlDTCxPQUFyQkEsT0FBT00sVUFBVSxFQUFDLEtBQW9CLE9BQWpCTixPQUFPTyxTQUFTLEVBQUM7Z0JBRXRFLElBQUk7b0JBQ0YsTUFBTSxFQUFFMUMsS0FBSyxFQUFFLEdBQUcsTUFBTVQsbURBQVFBLENBQzdCb0QsSUFBSSxDQUFDLFFBQ0xDLE1BQU0sQ0FBQzt3QkFDTlIsUUFBUTt3QkFDUlUsYUFBYVUsV0FBV0csV0FBVyxHQUFHbkQsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO3dCQUNuRHFDLGdCQUFnQjtvQkFDbEIsR0FDQ0csRUFBRSxDQUFDLE1BQU1iLE9BQU9jLEVBQUU7b0JBRXJCLElBQUlqRCxPQUFPO3dCQUNURCxRQUFRQyxLQUFLLENBQUMsNEJBQTRCQTtvQkFDNUMsT0FBTzt3QkFDTEQsUUFBUXlDLEdBQUcsQ0FBQyxLQUF1QixPQUFsQkwsT0FBT00sVUFBVSxFQUFDO29CQUNyQztnQkFDRixFQUFFLE9BQU9TLEtBQUs7b0JBQ1puRCxRQUFRQyxLQUFLLENBQUMsc0JBQXNCa0Q7Z0JBQ3RDO1lBQ0Y7UUFDRjtRQUVBLGdEQUFnRDtRQUNoRCxJQUFJZixPQUFPQyxNQUFNLEtBQUssV0FBV0QsT0FBT1csV0FBVyxFQUFFO1lBQ25ELE1BQU1jLFlBQVksSUFBSTNELEtBQUtrQyxPQUFPVyxXQUFXO1lBQzdDYyxVQUFVcEMsUUFBUSxDQUFDLEdBQUcsR0FBRyxHQUFHO1lBRTVCLE1BQU1xQyxpQkFBaUJwQyxLQUFLQyxLQUFLLENBQUMsQ0FBQ1EsTUFBTTVCLE9BQU8sS0FBS3NELFVBQVV0RCxPQUFPLEVBQUMsSUFBTSxRQUFPLEtBQUssS0FBSyxFQUFDO1lBRS9GLElBQUl1RCxrQkFBa0JSLFlBQVk7Z0JBQ2hDLE1BQU1TLGVBQWUsSUFBSTdELEtBQUsyRDtnQkFDOUJFLGFBQWFMLE9BQU8sQ0FBQ0ssYUFBYUosT0FBTyxLQUFLTDtnQkFFOUN0RCxRQUFReUMsR0FBRyxDQUFDLDhCQUF5Q0wsT0FBckJBLE9BQU9NLFVBQVUsRUFBQyxLQUFvQixPQUFqQk4sT0FBT08sU0FBUyxFQUFDO2dCQUV0RSxJQUFJO29CQUNGLE1BQU0sRUFBRTFDLEtBQUssRUFBRSxHQUFHLE1BQU1ULG1EQUFRQSxDQUM3Qm9ELElBQUksQ0FBQyxRQUNMQyxNQUFNLENBQUM7d0JBQ05SLFFBQVE7d0JBQ1JTLGdCQUFnQmlCLGFBQWFILFdBQVcsR0FBR25ELEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTt3QkFDeERzQyxhQUFhO29CQUNmLEdBQ0NFLEVBQUUsQ0FBQyxNQUFNYixPQUFPYyxFQUFFO29CQUVyQixJQUFJakQsT0FBTzt3QkFDVEQsUUFBUUMsS0FBSyxDQUFDLGdDQUFnQ0E7b0JBQ2hELE9BQU87d0JBQ0xELFFBQVF5QyxHQUFHLENBQUMsS0FBdUIsT0FBbEJMLE9BQU9NLFVBQVUsRUFBQztvQkFDckM7Z0JBQ0YsRUFBRSxPQUFPUyxLQUFLO29CQUNabkQsUUFBUUMsS0FBSyxDQUFDLHNCQUFzQmtEO2dCQUN0QztZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBRUEseURBQXlEO0FBQ3pELGVBQWVhLDZCQUE2QjlCLFFBQWUsRUFBRStCLGtCQUF5QixFQUFFQyxTQUFnQjtJQUN0RyxNQUFNL0IsUUFBUSxJQUFJakM7SUFDbEIsTUFBTWlFLGNBQWNoQyxNQUFNaUMsV0FBVztJQUNyQyxNQUFNQyxlQUFlbEMsTUFBTW1DLFFBQVEsS0FBSyxFQUFFLGdDQUFnQzs7SUFFMUV0RSxRQUFReUMsR0FBRyxDQUFDLHVEQUE0RDRCLE9BQWZGLGFBQVksS0FBZ0IsT0FBYkU7SUFFeEUsb0NBQW9DO0lBQ3BDLE1BQU1FLHVCQUF1QnJDLFNBQVNzQyxNQUFNLENBQUNwQyxDQUFBQSxTQUFVQSxPQUFPcUMsWUFBWSxLQUFLO0lBRS9FLEtBQUssTUFBTUMsWUFBWUgscUJBQXNCO1FBQzNDdkUsUUFBUXlDLEdBQUcsQ0FBQyxrREFBK0RpQyxPQUF2QkEsU0FBU2hDLFVBQVUsRUFBQyxLQUFzQixPQUFuQmdDLFNBQVMvQixTQUFTO1FBRTdGLHVDQUF1QztRQUN2QyxNQUFNZ0MsaUJBQWlCVixtQkFBbUJXLElBQUksQ0FBQ0MsQ0FBQUEsU0FDN0NBLE9BQU9DLFdBQVcsS0FBS0osU0FBU3hCLEVBQUUsSUFDbEMyQixPQUFPL0QsSUFBSSxLQUFLcUQsZUFDaEJVLE9BQU9oRSxLQUFLLEtBQUt3RDtRQUduQixJQUFJLENBQUNNLGdCQUFnQjtZQUNuQiw0QkFBNEI7WUFDNUIzRSxRQUFReUMsR0FBRyxDQUFDLGdEQUE2RGlDLE9BQXZCQSxTQUFTaEMsVUFBVSxFQUFDLEtBQXNCLE9BQW5CZ0MsU0FBUy9CLFNBQVM7WUFFM0YsSUFBSTtnQkFDRixNQUFNb0MsWUFBWTtvQkFDaEJELGFBQWFKLFNBQVN4QixFQUFFO29CQUN4QnBDLE1BQU1xRDtvQkFDTnRELE9BQU93RDtvQkFDUFcsZUFBZTtvQkFDZkMsYUFBYTtvQkFDYkMsY0FBYztvQkFDZEMsT0FBTywrQkFBOENkLE9BQWZGLGFBQVksS0FBZ0IsT0FBYkU7Z0JBQ3ZEO2dCQUVBLE1BQU0sRUFBRWUsSUFBSSxFQUFFbkYsS0FBSyxFQUFFLEdBQUcsTUFBTVQsbURBQVFBLENBQ25Db0QsSUFBSSxDQUFDLHdCQUNMeUMsTUFBTSxDQUFDO29CQUFDTjtpQkFBVSxFQUNsQk8sTUFBTSxHQUNOQyxNQUFNO2dCQUVULElBQUl0RixPQUFPO29CQUNURCxRQUFRQyxLQUFLLENBQUMsdUNBQXVDQTtnQkFDdkQsT0FBTztvQkFDTEQsUUFBUXlDLEdBQUcsQ0FBQyxnQ0FBb0QsT0FBcEJpQyxTQUFTaEMsVUFBVTtnQkFDakU7WUFDRixFQUFFLE9BQU9TLEtBQUs7Z0JBQ1puRCxRQUFRQyxLQUFLLENBQUMsMENBQTBDa0Q7WUFDMUQ7UUFDRjtRQUVBLCtEQUErRDtRQUMvRCxNQUFNcUMsb0JBQW9CdEIsVUFBVU0sTUFBTSxDQUFDaUIsQ0FBQUEsT0FDekNBLEtBQUtYLFdBQVcsS0FBS0osU0FBU3hCLEVBQUUsSUFDaEN1QyxLQUFLcEQsTUFBTSxLQUFLLGNBQ2hCb0QsS0FBS0MsVUFBVSxJQUNmLElBQUl4RixLQUFLdUYsS0FBS0MsVUFBVSxFQUFFdEIsV0FBVyxPQUFPRCxlQUM1QyxJQUFJakUsS0FBS3VGLEtBQUtDLFVBQVUsRUFBRXBCLFFBQVEsS0FBSyxNQUFNRDtRQUcvQyxJQUFJc0IsZ0JBQWdCO1FBQ3BCLEtBQUssTUFBTUYsUUFBUUQsa0JBQW1CO1lBQ3BDLE1BQU1JLFdBQVdDLGtCQUFrQkosS0FBS0ssV0FBVyxFQUFFTCxLQUFLTSxVQUFVLEVBQUVOLEtBQUtDLFVBQVUsRUFBRUQsS0FBS08sU0FBUztZQUNyR0wsaUJBQWlCQztRQUNuQjtRQUVBLGlEQUFpRDtRQUNqRCxJQUFJakIsZ0JBQWdCO1lBQ2xCLE1BQU1zQixlQUFlO1lBRXJCLCtEQUErRDtZQUMvRCxtREFBbUQ7WUFDbkQsSUFBSUMsYUFBYXZCLGVBQWVPLFlBQVksSUFBSTtZQUVoRCxnRkFBZ0Y7WUFDaEYsSUFBSWdCLGVBQWUsS0FBSzdCLGlCQUFpQixHQUFHO29CQUVuQks7Z0JBRHZCLHdDQUF3QztnQkFDeEMsTUFBTXlCLGtCQUFpQnpCLGtCQUFBQSxTQUFTUyxLQUFLLGNBQWRULHNDQUFBQSxnQkFBZ0JFLElBQUksQ0FBQyxDQUFDd0IsT0FDM0NBLEtBQUtDLElBQUksSUFBS0QsQ0FBQUEsS0FBS0MsSUFBSSxDQUFDbEcsUUFBUSxDQUFDLGlCQUFpQmlHLEtBQUtDLElBQUksQ0FBQ2xHLFFBQVEsQ0FBQyxhQUFZO2dCQUVuRixJQUFJZ0csZ0JBQWdCO29CQUNsQixNQUFNRyxRQUFRSCxlQUFlRSxJQUFJLENBQUNDLEtBQUssQ0FBQztvQkFDeEMsSUFBSUEsT0FBTzt3QkFDVCxNQUFNQyxhQUFhQyxXQUFXRixLQUFLLENBQUMsRUFBRTt3QkFDdENKLGFBQWEsQ0FBQyxLQUFLSzt3QkFDbkJ2RyxRQUFReUMsR0FBRyxDQUFDLHlDQUF5RHlELE9BQTFCSyxZQUFXLGlCQUEwQixPQUFYTDtvQkFDdkU7Z0JBQ0Y7Z0JBQ0EsSUFBSUEsZUFBZSxHQUFHQSxhQUFhLENBQUMsR0FBRyxXQUFXOztZQUNwRDtZQUVBLDZEQUE2RDtZQUM3RCwrQ0FBK0M7WUFDL0MsSUFBSU87WUFDSixJQUFJcEMsaUJBQWlCLEtBQUs2QixlQUFlLENBQUMsSUFBSTtnQkFDNUMsK0NBQStDO2dCQUMvQ08sY0FBY1A7WUFDaEIsT0FBTztnQkFDTCxrREFBa0Q7Z0JBQ2xETyxjQUFjUCxhQUFjUCxDQUFBQSxnQkFBZ0JNLFlBQVc7WUFDekQ7WUFFQSxnREFBZ0Q7WUFDaEQsTUFBTVMsbUJBQW1CaEYsS0FBS2lGLEdBQUcsQ0FBQ2hCLGVBQWU7WUFDakQsTUFBTWlCLG9CQUFvQmxGLEtBQUtpRixHQUFHLENBQUNqRixLQUFLbUYsR0FBRyxDQUFDSixhQUFhLENBQUMsUUFBUTtZQUVsRSxJQUFJOUIsZUFBZU0sV0FBVyxLQUFLeUIsb0JBQW9CL0IsZUFBZU8sWUFBWSxLQUFLMEIsbUJBQW1CO2dCQUN4RzVHLFFBQVF5QyxHQUFHLENBQUMsb0NBQWtEaUUsT0FBeEJoQyxTQUFTaEMsVUFBVSxFQUFDLE1BQXVDa0UsT0FBbkNGLGtCQUFpQixvQkFBb0MsT0FBbEJFLG1CQUFrQjtnQkFFbkgsSUFBSTtvQkFDSixNQUFNLEVBQUUzRyxLQUFLLEVBQUUsR0FBRyxNQUFNVCxtREFBUUEsQ0FDN0JvRCxJQUFJLENBQUMsd0JBQ0xDLE1BQU0sQ0FBQzt3QkFDTm9DLGFBQWF5Qjt3QkFDYnhCLGNBQWMwQjtvQkFDaEIsR0FDQzNELEVBQUUsQ0FBQyxNQUFNMEIsZUFBZXpCLEVBQUU7b0JBRTNCLElBQUlqRCxPQUFPO3dCQUNURCxRQUFRQyxLQUFLLENBQUMseUNBQXlDQTt3QkFDdkRELFFBQVFDLEtBQUssQ0FBQyxvQkFBb0I2RyxLQUFLQyxTQUFTLENBQUM5RyxPQUFPLE1BQU07d0JBQzlERCxRQUFRQyxLQUFLLENBQUMsa0JBQWtCOzRCQUFFaUQsSUFBSXlCLGVBQWV6QixFQUFFOzRCQUFFK0IsYUFBYVU7NEJBQWVULGNBQWN1Qjt3QkFBWTtvQkFDakgsT0FBTzt3QkFDTHpHLFFBQVF5QyxHQUFHLENBQUMsd0JBQTRDLE9BQXBCaUMsU0FBU2hDLFVBQVU7b0JBQ3pEO2dCQUNGLEVBQUUsT0FBT1MsS0FBSztvQkFDWm5ELFFBQVFDLEtBQUssQ0FBQyx1Q0FBdUNrRDtnQkFDdkQ7WUFDRjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLHdEQUF3RDtBQUNqRCxTQUFTMEMsa0JBQWtCbkcsU0FBaUIsRUFBRUMsU0FBaUIsRUFBRUMsT0FBZSxFQUFFQyxPQUFlO0lBQ3RHLElBQUksQ0FBQ0gsYUFBYSxDQUFDRSxTQUFTLE9BQU87SUFFbkMsNkNBQTZDO0lBQzdDLE1BQU1FLFlBQVksQ0FBQ0M7UUFDakIsSUFBSSxDQUFDQSxXQUFXLE9BQU9BLFlBQVksVUFBVTtZQUMzQ0MsUUFBUUMsS0FBSyxDQUFDLHdCQUF3QkY7WUFDdEMsT0FBTyxJQUFJRyxPQUFPLGtDQUFrQzs7UUFDdEQ7UUFFQSw4RUFBOEU7UUFDOUUsSUFBSUgsUUFBUUksUUFBUSxDQUFDLFFBQVEscUJBQXFCQyxJQUFJLENBQUNMLFVBQVU7WUFDL0QsNENBQTRDO1lBQzVDLE1BQU1NLE9BQU8sSUFBSUgsS0FBS0g7WUFDdEIsSUFBSU8sTUFBTUQsS0FBS0UsT0FBTyxLQUFLO2dCQUN6QlAsUUFBUUMsS0FBSyxDQUFDLHFCQUFxQkY7Z0JBQ25DLE9BQU8sSUFBSUcsT0FBTyxrQ0FBa0M7O1lBQ3REO1lBQ0EsT0FBT0c7UUFDVDtRQUVBLHdDQUF3QztRQUN4QyxNQUFNRyxRQUFRVCxRQUFRVSxLQUFLLENBQUM7UUFDNUIsSUFBSUQsTUFBTUUsTUFBTSxLQUFLLEdBQUc7WUFDdEJWLFFBQVFDLEtBQUssQ0FBQyx3QkFBd0JGO1lBQ3RDLE9BQU8sSUFBSUcsT0FBTyxrQ0FBa0M7O1FBQ3REO1FBRUEsTUFBTSxDQUFDUyxLQUFLRSxPQUFPQyxLQUFLLEdBQUdOO1FBQzNCLE1BQU13RyxVQUFVLEdBQVduRyxPQUFSQyxNQUFLLEtBQTZCSCxPQUExQkUsTUFBTW9HLFFBQVEsQ0FBQyxHQUFHLE1BQUssS0FBd0IsT0FBckJ0RyxJQUFJc0csUUFBUSxDQUFDLEdBQUc7UUFDckUsTUFBTTVHLE9BQU8sSUFBSUgsS0FBSzhHO1FBRXRCLElBQUkxRyxNQUFNRCxLQUFLRSxPQUFPLEtBQUs7WUFDekJQLFFBQVFDLEtBQUssQ0FBQywrQkFBK0IrRyxTQUFTLFNBQVNqSDtZQUMvRCxPQUFPLElBQUlHLE9BQU8sa0NBQWtDOztRQUN0RDtRQUVBLE9BQU9HO0lBQ1Q7SUFFQSxNQUFNZSxRQUFRdEIsVUFBVUo7SUFDeEIsTUFBTTJCLE1BQU12QixVQUFVRjtJQUV0QiwwREFBMEQ7SUFDMUQsSUFBSXlCLE1BQU1ELE9BQU87UUFDZnBCLFFBQVFDLEtBQUssQ0FBQztRQUNkLE9BQU87SUFDVDtJQUVBLDBFQUEwRTtJQUMxRSxNQUFNaUgsV0FBVzdGLElBQUlkLE9BQU8sS0FBS2EsTUFBTWIsT0FBTztJQUM5QyxNQUFNNEcsV0FBV3pGLEtBQUtNLElBQUksQ0FBQ2tGLFdBQVksUUFBTyxLQUFLLEtBQUssRUFBQyxLQUFNLEVBQUUsNENBQTRDOztJQUc3RyxPQUFPQztBQUNUO0FBRUEsd0VBQXdFO0FBQ3hFLGVBQWVDLDhCQUE4QkMsYUFBa0I7SUFDN0QsSUFBSTtZQW1KcUIzQztRQWxKdkIxRSxRQUFReUMsR0FBRyxDQUFDLCtEQUFzRSxPQUFqQjRFLGNBQWNuRSxFQUFFO1FBQ2pGbEQsUUFBUXlDLEdBQUcsQ0FBRSwyQkFBZ0I0RTtRQUU3QixtQkFBbUI7UUFDbkIsTUFBTSxFQUFFakMsTUFBTVYsUUFBUSxFQUFFekUsT0FBT3FILGFBQWEsRUFBRSxHQUFHLE1BQU05SCxtREFBUUEsQ0FDNURvRCxJQUFJLENBQUMsUUFDTDBDLE1BQU0sQ0FBQyxLQUNQckMsRUFBRSxDQUFDLE1BQU1vRSxjQUFjdkMsV0FBVyxFQUNsQ1MsTUFBTTtRQUVULElBQUkrQixpQkFBaUIsQ0FBQzVDLFVBQVU7WUFDOUIxRSxRQUFRQyxLQUFLLENBQUMsNEJBQTRCcUg7WUFDMUM7UUFDRjtRQUVBLHVDQUF1QztRQUN2QyxJQUFJLENBQUM1QyxTQUFTRCxZQUFZLEVBQUU7WUFDMUJ6RSxRQUFReUMsR0FBRyxDQUFDO1lBQ1o7UUFDRjtRQUVBLDRDQUE0QztRQUM1QyxtREFBbUQ7UUFDbkQsTUFBTTNDLFlBQVksQ0FBQ0M7WUFDakIsSUFBSSxDQUFDQSxXQUFXLE9BQU9BLFlBQVksVUFBVTtnQkFDM0NDLFFBQVFDLEtBQUssQ0FBQyx3QkFBd0JGO2dCQUN0QyxPQUFPLElBQUlHO1lBQ2I7WUFFQSw4RUFBOEU7WUFDOUUsSUFBSUgsUUFBUUksUUFBUSxDQUFDLFFBQVEscUJBQXFCQyxJQUFJLENBQUNMLFVBQVU7Z0JBQy9ELDRDQUE0QztnQkFDNUMsTUFBTU0sT0FBTyxJQUFJSCxLQUFLSDtnQkFDdEIsSUFBSU8sTUFBTUQsS0FBS0UsT0FBTyxLQUFLO29CQUN6QlAsUUFBUUMsS0FBSyxDQUFDLHFCQUFxQkY7b0JBQ25DLE9BQU8sSUFBSUc7Z0JBQ2I7Z0JBQ0EsT0FBT0c7WUFDVDtZQUVBLHdDQUF3QztZQUN4QyxNQUFNRyxRQUFRVCxRQUFRVSxLQUFLLENBQUM7WUFDNUIsSUFBSUQsTUFBTUUsTUFBTSxLQUFLLEdBQUc7Z0JBQ3RCVixRQUFRQyxLQUFLLENBQUMsd0JBQXdCRjtnQkFDdEMsT0FBTyxJQUFJRztZQUNiO1lBRUEsTUFBTSxDQUFDUyxLQUFLRSxPQUFPQyxLQUFLLEdBQUdOO1lBQzNCLE1BQU13RyxVQUFVLEdBQVduRyxPQUFSQyxNQUFLLEtBQTZCSCxPQUExQkUsTUFBTW9HLFFBQVEsQ0FBQyxHQUFHLE1BQUssS0FBd0IsT0FBckJ0RyxJQUFJc0csUUFBUSxDQUFDLEdBQUc7WUFDckUsTUFBTTVHLE9BQU8sSUFBSUgsS0FBSzhHO1lBRXRCLElBQUkxRyxNQUFNRCxLQUFLRSxPQUFPLEtBQUs7Z0JBQ3pCUCxRQUFRQyxLQUFLLENBQUMsK0JBQStCK0csU0FBUyxTQUFTakg7Z0JBQy9ELE9BQU8sSUFBSUc7WUFDYjtZQUVBLE9BQU9HO1FBQ1Q7UUFFQSxNQUFNVCxVQUFVRSxVQUFVdUgsY0FBYzNCLFVBQVU7UUFDbEQsTUFBTTVFLE9BQU9sQixRQUFRd0UsV0FBVztRQUNoQyxNQUFNdkQsUUFBUWpCLFFBQVEwRSxRQUFRLEtBQUs7UUFFbkMsaUNBQWlDO1FBQ2pDLE1BQU0sRUFBRWMsTUFBTVQsY0FBYyxFQUFFMUUsT0FBT3NILFdBQVcsRUFBRSxHQUFHLE1BQU0vSCxtREFBUUEsQ0FDaEVvRCxJQUFJLENBQUMsd0JBQ0wwQyxNQUFNLENBQUMsS0FDUHJDLEVBQUUsQ0FBQyxlQUFlb0UsY0FBY3ZDLFdBQVcsRUFDM0M3QixFQUFFLENBQUMsUUFBUW5DLE1BQ1htQyxFQUFFLENBQUMsU0FBU3BDLE9BQ1owRSxNQUFNO1FBRVQsSUFBSWdDLGVBQWVBLFlBQVlDLElBQUksS0FBSyxZQUFZO1lBQ2xEeEgsUUFBUUMsS0FBSyxDQUFDLHVDQUF1Q3NIO1lBQ3JEO1FBQ0Y7UUFFQSxJQUFJRSxXQUFXOUMsMkJBQUFBLHFDQUFBQSxlQUFnQnpCLEVBQUU7UUFFakMsb0NBQW9DO1FBQ3BDLElBQUksQ0FBQ3lCLGdCQUFnQjtZQUNuQjNFLFFBQVF5QyxHQUFHLENBQUMsZ0RBQTZEaUMsT0FBdkJBLFNBQVNoQyxVQUFVLEVBQUMsS0FBc0IsT0FBbkJnQyxTQUFTL0IsU0FBUztZQUUzRixNQUFNb0MsWUFBWTtnQkFDaEJELGFBQWF1QyxjQUFjdkMsV0FBVztnQkFDdENoRSxNQUFNQTtnQkFDTkQsT0FBT0E7Z0JBQ1BtRSxlQUFlO2dCQUNmQyxhQUFhO2dCQUNiQyxjQUFjO2dCQUNkQyxPQUFPLCtCQUF1Q3RFLE9BQVJDLE1BQUssS0FBUyxPQUFORDtZQUNoRDtZQUVBLE1BQU0sRUFBRXVFLE1BQU1zQyxhQUFhLEVBQUV6SCxPQUFPMEgsV0FBVyxFQUFFLEdBQUcsTUFBTW5JLG1EQUFRQSxDQUMvRG9ELElBQUksQ0FBQyx3QkFDTHlDLE1BQU0sQ0FBQztnQkFBQ047YUFBVSxFQUNsQk8sTUFBTSxHQUNOQyxNQUFNO1lBRVQsSUFBSW9DLGFBQWE7Z0JBQ2YzSCxRQUFRQyxLQUFLLENBQUMsdUNBQXVDMEg7Z0JBQ3JEO1lBQ0Y7WUFFQUYsV0FBV0MsY0FBY3hFLEVBQUU7UUFDN0I7UUFFQSxvQ0FBb0M7UUFDcEMsTUFBTTBDLFdBQVdDLGtCQUNmd0IsY0FBY3ZCLFdBQVcsRUFDekJ1QixjQUFjdEIsVUFBVSxFQUN4QnNCLGNBQWMzQixVQUFVLEVBQ3hCMkIsY0FBY3JCLFNBQVM7UUFHekIsNERBQTREO1FBQzVELE1BQU0sRUFBRVosTUFBTXdDLFFBQVEsRUFBRTNILE9BQU80SCxVQUFVLEVBQUUsR0FBRyxNQUFNckksbURBQVFBLENBQ3pEb0QsSUFBSSxDQUFDLFNBQ0wwQyxNQUFNLENBQUMsS0FDUHJDLEVBQUUsQ0FBQyxlQUFlb0UsY0FBY3ZDLFdBQVcsRUFDM0M3QixFQUFFLENBQUMsVUFBVSxZQUNiNkUsR0FBRyxDQUFDLGNBQWMsTUFBTTtRQUUzQixJQUFJRCxZQUFZO1lBQ2Q3SCxRQUFRQyxLQUFLLENBQUMseUJBQXlCNEg7WUFDdkM7UUFDRjtRQUVBLDBDQUEwQztRQUMxQyxJQUFJbEMsZ0JBQWdCO1FBQ3BCLEtBQUssTUFBTUYsUUFBUW1DLFlBQVksRUFBRSxDQUFFO1lBQ2pDLE1BQU1HLGNBQWNqSSxVQUFVMkYsS0FBS0MsVUFBVTtZQUM3QyxJQUFJcUMsWUFBWTNELFdBQVcsT0FBT3RELFFBQVFpSCxZQUFZekQsUUFBUSxLQUFLLE1BQU16RCxPQUFPO2dCQUM5RSxNQUFNbUgsZUFBZW5DLGtCQUFrQkosS0FBS0ssV0FBVyxFQUFFTCxLQUFLTSxVQUFVLEVBQUVOLEtBQUtDLFVBQVUsRUFBRUQsS0FBS08sU0FBUztnQkFDekdMLGlCQUFpQnFDO1lBQ25CO1FBQ0Y7UUFFQSxvQkFBb0I7UUFDcEIsTUFBTS9CLGVBQWU7UUFFckIsK0RBQStEO1FBQy9ELG1EQUFtRDtRQUNuRCxJQUFJQyxhQUFhO1FBRWpCLDhEQUE4RDtRQUM5RCxNQUFNQyxrQkFBaUJ6QixrQkFBQUEsU0FBU1MsS0FBSyxjQUFkVCxzQ0FBQUEsZ0JBQWdCRSxJQUFJLENBQUMsQ0FBQ3dCLE9BQzNDQSxLQUFLQyxJQUFJLElBQUtELENBQUFBLEtBQUtDLElBQUksQ0FBQ2xHLFFBQVEsQ0FBQyxpQkFBaUJpRyxLQUFLQyxJQUFJLENBQUNsRyxRQUFRLENBQUMsYUFBWTtRQUVuRixJQUFJZ0csZ0JBQWdCO1lBQ2xCLE1BQU1HLFFBQVFILGVBQWVFLElBQUksQ0FBQ0MsS0FBSyxDQUFDO1lBQ3hDLElBQUlBLE9BQU87Z0JBQ1QsTUFBTUMsYUFBYUMsV0FBV0YsS0FBSyxDQUFDLEVBQUU7Z0JBQ3RDSixhQUFhLENBQUMsS0FBS0s7Z0JBQ25CdkcsUUFBUXlDLEdBQUcsQ0FBQyw0Q0FBNER5RCxPQUExQkssWUFBVyxpQkFBMEIsT0FBWEw7WUFDMUU7UUFDRjtRQUNBLElBQUlBLGVBQWUsR0FBR0EsYUFBYSxDQUFDLEdBQUcsV0FBVzs7UUFFbEQsNkRBQTZEO1FBQzdELCtDQUErQztRQUMvQyxJQUFJTztRQUNKLElBQUk1RixVQUFVLEtBQUtxRixlQUFlLENBQUMsSUFBSTtZQUNyQywrQ0FBK0M7WUFDL0NPLGNBQWNQO1FBQ2hCLE9BQU87WUFDTCxrREFBa0Q7WUFDbERPLGNBQWNQLGFBQWNQLENBQUFBLGdCQUFnQk0sWUFBVztRQUN6RDtRQUVBLGdEQUFnRDtRQUNoRCxNQUFNUyxtQkFBbUJoRixLQUFLaUYsR0FBRyxDQUFDaEIsZUFBZTtRQUNqRCxNQUFNaUIsb0JBQW9CbEYsS0FBS2lGLEdBQUcsQ0FBQ2pGLEtBQUttRixHQUFHLENBQUNKLGFBQWEsQ0FBQyxRQUFRO1FBRWxFLE1BQU0sRUFBRXhHLE9BQU9nSSxXQUFXLEVBQUUsR0FBRyxNQUFNekksbURBQVFBLENBQzFDb0QsSUFBSSxDQUFDLHdCQUNMQyxNQUFNLENBQUM7WUFDTm9DLGFBQWF5QjtZQUNieEIsY0FBYzBCO1FBQ2hCLEdBQ0MzRCxFQUFFLENBQUMsTUFBTXdFO1FBRVosSUFBSVEsYUFBYTtZQUNmakksUUFBUUMsS0FBSyxDQUFDLHlDQUF5Q2dJO1lBQ3ZEakksUUFBUUMsS0FBSyxDQUFDLG9CQUFvQjZHLEtBQUtDLFNBQVMsQ0FBQ2tCLGFBQWEsTUFBTTtZQUNwRWpJLFFBQVFDLEtBQUssQ0FBQyxrQkFBa0I7Z0JBQUVpRCxJQUFJdUU7Z0JBQVV4QyxhQUFhVTtnQkFBZVQsY0FBY3VCO1lBQVk7UUFDeEcsT0FBTztZQUNMekcsUUFBUXlDLEdBQUcsQ0FBQyxxQ0FBNkRrRCxPQUF4QmpCLFNBQVNoQyxVQUFVLEVBQUMsTUFBb0MrRCxPQUFoQ2QsZUFBYyxvQkFBOEIsT0FBWmMsYUFBWTtRQUN2SDtJQUVGLEVBQUUsT0FBT3RELEtBQUs7UUFDWm5ELFFBQVFDLEtBQUssQ0FBQyxzQ0FBc0NrRDtJQUN0RDtBQUNGO0FBRUEsd0VBQXdFO0FBQ3hFLGVBQWUrRSxzQ0FBc0NoRyxRQUFlLEVBQUVnQyxTQUFnQjtJQUNwRixJQUFJO1FBQ0ZsRSxRQUFReUMsR0FBRyxDQUFDO1FBQ1p6QyxRQUFReUMsR0FBRyxDQUFDLDJCQUFpQyxPQUFoQlAsU0FBU3hCLE1BQU0sRUFBQztRQUM3Q1YsUUFBUXlDLEdBQUcsQ0FBQyw0QkFBbUMsT0FBakJ5QixVQUFVeEQsTUFBTSxFQUFDO1FBRS9DLCtCQUErQjtRQUMvQixNQUFNLEVBQUUwRSxNQUFNK0MsVUFBVSxFQUFFbEksT0FBT21JLFVBQVUsRUFBRSxHQUFHLE1BQU01SSxtREFBUUEsQ0FDM0RvRCxJQUFJLENBQUMsd0JBQ0wwQyxNQUFNLENBQUM7UUFFVixJQUFJOEMsWUFBWTtZQUNkcEksUUFBUUMsS0FBSyxDQUFDLDBDQUEwQ21JO1lBQ3hEO1FBQ0Y7UUFFQSxJQUFJLENBQUNELGNBQWNBLFdBQVd6SCxNQUFNLEtBQUssR0FBRztZQUMxQ1YsUUFBUXlDLEdBQUcsQ0FBQztZQUNaO1FBQ0Y7UUFFQXpDLFFBQVF5QyxHQUFHLENBQUMsc0JBQThCLE9BQWxCMEYsV0FBV3pILE1BQU0sRUFBQztRQUUxQyxzQkFBc0I7UUFDdEIsS0FBSyxNQUFNbUUsVUFBVXNELFdBQVk7WUFDL0IsSUFBSTtnQkFDRm5JLFFBQVF5QyxHQUFHLENBQUMsb0NBQW9Eb0MsT0FBMUJBLE9BQU8zQixFQUFFLEVBQUMsa0JBQW1DLE9BQW5CMkIsT0FBT0MsV0FBVztnQkFFbEYsb0JBQW9CO2dCQUNwQixNQUFNSixXQUFXeEMsU0FBUzBDLElBQUksQ0FBQ3lELENBQUFBLE9BQVFBLEtBQUtuRixFQUFFLEtBQUsyQixPQUFPQyxXQUFXO2dCQUNyRSxJQUFJLENBQUNKLFVBQVU7b0JBQ2IxRSxRQUFReUMsR0FBRyxDQUFDLG9DQUE4QyxPQUFWb0MsT0FBTzNCLEVBQUU7b0JBQ3pEO2dCQUNGO2dCQUVBbEQsUUFBUXlDLEdBQUcsQ0FBQyxnQ0FBNkNpQyxPQUF2QkEsU0FBU2hDLFVBQVUsRUFBQyxLQUFzQixPQUFuQmdDLFNBQVMvQixTQUFTO2dCQUUzRSw0Q0FBNEM7Z0JBQzVDLE1BQU1pRixXQUFXMUQsVUFBVU0sTUFBTSxDQUFDLENBQUNpQixPQUNqQ0EsS0FBS1gsV0FBVyxLQUFLRCxPQUFPQyxXQUFXLElBQ3ZDVyxLQUFLcEQsTUFBTSxLQUFLLGNBQ2hCb0QsS0FBS0ssV0FBVyxJQUFJTCxLQUFLQyxVQUFVLElBQUlELEtBQUtNLFVBQVUsSUFBSU4sS0FBS08sU0FBUztnQkFHMUVoRyxRQUFReUMsR0FBRyxDQUFDLHNCQUE0QixPQUFoQm1GLFNBQVNsSCxNQUFNLEVBQUM7Z0JBRXhDLDJDQUEyQztnQkFDM0MsSUFBSWlGLGdCQUFnQjtnQkFDcEIsS0FBSyxNQUFNRixRQUFRbUMsU0FBVTtvQkFDM0IsTUFBTWhDLFdBQVdDLGtCQUFrQkosS0FBS0ssV0FBVyxFQUFFTCxLQUFLTSxVQUFVLEVBQUVOLEtBQUtDLFVBQVUsRUFBRUQsS0FBS08sU0FBUztvQkFDckdoRyxRQUFReUMsR0FBRyxDQUFDLHVCQUF5QmdELE9BQVpBLEtBQUt2QyxFQUFFLEVBQUMsTUFBMkJ1QyxPQUF2QkEsS0FBS0ssV0FBVyxFQUFDLFFBQTJCRixPQUFyQkgsS0FBS0MsVUFBVSxFQUFDLE9BQWMsT0FBVEUsVUFBUztvQkFDMUZELGlCQUFpQkM7Z0JBQ25CO2dCQUVBNUYsUUFBUXlDLEdBQUcsQ0FBQyw0Q0FBZ0QsT0FBZGtEO2dCQUU5QyxvQ0FBb0M7Z0JBQ3BDLE1BQU1NLGVBQWU7Z0JBRXJCLCtEQUErRDtnQkFDL0QsbURBQW1EO2dCQUNuRCxJQUFJQyxhQUFhckIsT0FBT0ssWUFBWSxJQUFJO2dCQUV4QyxnRkFBZ0Y7Z0JBQ2hGLElBQUlnQixlQUFlLEtBQUtyQixPQUFPaEUsS0FBSyxLQUFLLEdBQUc7d0JBRW5CNkQ7b0JBRHZCLHdDQUF3QztvQkFDeEMsTUFBTXlCLGtCQUFpQnpCLGtCQUFBQSxTQUFTUyxLQUFLLGNBQWRULHNDQUFBQSxnQkFBZ0JFLElBQUksQ0FBQyxDQUFDd0IsT0FDM0NBLEtBQUtDLElBQUksSUFBS0QsQ0FBQUEsS0FBS0MsSUFBSSxDQUFDbEcsUUFBUSxDQUFDLGlCQUFpQmlHLEtBQUtDLElBQUksQ0FBQ2xHLFFBQVEsQ0FBQyxhQUFZO29CQUVuRixJQUFJZ0csZ0JBQWdCO3dCQUNsQixNQUFNRyxRQUFRSCxlQUFlRSxJQUFJLENBQUNDLEtBQUssQ0FBQzt3QkFDeEMsSUFBSUEsT0FBTzs0QkFDVCxNQUFNQyxhQUFhQyxXQUFXRixLQUFLLENBQUMsRUFBRTs0QkFDdENKLGFBQWEsQ0FBQyxLQUFLSzs0QkFDbkJ2RyxRQUFReUMsR0FBRyxDQUFDLHVEQUF1RXlELE9BQTFCSyxZQUFXLGlCQUEwQixPQUFYTDt3QkFDckY7b0JBQ0Y7b0JBQ0EsSUFBSUEsZUFBZSxHQUFHQSxhQUFhLENBQUMsR0FBRyxXQUFXOztnQkFDcEQ7Z0JBRUEsNkRBQTZEO2dCQUM3RCwrQ0FBK0M7Z0JBQy9DLElBQUlPO2dCQUNKLElBQUk1QixPQUFPaEUsS0FBSyxLQUFLLEtBQUtxRixlQUFlLENBQUMsSUFBSTtvQkFDNUMsK0NBQStDO29CQUMvQ08sY0FBY1A7Z0JBQ2hCLE9BQU87b0JBQ0wsa0RBQWtEO29CQUNsRE8sY0FBY1AsYUFBY1AsQ0FBQUEsZ0JBQWdCTSxZQUFXO2dCQUN6RDtnQkFDQSxNQUFNUyxtQkFBbUJoRixLQUFLaUYsR0FBRyxDQUFDaEIsZUFBZTtnQkFDakQsTUFBTWlCLG9CQUFvQmxGLEtBQUtpRixHQUFHLENBQUNqRixLQUFLbUYsR0FBRyxDQUFDSixhQUFhLENBQUMsUUFBUTtnQkFFbEV6RyxRQUFReUMsR0FBRyxDQUFDLHdDQUEyRG1FLE9BQTdCRixrQkFBaUIsY0FBOEIsT0FBbEJFO2dCQUV2RSxvQkFBb0I7Z0JBQ3BCLE1BQU0sRUFBRTNHLE9BQU9nSSxXQUFXLEVBQUUsR0FBRyxNQUFNekksbURBQVFBLENBQzFDb0QsSUFBSSxDQUFDLHdCQUNMQyxNQUFNLENBQUM7b0JBQ05vQyxhQUFheUI7b0JBQ2J4QixjQUFjMEI7Z0JBQ2hCLEdBQ0MzRCxFQUFFLENBQUMsTUFBTTRCLE9BQU8zQixFQUFFO2dCQUVyQixJQUFJK0UsYUFBYTtvQkFDZmpJLFFBQVFDLEtBQUssQ0FBQywyQkFBcUMsT0FBVjRFLE9BQU8zQixFQUFFLEVBQUMsTUFBSStFO2dCQUN6RCxPQUFPO29CQUNMakksUUFBUXlDLEdBQUcsQ0FBQyxxQ0FBNkRpRSxPQUF4QmhDLFNBQVNoQyxVQUFVLEVBQUMsTUFBdUNrRSxPQUFuQ0Ysa0JBQWlCLG9CQUFvQyxPQUFsQkUsbUJBQWtCO2dCQUNoSTtZQUVGLEVBQUUsT0FBT3pELEtBQUs7Z0JBQ1puRCxRQUFRQyxLQUFLLENBQUMsNkJBQXVDLE9BQVY0RSxPQUFPM0IsRUFBRSxFQUFDLE1BQUlDO1lBQzNEO1FBQ0Y7UUFFQW5ELFFBQVF5QyxHQUFHLENBQUM7SUFFZCxFQUFFLE9BQU9VLEtBQUs7UUFDWm5ELFFBQVFDLEtBQUssQ0FBQyxpQ0FBaUNrRDtJQUNqRDtBQUNGO0FBRUEsa0RBQWtEO0FBQ2xELGVBQWVtRjtJQUNiLElBQUk7UUFDRnRJLFFBQVF5QyxHQUFHLENBQUM7UUFFWiwrQkFBK0I7UUFDL0IsTUFBTSxFQUFFMkMsTUFBTStDLFVBQVUsRUFBRWxJLE9BQU9tSSxVQUFVLEVBQUUsR0FBRyxNQUFNNUksbURBQVFBLENBQzNEb0QsSUFBSSxDQUFDLHdCQUNMMEMsTUFBTSxDQUFDO1FBRVYsSUFBSThDLFlBQVk7WUFDZHBJLFFBQVFDLEtBQUssQ0FBQyxrREFBa0RtSTtZQUNoRTtRQUNGO1FBRUEsSUFBSSxDQUFDRCxjQUFjQSxXQUFXekgsTUFBTSxLQUFLLEdBQUc7WUFDMUNWLFFBQVF5QyxHQUFHLENBQUM7WUFDWjtRQUNGO1FBRUF6QyxRQUFReUMsR0FBRyxDQUFDLFNBQTJCLE9BQWxCMEYsV0FBV3pILE1BQU0sRUFBQztRQUV2Qyx5QkFBeUI7UUFDekIsS0FBSyxNQUFNbUUsVUFBVXNELFdBQVk7WUFDL0IsSUFBSTtnQkFDRixNQUFNLEVBQUVsSSxPQUFPZ0ksV0FBVyxFQUFFLEdBQUcsTUFBTXpJLG1EQUFRQSxDQUMxQ29ELElBQUksQ0FBQyx3QkFDTEMsTUFBTSxDQUFDO29CQUNOb0MsYUFBYTtvQkFDYkMsY0FBYyxDQUFDLEdBQUcsa0NBQWtDO2dCQUN0RCxHQUNDakMsRUFBRSxDQUFDLE1BQU00QixPQUFPM0IsRUFBRTtnQkFFckIsSUFBSStFLGFBQWE7b0JBQ2ZqSSxRQUFRQyxLQUFLLENBQUMsNEJBQXNDLE9BQVY0RSxPQUFPM0IsRUFBRSxFQUFDLE1BQUkrRTtnQkFDMUQsT0FBTztvQkFDTGpJLFFBQVF5QyxHQUFHLENBQUMsa0JBQTRCLE9BQVZvQyxPQUFPM0IsRUFBRSxFQUFDO2dCQUMxQztZQUVGLEVBQUUsT0FBT0MsS0FBSztnQkFDWm5ELFFBQVFDLEtBQUssQ0FBQywwQkFBb0MsT0FBVjRFLE9BQU8zQixFQUFFLEVBQUMsTUFBSUM7WUFDeEQ7UUFDRjtRQUVBbkQsUUFBUXlDLEdBQUcsQ0FBQztJQUVkLEVBQUUsT0FBT1UsS0FBSztRQUNabkQsUUFBUUMsS0FBSyxDQUFDLCtCQUErQmtEO0lBQy9DO0FBQ0Y7QUFFTyxTQUFTb0Y7SUFDZCxNQUFNLENBQUNDLE9BQU9DLFNBQVMsR0FBR25KLCtDQUFRQSxDQUFRLEVBQUU7SUFDNUMsTUFBTSxDQUFDK0ksTUFBTUssUUFBUSxHQUFHcEosK0NBQVFBLENBQVEsRUFBRTtJQUMxQyxNQUFNLENBQUNxSixXQUFXQyxhQUFhLEdBQUd0SiwrQ0FBUUEsQ0FBUSxFQUFFO0lBQ3BELE1BQU0sQ0FBQ3VKLGtCQUFrQkMsb0JBQW9CLEdBQUd4SiwrQ0FBUUEsQ0FBUSxFQUFFO0lBQ2xFLE1BQU0sQ0FBQ3lKLE9BQU9DLFNBQVMsR0FBRzFKLCtDQUFRQSxDQUFRLEVBQUU7SUFDNUMsTUFBTSxDQUFDMkosT0FBT0MsU0FBUyxHQUFHNUosK0NBQVFBLENBQVEsRUFBRTtJQUM1QyxNQUFNLENBQUMyRSxvQkFBb0JrRixzQkFBc0IsR0FBRzdKLCtDQUFRQSxDQUFRLEVBQUU7SUFDdEUsTUFBTSxDQUFDOEosT0FBT0MsU0FBUyxHQUFHL0osK0NBQVFBLENBQVEsRUFBRTtJQUM1QyxNQUFNLENBQUNnSyxTQUFTQyxXQUFXLEdBQUdqSywrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNXLE9BQU91SixTQUFTLEdBQUdsSywrQ0FBUUEsQ0FBZ0I7SUFDbEQsTUFBTSxDQUFDbUssZUFBZUMsaUJBQWlCLEdBQUdwSywrQ0FBUUEsQ0FBeUIsQ0FBQztJQUU1RSw4QkFBOEI7SUFDOUIsTUFBTXFLLFdBQVc7UUFDZixJQUFJO1lBQ0ZKLFdBQVc7WUFDWEMsU0FBUztZQUNUeEosUUFBUXlDLEdBQUcsQ0FBQztZQUVaLGlDQUFpQztZQUNqQyxNQUFNLEVBQUUyQyxNQUFNLEVBQUV3RSxPQUFPLEVBQUUsRUFBRSxHQUFHLE1BQU1wSyxtREFBUUEsQ0FBQ3FLLElBQUksQ0FBQ0MsVUFBVTtZQUM1RDlKLFFBQVF5QyxHQUFHLENBQUMsb0JBQW9CbUgsVUFBVSxtQkFBbUI7WUFFN0QsSUFBSSxDQUFDQSxTQUFTO2dCQUNaNUosUUFBUStKLElBQUksQ0FBQztnQkFDYnRCLFNBQVMsRUFBRTtnQkFDWEMsUUFBUSxFQUFFO2dCQUNWRSxhQUFhLEVBQUU7Z0JBQ2ZFLG9CQUFvQixFQUFFO2dCQUN0QkUsU0FBUyxFQUFFO2dCQUNYRSxTQUFTLEVBQUU7Z0JBQ1hDLHNCQUFzQixFQUFFO2dCQUN4QkUsU0FBUyxFQUFFO2dCQUNYRSxXQUFXO2dCQUNYO1lBQ0Y7WUFFQSwyQkFBMkI7WUFDM0J2SixRQUFReUMsR0FBRyxDQUFDO1lBQ1osTUFBTSxFQUFFMkMsTUFBTTRFLFFBQVEsRUFBRS9KLE9BQU9nSyxTQUFTLEVBQUUsR0FBRyxNQUFNekssbURBQVFBLENBQ3hEb0QsSUFBSSxDQUFDLGNBQ0wwQyxNQUFNLENBQUMsTUFDUDRFLEtBQUssQ0FBQztZQUVULElBQUlELFdBQVc7Z0JBQ2JqSyxRQUFRQyxLQUFLLENBQUMsb0NBQW9DZ0s7Z0JBQ2xEakssUUFBUUMsS0FBSyxDQUFDLHVCQUF1QjZHLEtBQUtDLFNBQVMsQ0FBQ2tELFdBQVcsTUFBTTtZQUN2RSxPQUFPO2dCQUNMakssUUFBUXlDLEdBQUcsQ0FBQztZQUNkO1lBRUEsYUFBYTtZQUNiekMsUUFBUXlDLEdBQUcsQ0FBQztZQUNaLE1BQU0sRUFBRTJDLE1BQU0rRSxTQUFTLEVBQUVsSyxPQUFPbUssVUFBVSxFQUFFLEdBQUcsTUFBTTVLLG1EQUFRQSxDQUMxRG9ELElBQUksQ0FBQyxTQUNMMEMsTUFBTSxDQUFDLEtBQ1ArRSxLQUFLLENBQUM7WUFFVCxJQUFJRCxZQUFZO2dCQUNkcEssUUFBUUMsS0FBSyxDQUFDLHdCQUF3Qm1LO2dCQUN0Q3BLLFFBQVFDLEtBQUssQ0FBQyx3QkFBd0I2RyxLQUFLQyxTQUFTLENBQUNxRCxZQUFZLE1BQU07WUFDekUsT0FBTztnQkFDTHBLLFFBQVF5QyxHQUFHLENBQUMsaUJBQWlCMEgsQ0FBQUEsc0JBQUFBLGdDQUFBQSxVQUFXekosTUFBTSxLQUFJO2dCQUNsRCtILFNBQVMwQixhQUFhLEVBQUU7WUFDMUI7WUFFQSxZQUFZO1lBQ1puSyxRQUFReUMsR0FBRyxDQUFDO1lBQ1osTUFBTSxFQUFFMkMsTUFBTWxELFFBQVEsRUFBRWpDLE9BQU9xSyxTQUFTLEVBQUUsR0FBRyxNQUFNOUssbURBQVFBLENBQ3hEb0QsSUFBSSxDQUFDLFFBQ0wwQyxNQUFNLENBQUMsS0FDUCtFLEtBQUssQ0FBQztZQUVULElBQUlDLFdBQVc7Z0JBQ2J0SyxRQUFRQyxLQUFLLENBQUMsdUJBQXVCcUs7Z0JBQ3JDdEssUUFBUUMsS0FBSyxDQUFDLHVCQUF1QjZHLEtBQUtDLFNBQVMsQ0FBQ3VELFdBQVcsTUFBTTtZQUN2RSxPQUFPO2dCQUNMdEssUUFBUXlDLEdBQUcsQ0FBQyxnQkFBZ0JQLENBQUFBLHFCQUFBQSwrQkFBQUEsU0FBVXhCLE1BQU0sS0FBSTtnQkFFaEQsNkVBQTZFO2dCQUM3RSxnREFBZ0Q7Z0JBQ2hELDhDQUE4QztnQkFFOUMsMkNBQTJDO2dCQUMzQ2dJLFFBQVF4RyxZQUFZLEVBQUU7WUFDeEI7WUFFQSxrQkFBa0I7WUFDbEJsQyxRQUFReUMsR0FBRyxDQUFDO1lBQ1osTUFBTSxFQUFFMkMsTUFBTW1GLGFBQWEsRUFBRXRLLE9BQU91SyxjQUFjLEVBQUUsR0FBRyxNQUFNaEwsbURBQVFBLENBQ2xFb0QsSUFBSSxDQUFDLGNBQ0wwQyxNQUFNLENBQUMsS0FDUCtFLEtBQUssQ0FBQyxjQUFjO2dCQUFFSSxXQUFXO1lBQU07WUFFMUMsSUFBSUQsZ0JBQWdCO2dCQUNsQnhLLFFBQVFDLEtBQUssQ0FBQyw2QkFBNkJ1SztZQUM3QyxPQUFPO2dCQUNMeEssUUFBUXlDLEdBQUcsQ0FBQyxzQkFBc0I4SCxDQUFBQSwwQkFBQUEsb0NBQUFBLGNBQWU3SixNQUFNLEtBQUk7Z0JBQzNEa0ksYUFBYTJCLGlCQUFpQixFQUFFO1lBQ2xDO1lBRUEsMEJBQTBCO1lBQzFCdkssUUFBUXlDLEdBQUcsQ0FBQztZQUNaLE1BQU0sRUFBRTJDLE1BQU1zRixhQUFhLEVBQUV6SyxPQUFPMEssY0FBYyxFQUFFLEdBQUcsTUFBTW5MLG1EQUFRQSxDQUNsRW9ELElBQUksQ0FBQyxzQkFDTDBDLE1BQU0sQ0FBQyxLQUNQK0UsS0FBSyxDQUFDLGNBQWM7Z0JBQUVJLFdBQVc7WUFBTTtZQUUxQyxJQUFJRSxnQkFBZ0I7Z0JBQ2xCM0ssUUFBUUMsS0FBSyxDQUFDLHFDQUFxQzBLO2dCQUNuRDdCLG9CQUFvQixFQUFFO1lBQ3hCLE9BQU87Z0JBQ0w5SSxRQUFReUMsR0FBRyxDQUFDLDhCQUE4QmlJLENBQUFBLDBCQUFBQSxvQ0FBQUEsY0FBZWhLLE1BQU0sS0FBSTtnQkFDbkVvSSxvQkFBb0I0QixpQkFBaUIsRUFBRTtZQUN6QztZQUVBLGFBQWE7WUFDYjFLLFFBQVF5QyxHQUFHLENBQUM7WUFDWixNQUFNLEVBQUUyQyxNQUFNd0YsU0FBUyxFQUFFM0ssT0FBTzRLLFVBQVUsRUFBRSxHQUFHLE1BQU1yTCxtREFBUUEsQ0FDMURvRCxJQUFJLENBQUMsU0FDTDBDLE1BQU0sQ0FBQyxLQUNQK0UsS0FBSyxDQUFDLGNBQWM7Z0JBQUVJLFdBQVc7WUFBTTtZQUUxQyxJQUFJSSxZQUFZO2dCQUNkN0ssUUFBUUMsS0FBSyxDQUFDLHdCQUF3QjRLO2dCQUN0QzdCLFNBQVMsRUFBRTtZQUNiLE9BQU87Z0JBQ0xoSixRQUFReUMsR0FBRyxDQUFDLGlCQUFpQm1JLENBQUFBLHNCQUFBQSxnQ0FBQUEsVUFBV2xLLE1BQU0sS0FBSTtnQkFDbERzSSxTQUFTNEIsYUFBYSxFQUFFO1lBQzFCO1lBRU0sYUFBYTtZQUNiNUssUUFBUXlDLEdBQUcsQ0FBQztZQUNaLE1BQU0sRUFBRTJDLE1BQU1sQixTQUFTLEVBQUVqRSxPQUFPNEgsVUFBVSxFQUFFLEdBQUcsTUFBTXJJLG1EQUFRQSxDQUMxRG9ELElBQUksQ0FBQyxTQUNMMEMsTUFBTSxDQUFDLEtBQ1ArRSxLQUFLLENBQUMsY0FBYztnQkFBRUksV0FBVztZQUFNO1lBRTFDLElBQUk1QyxZQUFZO2dCQUNkN0gsUUFBUUMsS0FBSyxDQUFDLHdCQUF3QjRIO2dCQUN0Q3FCLFNBQVMsRUFBRTtZQUNiLE9BQU87Z0JBQ0xsSixRQUFReUMsR0FBRyxDQUFDLGlCQUFpQnlCLENBQUFBLHNCQUFBQSxnQ0FBQUEsVUFBV3hELE1BQU0sS0FBSTtnQkFDbER3SSxTQUFTaEYsYUFBYSxFQUFFO1lBQzFCO1lBRUEsNEJBQTRCO1lBQzVCbEUsUUFBUXlDLEdBQUcsQ0FBQztZQUNaLE1BQU0sRUFBRTJDLE1BQU0wRixlQUFlLEVBQUU3SyxPQUFPOEssZ0JBQWdCLEVBQUUsR0FBRyxNQUFNdkwsbURBQVFBLENBQ3RFb0QsSUFBSSxDQUFDLHdCQUNMMEMsTUFBTSxDQUFDLEtBQ1ArRSxLQUFLLENBQUMsUUFBUTtnQkFBRUksV0FBVztZQUFNLEdBQ2pDSixLQUFLLENBQUMsU0FBUztnQkFBRUksV0FBVztZQUFNO1lBRXJDLElBQUlNLGtCQUFrQjtnQkFDcEIvSyxRQUFRQyxLQUFLLENBQUMsdUNBQXVDOEs7Z0JBQ3JENUIsc0JBQXNCLEVBQUU7WUFDMUIsT0FBTztnQkFDTG5KLFFBQVF5QyxHQUFHLENBQUMsZ0NBQWdDcUksQ0FBQUEsNEJBQUFBLHNDQUFBQSxnQkFBaUJwSyxNQUFNLEtBQUk7Z0JBQ3ZFeUksc0JBQXNCMkIsbUJBQW1CLEVBQUU7Z0JBRTNDLDBEQUEwRDtnQkFDMUQ5SyxRQUFReUMsR0FBRyxDQUFDO2dCQUNaLE1BQU11Qiw2QkFBNkI5QixZQUFZLEVBQUUsRUFBRTRJLG1CQUFtQixFQUFFLEVBQUU1RyxhQUFhLEVBQUU7WUFDM0Y7WUFFTixhQUFhO1lBQ2JsRSxRQUFReUMsR0FBRyxDQUFDO1lBQ1osTUFBTSxFQUFFMkMsTUFBTTRGLFNBQVMsRUFBRS9LLE9BQU9nTCxVQUFVLEVBQUUsR0FBRyxNQUFNekwsbURBQVFBLENBQzFEb0QsSUFBSSxDQUFDLFNBQ0wwQyxNQUFNLENBQUMsS0FDUCtFLEtBQUssQ0FBQyxjQUFjO2dCQUFFSSxXQUFXO1lBQU07WUFFMUMsSUFBSVEsWUFBWTtnQkFDZGpMLFFBQVFDLEtBQUssQ0FBQyx3QkFBd0JnTDtnQkFDdEM1QixTQUFTLEVBQUU7WUFDYixPQUFPO2dCQUNMckosUUFBUXlDLEdBQUcsQ0FBQyxpQkFBaUJ1SSxDQUFBQSxzQkFBQUEsZ0NBQUFBLFVBQVd0SyxNQUFNLEtBQUk7Z0JBQ2xEMkksU0FBUzJCLGFBQWEsRUFBRTtZQUMxQjtZQUVBaEwsUUFBUXlDLEdBQUcsQ0FBQztZQUVaLHdEQUF3RDtZQUN4RCxJQUFJO2dCQUNGLE1BQU0sRUFBRTJDLE1BQU04RixTQUFTLEVBQUVqTCxPQUFPa0wsUUFBUSxFQUFFLEdBQUcsTUFBTTNMLG1EQUFRQSxDQUN4RG9ELElBQUksQ0FBQyxtQkFDTDBDLE1BQU0sQ0FBQztnQkFDVixJQUFJNkYsVUFBVTtvQkFDWixNQUFNQyxNQUFNLENBQUNELHFCQUFBQSwrQkFBRCxTQUFtQkUsT0FBTyxLQUFJQyxPQUFPSDtvQkFDakRuTCxRQUFRK0osSUFBSSxDQUFDLDBEQUEwRHFCO29CQUN2RTFCLGlCQUFpQixDQUFDO2dCQUNwQixPQUFPO29CQUNMLE1BQU02QixNQUE4QixDQUFDO29CQUNyQyxLQUFLLE1BQU1DLE9BQU9OLGFBQWEsRUFBRSxDQUFFO3dCQUNqQyxJQUFJTSxJQUFJQyxPQUFPLElBQUlELElBQUlFLEtBQUssRUFBRUgsR0FBRyxDQUFDQyxJQUFJQyxPQUFPLENBQUMsR0FBR0QsSUFBSUUsS0FBSztvQkFDNUQ7b0JBQ0FoQyxpQkFBaUI2QjtnQkFDbkI7WUFDRixFQUFFLE9BQU9JLEdBQUc7Z0JBQ1YzTCxRQUFRK0osSUFBSSxDQUFDLGtDQUFrQyxDQUFDNEIsY0FBQUEsd0JBQUQsRUFBWU4sT0FBTyxLQUFJTTtnQkFDdEVqQyxpQkFBaUIsQ0FBQztZQUNwQjtRQUVGLEVBQUUsT0FBT3ZHLEtBQUs7WUFDWm5ELFFBQVFDLEtBQUssQ0FBQyxzQkFBc0JrRDtZQUNwQ3FHLFNBQVNyRyxlQUFleUksUUFBUXpJLElBQUlrSSxPQUFPLEdBQUc7UUFDaEQsU0FBVTtZQUNSOUIsV0FBVztRQUNiO0lBQ0Y7SUFFQSxxQkFBcUI7SUFDckJoSyxnREFBU0E7cUNBQUM7WUFDUm9LO1FBRUEsNERBQTREO1FBQzVELHlDQUF5QztRQUN6QywwREFBMEQ7UUFDMUQsNERBQTREO1FBQzVELG9DQUFvQztRQUVwQyx5Q0FBeUM7UUFDM0M7b0NBQUcsRUFBRTtJQUVMLGlDQUFpQztJQUNqQ3BLLGdEQUFTQTtxQ0FBQztZQUNSLDZCQUE2QjtZQUM3QixNQUFNc00sb0JBQW9Cck0sbURBQVFBLENBQy9Cc00sT0FBTyxDQUFDLGlCQUNSQyxFQUFFLENBQUMsb0JBQW9CO2dCQUFFQyxPQUFPO2dCQUFLQyxRQUFRO2dCQUFVQyxPQUFPO1lBQVE7K0RBQUc7b0JBQ3hFdkM7Z0JBQ0Y7OERBQ0N3QyxTQUFTO1lBRVosNEJBQTRCO1lBQzVCLE1BQU1DLG1CQUFtQjVNLG1EQUFRQSxDQUM5QnNNLE9BQU8sQ0FBQyxnQkFDUkMsRUFBRSxDQUFDLG9CQUFvQjtnQkFBRUMsT0FBTztnQkFBS0MsUUFBUTtnQkFBVUMsT0FBTztZQUFPOzhEQUFHO29CQUN2RXZDO2dCQUNGOzZEQUNDd0MsU0FBUztZQUVaLGtDQUFrQztZQUNsQyxNQUFNRSx3QkFBd0I3TSxtREFBUUEsQ0FDbkNzTSxPQUFPLENBQUMsc0JBQ1JDLEVBQUUsQ0FBQyxvQkFBb0I7Z0JBQUVDLE9BQU87Z0JBQUtDLFFBQVE7Z0JBQVVDLE9BQU87WUFBYTttRUFBRztvQkFDN0V2QztnQkFDRjtrRUFDQ3dDLFNBQVM7WUFFWiwwQ0FBMEM7WUFDMUMsTUFBTUcsd0JBQXdCOU0sbURBQVFBLENBQ25Dc00sT0FBTyxDQUFDLHNCQUNSQyxFQUFFLENBQUMsb0JBQW9CO2dCQUFFQyxPQUFPO2dCQUFLQyxRQUFRO2dCQUFVQyxPQUFPO1lBQXFCO21FQUFHO29CQUNyRnZDO2dCQUNGO2tFQUNDd0MsU0FBUztZQUVaLDZCQUE2QjtZQUM3QixNQUFNSSxvQkFBb0IvTSxtREFBUUEsQ0FDL0JzTSxPQUFPLENBQUMsaUJBQ1JDLEVBQUUsQ0FBQyxvQkFBb0I7Z0JBQUVDLE9BQU87Z0JBQUtDLFFBQVE7Z0JBQVVDLE9BQU87WUFBUTsrREFBRztvQkFDeEV2QztnQkFDRjs4REFDQ3dDLFNBQVM7WUFFWiw2QkFBNkI7WUFDN0IsTUFBTUssb0JBQW9CaE4sbURBQVFBLENBQy9Cc00sT0FBTyxDQUFDLGlCQUNSQyxFQUFFLENBQUMsb0JBQW9CO2dCQUFFQyxPQUFPO2dCQUFLQyxRQUFRO2dCQUFVQyxPQUFPO1lBQVE7K0RBQUc7b0JBQ3hFdkM7Z0JBQ0Y7OERBQ0N3QyxTQUFTO1lBRVosNkJBQTZCO1lBQzdCLE1BQU1NLG9CQUFvQmpOLG1EQUFRQSxDQUMvQnNNLE9BQU8sQ0FBQyxpQkFDUkMsRUFBRSxDQUFDLG9CQUFvQjtnQkFBRUMsT0FBTztnQkFBS0MsUUFBUTtnQkFBVUMsT0FBTztZQUFROytEQUFHO29CQUN4RXZDO2dCQUNGOzhEQUNDd0MsU0FBUztZQUVaOzZDQUFPO29CQUNMTixrQkFBa0JhLFdBQVc7b0JBQzdCTixpQkFBaUJNLFdBQVc7b0JBQzVCTCxzQkFBc0JLLFdBQVc7b0JBQ2pDSixzQkFBc0JJLFdBQVc7b0JBQ2pDSCxrQkFBa0JHLFdBQVc7b0JBQzdCRixrQkFBa0JFLFdBQVc7b0JBQzdCRCxrQkFBa0JDLFdBQVc7Z0JBQy9COztRQUNGO29DQUFHLEVBQUU7SUFFTCxrQkFBa0I7SUFDbEIsTUFBTUMsVUFBVSxPQUFPeks7UUFDckIsSUFBSTtZQUNGbEMsUUFBUXlDLEdBQUcsQ0FBQyxtQ0FBbUNQO1lBQy9DbEMsUUFBUXlDLEdBQUcsQ0FBQyxzQkFBc0JxRSxLQUFLQyxTQUFTLENBQUM3RSxVQUFVLE1BQU07WUFFakUsMkJBQTJCO1lBQzNCLE1BQU0wSyxpQkFBaUI7Z0JBQUM7Z0JBQU07Z0JBQWM7Z0JBQWE7Z0JBQWU7YUFBVztZQUNuRixNQUFNQyxnQkFBZ0JELGVBQWVwSSxNQUFNLENBQUNzSSxDQUFBQSxRQUFTLENBQUM1SyxRQUFRLENBQUM0SyxNQUFNO1lBRXJFLElBQUlELGNBQWNuTSxNQUFNLEdBQUcsR0FBRztnQkFDNUIsTUFBTVQsUUFBUSxJQUFJMkwsTUFBTSw0QkFBcUQsT0FBekJpQixjQUFjRSxJQUFJLENBQUM7Z0JBQ3ZFL00sUUFBUUMsS0FBSyxDQUFDLHFCQUFxQkE7Z0JBQ25DLE1BQU1BO1lBQ1I7WUFFQSxrQ0FBa0M7WUFDbEMsTUFBTSxFQUFFbUYsTUFBTTRILFlBQVksRUFBRS9NLE9BQU9nTixVQUFVLEVBQUUsR0FBRyxNQUFNek4sbURBQVFBLENBQzdEb0QsSUFBSSxDQUFDLFFBQ0wwQyxNQUFNLENBQUMsTUFDUHJDLEVBQUUsQ0FBQyxjQUFjZixTQUFTUSxVQUFVLEVBQ3BDTyxFQUFFLENBQUMsYUFBYWYsU0FBU1MsU0FBUyxFQUNsQ00sRUFBRSxDQUFDLGVBQWVmLFNBQVNnTCxXQUFXLEVBQ3RDM0gsTUFBTTtZQUVULElBQUl5SCxnQkFBZ0IsQ0FBQ0MsWUFBWTtnQkFDL0IsTUFBTWhOLFFBQVEsSUFBSTJMLE1BQU0seUJBQWdEMUosT0FBdkJBLFNBQVNRLFVBQVUsRUFBQyxLQUFzQixPQUFuQlIsU0FBU1MsU0FBUyxFQUFDO2dCQUMzRjNDLFFBQVFDLEtBQUssQ0FBQywwQkFBMEJBO2dCQUN4QyxNQUFNQTtZQUNSO1lBRUEsTUFBTSxFQUFFbUYsSUFBSSxFQUFFbkYsS0FBSyxFQUFFLEdBQUcsTUFBTVQsbURBQVFBLENBQ25Db0QsSUFBSSxDQUFDLFFBQ0x5QyxNQUFNLENBQUM7Z0JBQUNuRDthQUFTLEVBQ2pCb0QsTUFBTSxHQUNOQyxNQUFNO1lBRVQsSUFBSXRGLE9BQU87Z0JBQ1RELFFBQVFDLEtBQUssQ0FBQywrQkFBK0JBO2dCQUM3Q0QsUUFBUUMsS0FBSyxDQUFDLGtCQUFrQjZHLEtBQUtDLFNBQVMsQ0FBQzlHLE9BQU8sTUFBTTtnQkFDNURELFFBQVFDLEtBQUssQ0FBQyxlQUFlQSxNQUFNdUgsSUFBSTtnQkFDdkN4SCxRQUFRQyxLQUFLLENBQUMsa0JBQWtCQSxNQUFNb0wsT0FBTztnQkFDN0NyTCxRQUFRQyxLQUFLLENBQUMsZUFBZUEsTUFBTWtOLElBQUk7Z0JBQ3ZDLE1BQU1sTjtZQUNSO1lBRUFELFFBQVF5QyxHQUFHLENBQUMsbUNBQW1DMkM7WUFDL0MsTUFBTXVFO1lBQ04sT0FBT3ZFO1FBQ1QsRUFBRSxPQUFPakMsS0FBSztZQUNabkQsUUFBUUMsS0FBSyxDQUFDLHNCQUFzQmtEO1lBQ3BDbkQsUUFBUUMsS0FBSyxDQUFDLGtCQUFrQjZHLEtBQUtDLFNBQVMsQ0FBQzVELEtBQUssTUFBTTtZQUMxRCxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxxQkFBcUI7SUFDckIsTUFBTWlLLGFBQWEsT0FBT2xLLElBQVltSztRQUNwQyxJQUFJO1lBQ0ZyTixRQUFReUMsR0FBRyxDQUFDLHFDQUFxQ1MsSUFBSW1LO1lBRXJELE1BQU0sRUFBRWpJLElBQUksRUFBRW5GLEtBQUssRUFBRSxHQUFHLE1BQU1ULG1EQUFRQSxDQUNuQ29ELElBQUksQ0FBQyxRQUNMQyxNQUFNLENBQUN3SyxTQUNQcEssRUFBRSxDQUFDLE1BQU1DLElBQ1RvQyxNQUFNLEdBQ05DLE1BQU07WUFFVCxJQUFJdEYsT0FBTztnQkFDVEQsUUFBUUMsS0FBSyxDQUFDLGlDQUFpQ0E7Z0JBQy9DLE1BQU1BO1lBQ1I7WUFFQUQsUUFBUXlDLEdBQUcsQ0FBQztZQUNaLE1BQU1rSDtZQUNOLE9BQU92RTtRQUNULEVBQUUsT0FBT2pDLEtBQUs7WUFDWm5ELFFBQVFDLEtBQUssQ0FBQyx3QkFBd0JrRDtZQUN0QyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxxQkFBcUI7SUFDckIsTUFBTW1LLGFBQWEsT0FBT3BLO1FBQ3hCLElBQUk7WUFDRixNQUFNLEVBQUVqRCxLQUFLLEVBQUUsR0FBRyxNQUFNVCxtREFBUUEsQ0FDN0JvRCxJQUFJLENBQUMsUUFDTDJLLE1BQU0sR0FDTnRLLEVBQUUsQ0FBQyxNQUFNQztZQUVaLElBQUlqRCxPQUFPLE1BQU1BO1lBRWpCLE1BQU0wSixXQUFXLGtCQUFrQjs7UUFDckMsRUFBRSxPQUFPeEcsS0FBSztZQUNabkQsUUFBUUMsS0FBSyxDQUFDLHdCQUF3QmtEO1lBQ3RDLE1BQU1BO1FBQ1I7SUFDRjtJQUVBLFdBQVc7SUFDWCxNQUFNcUssVUFBVSxPQUFPQztRQUNyQixJQUFJO1lBQ0Z6TixRQUFReUMsR0FBRyxDQUFDLDRCQUE0QmdMO1lBRXhDLE1BQU0sRUFBRXJJLElBQUksRUFBRW5GLEtBQUssRUFBRSxHQUFHLE1BQU1ULG1EQUFRQSxDQUNuQ29ELElBQUksQ0FBQyxTQUNMeUMsTUFBTSxDQUFDO2dCQUFDb0k7YUFBUyxFQUNqQm5JLE1BQU0sR0FDTkMsTUFBTTtZQUVULElBQUl0RixPQUFPO2dCQUNURCxRQUFRQyxLQUFLLENBQUMsK0JBQStCQTtnQkFDN0NELFFBQVFDLEtBQUssQ0FBQyxrQkFBa0I2RyxLQUFLQyxTQUFTLENBQUM5RyxPQUFPLE1BQU07Z0JBQzVELE1BQU1BO1lBQ1I7WUFFQUQsUUFBUXlDLEdBQUcsQ0FBQyw0QkFBNEIyQztZQUN4QyxNQUFNdUU7WUFDTixPQUFPdkU7UUFDVCxFQUFFLE9BQU9qQyxLQUFLO1lBQ1puRCxRQUFRQyxLQUFLLENBQUMsc0JBQXNCa0Q7WUFDcEMsTUFBTUE7UUFDUjtJQUNGO0lBRUEsY0FBYztJQUNkLE1BQU11SyxhQUFhLE9BQU94SyxJQUFZbUs7UUFDcEMsSUFBSTtZQUNGLE1BQU0sRUFBRWpJLElBQUksRUFBRW5GLEtBQUssRUFBRSxHQUFHLE1BQU1ULG1EQUFRQSxDQUNuQ29ELElBQUksQ0FBQyxTQUNMQyxNQUFNLENBQUN3SyxTQUNQcEssRUFBRSxDQUFDLE1BQU1DLElBQ1RvQyxNQUFNLEdBQ05DLE1BQU07WUFFVCxJQUFJdEYsT0FBTyxNQUFNQTtZQUVqQixNQUFNMEosV0FBVyxrQkFBa0I7O1lBQ25DLE9BQU92RTtRQUNULEVBQUUsT0FBT2pDLEtBQUs7WUFDWm5ELFFBQVFDLEtBQUssQ0FBQyx3QkFBd0JrRDtZQUN0QyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxjQUFjO0lBQ2QsTUFBTXdLLGFBQWEsT0FBT3pLO1FBQ3hCLElBQUk7WUFDRixNQUFNLEVBQUVqRCxLQUFLLEVBQUUsR0FBRyxNQUFNVCxtREFBUUEsQ0FDN0JvRCxJQUFJLENBQUMsU0FDTDJLLE1BQU0sR0FDTnRLLEVBQUUsQ0FBQyxNQUFNQztZQUVaLElBQUlqRCxPQUFPLE1BQU1BO1lBRWpCLE1BQU0wSixXQUFXLGtCQUFrQjs7UUFDckMsRUFBRSxPQUFPeEcsS0FBSztZQUNabkQsUUFBUUMsS0FBSyxDQUFDLHdCQUF3QmtEO1lBQ3RDLE1BQU1BO1FBQ1I7SUFDRjtJQUVBLGlCQUFpQjtJQUNqQixNQUFNeUssZUFBZSxPQUFPckQ7UUFDMUIsSUFBSTtZQUNGdkssUUFBUXlDLEdBQUcsQ0FBQyxrQ0FBa0M4SDtZQUU5QywyQkFBMkI7WUFDM0IsSUFBSUEsY0FBY3BGLEtBQUssS0FBSyxRQUFRb0YsY0FBY3BGLEtBQUssS0FBSzBJLFdBQVc7Z0JBQ3JFdEQsY0FBY3BGLEtBQUssR0FBRztZQUN4QjtZQUVBLE1BQU0sRUFBRUMsSUFBSSxFQUFFbkYsS0FBSyxFQUFFLEdBQUcsTUFBTVQsbURBQVFBLENBQ25Db0QsSUFBSSxDQUFDLGNBQ0x5QyxNQUFNLENBQUM7Z0JBQUNrRjthQUFjLEVBQ3RCakYsTUFBTSxHQUNOQyxNQUFNO1lBRVQsSUFBSXRGLE9BQU87Z0JBQ1RELFFBQVFDLEtBQUssQ0FBQyxxQ0FBcUNBO2dCQUNuREQsUUFBUUMsS0FBSyxDQUFDLGtCQUFrQjZHLEtBQUtDLFNBQVMsQ0FBQzlHLE9BQU8sTUFBTTtnQkFDNUQsTUFBTUE7WUFDUjtZQUVBRCxRQUFReUMsR0FBRyxDQUFDLGtDQUFrQzJDO1lBQzlDLE1BQU11RSxXQUFXLGtCQUFrQjs7WUFDbkMsT0FBT3ZFO1FBQ1QsRUFBRSxPQUFPakMsS0FBSztZQUNabkQsUUFBUUMsS0FBSyxDQUFDLDRCQUE0QmtEO1lBQzFDLE1BQU1BO1FBQ1I7SUFDRjtJQUVBLG9CQUFvQjtJQUNwQixNQUFNMkssa0JBQWtCLE9BQU81SyxJQUFZbUs7UUFDekMsSUFBSTtZQUNGck4sUUFBUXlDLEdBQUcsQ0FBQyxvQ0FBb0NTLElBQUltSztZQUVwRCwyQkFBMkI7WUFDM0IsSUFBSUEsUUFBUWxJLEtBQUssS0FBSyxRQUFRa0ksUUFBUWxJLEtBQUssS0FBSzBJLFdBQVc7Z0JBQ3pEUixRQUFRbEksS0FBSyxHQUFHO1lBQ2xCO1lBRUEsTUFBTSxFQUFFQyxJQUFJLEVBQUVuRixLQUFLLEVBQUUsR0FBRyxNQUFNVCxtREFBUUEsQ0FDbkNvRCxJQUFJLENBQUMsY0FDTEMsTUFBTSxDQUFDd0ssU0FDUHBLLEVBQUUsQ0FBQyxNQUFNQyxJQUNUb0MsTUFBTSxHQUNOQyxNQUFNO1lBRVQsSUFBSXRGLE9BQU87Z0JBQ1RELFFBQVFDLEtBQUssQ0FBQyx1Q0FBdUNBO2dCQUNyREQsUUFBUUMsS0FBSyxDQUFDLGtCQUFrQjZHLEtBQUtDLFNBQVMsQ0FBQzlHLE9BQU8sTUFBTTtnQkFDNUQsTUFBTUE7WUFDUjtZQUVBRCxRQUFReUMsR0FBRyxDQUFDLG9DQUFvQzJDO1lBQ2hELE1BQU11RSxXQUFXLGtCQUFrQjs7WUFDbkMsT0FBT3ZFO1FBQ1QsRUFBRSxPQUFPakMsS0FBSztZQUNabkQsUUFBUUMsS0FBSyxDQUFDLDhCQUE4QmtEO1lBQzVDbkQsUUFBUUMsS0FBSyxDQUFDLGtCQUFrQjZHLEtBQUtDLFNBQVMsQ0FBQzVELEtBQUssTUFBTTtZQUMxRCxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxNQUFNNEsscUJBQXFCLE9BQU9DO1FBQ2hDLElBQUk7WUFDRmhPLFFBQVF5QyxHQUFHLENBQUM7WUFDWnpDLFFBQVF5QyxHQUFHLENBQUMseUJBQXlCdUw7WUFFckMsbUNBQW1DO1lBQ25DLE1BQU1DLE9BQU9DLE9BQU9DLFVBQVU7WUFDOUJuTyxRQUFReUMsR0FBRyxDQUFDLG1CQUFtQndMO1lBRS9CLG9EQUFvRDtZQUNwRCxNQUFNLEVBQUUvSyxFQUFFLEVBQUUsR0FBR2tMLGVBQWUsR0FBR0o7WUFFakMsNkRBQTZEO1lBQzdELE1BQU1LLGVBQWU7Z0JBQ25CbkwsSUFBSStLO2dCQUNKSyxnQkFBZ0JGLGNBQWNFLGNBQWM7Z0JBQzVDQyxZQUFZSCxjQUFjRyxVQUFVO2dCQUNwQ0MsVUFBVUosY0FBY0ksUUFBUTtnQkFDaENDLFlBQVlMLGNBQWNLLFVBQVU7Z0JBQ3BDQyxhQUFhTixjQUFjTSxXQUFXO2dCQUN0Q0MsMEJBQTBCUCxjQUFjTyx3QkFBd0I7Z0JBQ2hFQywyQkFBMkJSLGNBQWNRLHlCQUF5QjtnQkFDbEVDLDJCQUEyQlQsY0FBY1MseUJBQXlCO2dCQUNsRUMsbUJBQW1CVixjQUFjVSxpQkFBaUI7Z0JBQ2xEQyxvQkFBb0JYLGNBQWNXLGtCQUFrQixJQUFJLEVBQUU7WUFDNUQ7WUFFQSxpRUFBaUU7WUFDakUsSUFBSVgsY0FBY1ksTUFBTSxFQUFFO2dCQUN2QlgsYUFBcUJXLE1BQU0sR0FBR1osY0FBY1ksTUFBTTtZQUNyRDtZQUNBLElBQUlaLGNBQWNqSixLQUFLLEVBQUU7Z0JBQ3RCa0osYUFBcUJsSixLQUFLLEdBQUdpSixjQUFjakosS0FBSztZQUNuRDtZQUVBbkYsUUFBUXlDLEdBQUcsQ0FBQyx5Q0FBeUM0TDtZQUNyRHJPLFFBQVF5QyxHQUFHLENBQUMsd0JBQXdCcUUsS0FBS0MsU0FBUyxDQUFDc0gsY0FBYyxNQUFNO1lBRXZFLDJCQUEyQjtZQUMzQixNQUFNekIsaUJBQWlCO2dCQUFDO2dCQUFNO2dCQUFrQjtnQkFBYztnQkFBWTtnQkFBYztnQkFBNEI7Z0JBQTZCO2dCQUE2QjthQUFvQjtZQUNsTSxNQUFNQyxnQkFBZ0JELGVBQWVwSSxNQUFNLENBQUNzSSxDQUFBQSxRQUFTLENBQUMsWUFBcUIsQ0FBQ0EsTUFBTSxJQUFJLFlBQXFCLENBQUNBLE1BQU0sS0FBSztZQUV2SCxJQUFJRCxjQUFjbk0sTUFBTSxHQUFHLEdBQUc7Z0JBQzVCVixRQUFRQyxLQUFLLENBQUMsNEJBQTRCNE07Z0JBQzFDLE1BQU0sSUFBSWpCLE1BQU0sNEJBQXFELE9BQXpCaUIsY0FBY0UsSUFBSSxDQUFDO1lBQ2pFO1lBRUEvTSxRQUFReUMsR0FBRyxDQUFDO1lBRVosTUFBTSxFQUFFMkMsSUFBSSxFQUFFbkYsS0FBSyxFQUFFLEdBQUcsTUFBTVQsbURBQVFBLENBQ25Db0QsSUFBSSxDQUFDLHNCQUNMeUMsTUFBTSxDQUFDO2dCQUFDZ0o7YUFBYSxFQUNyQi9JLE1BQU07WUFFVCxJQUFJckYsT0FBTztnQkFDVEQsUUFBUUMsS0FBSyxDQUFDLDhDQUE4Q0E7Z0JBQzVERCxRQUFRQyxLQUFLLENBQUMsb0JBQW9CNkcsS0FBS0MsU0FBUyxDQUFDOUcsT0FBTyxNQUFNO2dCQUM5REQsUUFBUUMsS0FBSyxDQUFDLGlCQUFpQkEsTUFBTXVILElBQUk7Z0JBQ3pDeEgsUUFBUUMsS0FBSyxDQUFDLG9CQUFvQkEsTUFBTW9MLE9BQU87Z0JBQy9DckwsUUFBUUMsS0FBSyxDQUFDLGlCQUFpQkEsTUFBTWtOLElBQUk7Z0JBQ3pDLE1BQU1sTjtZQUNSO1lBRUFELFFBQVF5QyxHQUFHLENBQUMsMkNBQTJDMkM7WUFDdkQsTUFBTXVFLFdBQVcsa0JBQWtCOztZQUNuQyxPQUFPdkU7UUFDVCxFQUFFLE9BQU9qQyxLQUFLO1lBQ1puRCxRQUFRQyxLQUFLLENBQUMscUNBQXFDa0Q7WUFDbkRuRCxRQUFRQyxLQUFLLENBQUMsb0JBQW9CNkcsS0FBS0MsU0FBUyxDQUFDNUQsS0FBSyxNQUFNO1lBQzVELE1BQU1BO1FBQ1I7SUFDRjtJQUVBLE1BQU04TCx3QkFBd0IsT0FBT3hILFVBQWtCNEY7UUFDckQsSUFBSTtZQUNGck4sUUFBUXlDLEdBQUcsQ0FBQywyQ0FBMkNnRixVQUFVNEY7WUFDakUsTUFBTSxFQUFFakksSUFBSSxFQUFFbkYsS0FBSyxFQUFFLEdBQUcsTUFBTVQsbURBQVFBLENBQ25Db0QsSUFBSSxDQUFDLHNCQUNMQyxNQUFNLENBQUN3SyxTQUNQcEssRUFBRSxDQUFDLE1BQU13RSxVQUNUbkMsTUFBTTtZQUVULElBQUlyRixPQUFPO2dCQUNURCxRQUFRQyxLQUFLLENBQUMsOENBQThDQTtnQkFDNUQsTUFBTUE7WUFDUjtZQUVBRCxRQUFReUMsR0FBRyxDQUFDLDJDQUEyQzJDO1lBQ3ZELE1BQU11RSxXQUFXLGtCQUFrQjs7WUFDbkMsT0FBT3ZFO1FBQ1QsRUFBRSxPQUFPakMsS0FBSztZQUNabkQsUUFBUUMsS0FBSyxDQUFDLHFDQUFxQ2tEO1lBQ25ELE1BQU1BO1FBQ1I7SUFDRjtJQUVBLE1BQU0rTCxVQUFVLE9BQU9DO1FBQ3JCLElBQUk7WUFDRm5QLFFBQVF5QyxHQUFHLENBQUMsNEJBQTRCME07WUFDeEMsTUFBTSxFQUFFL0osSUFBSSxFQUFFbkYsS0FBSyxFQUFFLEdBQUcsTUFBTVQsbURBQVFBLENBQ25Db0QsSUFBSSxDQUFDLFNBQ0x5QyxNQUFNLENBQUM7Z0JBQUM4SjthQUFTLEVBQ2pCN0osTUFBTTtZQUVULElBQUlyRixPQUFPO2dCQUNURCxRQUFRQyxLQUFLLENBQUMsK0JBQStCQTtnQkFDN0MsTUFBTUE7WUFDUjtZQUVBRCxRQUFReUMsR0FBRyxDQUFDLDRCQUE0QjJDO1lBQ3hDLE1BQU11RSxXQUFXLGtCQUFrQjs7WUFDbkMsT0FBT3ZFO1FBQ1QsRUFBRSxPQUFPakMsS0FBSztZQUNabkQsUUFBUUMsS0FBSyxDQUFDLHNCQUFzQmtEO1lBQ3BDLE1BQU1BO1FBQ1I7SUFDRjtJQUVBLE1BQU1pTSxlQUFlLE9BQU9DLFFBQWdCbEs7UUFDMUMsSUFBSTtZQUNGbkYsUUFBUXlDLEdBQUcsQ0FBQyxnQ0FBZ0M0TTtZQUM1QyxNQUFNLEVBQUVqSyxJQUFJLEVBQUVuRixLQUFLLEVBQUUsR0FBRyxNQUFNVCxtREFBUUEsQ0FDbkNvRCxJQUFJLENBQUMsU0FDTEMsTUFBTSxDQUFDO2dCQUNOUixRQUFRO2dCQUNSaU4sY0FBYyxJQUFJcFAsT0FBTzBELFdBQVc7Z0JBQ3BDdUIsT0FBT0EsU0FBUztZQUNsQixHQUNDbEMsRUFBRSxDQUFDLE1BQU1vTSxRQUNUL0osTUFBTTtZQUVULElBQUlyRixPQUFPO2dCQUNURCxRQUFRQyxLQUFLLENBQUMsbUNBQW1DQTtnQkFDakQsTUFBTUE7WUFDUjtZQUVBRCxRQUFReUMsR0FBRyxDQUFDLGdDQUFnQzJDO1lBQzVDLE1BQU11RSxXQUFXLGtCQUFrQjs7WUFDbkMsT0FBT3ZFO1FBQ1QsRUFBRSxPQUFPakMsS0FBSztZQUNabkQsUUFBUUMsS0FBSyxDQUFDLDBCQUEwQmtEO1lBQ3hDLE1BQU1BO1FBQ1I7SUFDRjtJQUVBLE1BQU1vTSxjQUFjLE9BQU9GLFFBQWdCRyxlQUF1QnBKO1FBQ2hFLElBQUk7WUFDRnBHLFFBQVF5QyxHQUFHLENBQUMsNEJBQTRCNE0sUUFBUUc7WUFFaEQsOEJBQThCO1lBQzlCLE1BQU0sRUFBRXBLLE1BQU1xSyxJQUFJLEVBQUV4UCxPQUFPbUksVUFBVSxFQUFFLEdBQUcsTUFBTTVJLG1EQUFRQSxDQUNyRG9ELElBQUksQ0FBQyxTQUNMMEMsTUFBTSxDQUFDLEtBQ1ByQyxFQUFFLENBQUMsTUFBTW9NLFFBQ1Q5SixNQUFNO1lBRVQsSUFBSTZDLGNBQWMsQ0FBQ3FILE1BQU07Z0JBQ3ZCLE1BQU0sSUFBSTdELE1BQU07WUFDbEI7WUFFQSx1QkFBdUI7WUFDdkIsTUFBTThELFVBQVUsQ0FBQ0QsS0FBS0UsV0FBVyxJQUFJLEtBQUtIO1lBQzFDLE1BQU1JLGVBQWVILEtBQUtJLE1BQU0sR0FBR0g7WUFDbkMsTUFBTUksWUFBWUYsZ0JBQWdCLElBQUksYUFBYTtZQUVuRCwrQkFBK0I7WUFDL0IsTUFBTUcsZUFBZTtnQkFDbkIxUCxNQUFNLElBQUlILE9BQU8wRCxXQUFXO2dCQUM1QmlNLFFBQVFMO2dCQUNScEosTUFBTUEsUUFBUTtnQkFDZDRKLFFBQVE7WUFDVjtZQUVBLGNBQWM7WUFDZCxNQUFNLEVBQUU1SyxJQUFJLEVBQUVuRixLQUFLLEVBQUUsR0FBRyxNQUFNVCxtREFBUUEsQ0FDbkNvRCxJQUFJLENBQUMsU0FDTEMsTUFBTSxDQUFDO2dCQUNOOE0sYUFBYUQ7Z0JBQ2JPLGtCQUFrQkw7Z0JBQ2xCdk4sUUFBUXlOO2dCQUNSUixjQUFjUSxjQUFjLGFBQWEsSUFBSTVQLE9BQU8wRCxXQUFXLEtBQUs7Z0JBQ3BFc00saUJBQWlCO3VCQUFLVCxLQUFLUyxlQUFlLElBQUksRUFBRTtvQkFBR0g7aUJBQWE7WUFDbEUsR0FDQzlNLEVBQUUsQ0FBQyxNQUFNb00sUUFDVC9KLE1BQU07WUFFVCxJQUFJckYsT0FBTztnQkFDVEQsUUFBUUMsS0FBSyxDQUFDLGtDQUFrQ0E7Z0JBQ2hELE1BQU1BO1lBQ1I7WUFFQUQsUUFBUXlDLEdBQUcsQ0FBQyw4QkFBOEIyQztZQUMxQyxNQUFNdUUsV0FBVyxrQkFBa0I7O1lBQ25DLE9BQU92RTtRQUNULEVBQUUsT0FBT2pDLEtBQUs7WUFDWm5ELFFBQVFDLEtBQUssQ0FBQyx5QkFBeUJrRDtZQUN2QyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxpQkFBaUI7SUFDakIsTUFBTWdOLFVBQVUsT0FBT0M7UUFDckIsSUFBSTtZQUNGcFEsUUFBUXlDLEdBQUcsQ0FBQyxnQkFBZ0IyTjtZQUU1QixNQUFNLEVBQUVoTCxJQUFJLEVBQUVuRixLQUFLLEVBQUUsR0FBRyxNQUFNVCxtREFBUUEsQ0FDbkNvRCxJQUFJLENBQUMsU0FDTHlDLE1BQU0sQ0FBQztnQkFBQytLO2FBQVMsRUFDakI5SyxNQUFNO1lBRVQsSUFBSXJGLE9BQU87Z0JBQ1RELFFBQVFDLEtBQUssQ0FBQyxzQkFBc0JBO2dCQUNwQyxNQUFNQTtZQUNSO1lBRUFELFFBQVF5QyxHQUFHLENBQUMsNEJBQTRCMkM7WUFDeEMsTUFBTXVFLFdBQVcsa0JBQWtCOztZQUNuQyxPQUFPdkU7UUFDVCxFQUFFLE9BQU9qQyxLQUFLO1lBQ1puRCxRQUFRQyxLQUFLLENBQUMsc0JBQXNCa0Q7WUFDcEMsTUFBTUE7UUFDUjtJQUNGO0lBRUEsTUFBTWtOLGFBQWEsT0FBT0MsUUFBZ0JqRDtRQUN4QyxJQUFJO1lBQ0ZyTixRQUFReUMsR0FBRyxDQUFDLGtCQUFrQjZOLFFBQVFqRDtZQUV0QyxNQUFNLEVBQUVqSSxJQUFJLEVBQUVuRixLQUFLLEVBQUUsR0FBRyxNQUFNVCxtREFBUUEsQ0FDbkNvRCxJQUFJLENBQUMsU0FDTEMsTUFBTSxDQUFDO2dCQUFFLEdBQUd3SyxPQUFPO2dCQUFFa0QsWUFBWSxJQUFJclEsT0FBTzBELFdBQVc7WUFBRyxHQUMxRFgsRUFBRSxDQUFDLE1BQU1xTixRQUNUaEwsTUFBTSxHQUNOQyxNQUFNO1lBRVQsSUFBSXRGLE9BQU87Z0JBQ1RELFFBQVFDLEtBQUssQ0FBQyx3QkFBd0JBO2dCQUN0QyxNQUFNQTtZQUNSO1lBRUFELFFBQVF5QyxHQUFHLENBQUMsOEJBQThCMkM7WUFFMUMseURBQXlEO1lBQ3pELElBQUlpSSxRQUFRaEwsTUFBTSxLQUFLLGNBQWMrQyxLQUFLTixXQUFXLEVBQUU7Z0JBQ3JEOUUsUUFBUXlDLEdBQUcsQ0FBQztnQkFDWixNQUFNMkUsOEJBQThCaEM7WUFDdEM7WUFFQSxNQUFNdUUsV0FBVyxrQkFBa0I7O1lBQ25DLE9BQU92RTtRQUNULEVBQUUsT0FBT2pDLEtBQUs7WUFDWm5ELFFBQVFDLEtBQUssQ0FBQyx3QkFBd0JrRDtZQUN0QyxNQUFNQTtRQUNSO0lBQ0Y7SUFHQSx5QkFBeUI7SUFDekIsTUFBTXFOLHVCQUF1QixPQUFPeEM7UUFDbEMsSUFBSTtZQUNGaE8sUUFBUXlDLEdBQUcsQ0FBQywrQkFBK0J1TDtZQUMzQ2hPLFFBQVF5QyxHQUFHLENBQUMsd0JBQXdCcUUsS0FBS0MsU0FBUyxDQUFDaUgsWUFBWSxNQUFNO1lBRXJFLDJCQUEyQjtZQUMzQixNQUFNcEIsaUJBQWlCO2dCQUFDO2dCQUFlO2dCQUFRO2dCQUFTO2dCQUFpQjtnQkFBZTthQUFlO1lBQ3ZHLE1BQU1DLGdCQUFnQkQsZUFBZXBJLE1BQU0sQ0FBQ3NJLENBQUFBLFFBQVNrQixVQUFVLENBQUNsQixNQUFNLEtBQUtlLGFBQWFHLFVBQVUsQ0FBQ2xCLE1BQU0sS0FBSztZQUU5RyxJQUFJRCxjQUFjbk0sTUFBTSxHQUFHLEdBQUc7Z0JBQzVCLE1BQU1ULFFBQVEsSUFBSTJMLE1BQU0sNEJBQXFELE9BQXpCaUIsY0FBY0UsSUFBSSxDQUFDO2dCQUN2RS9NLFFBQVFDLEtBQUssQ0FBQyxxQkFBcUJBO2dCQUNuQyxNQUFNQTtZQUNSO1lBRUEsMEVBQTBFO1lBQzFFLE1BQU0sRUFBRW1GLE1BQU1ULGNBQWMsRUFBRTFFLE9BQU9nTixVQUFVLEVBQUUsR0FBRyxNQUFNek4sbURBQVFBLENBQy9Eb0QsSUFBSSxDQUFDLHdCQUNMMEMsTUFBTSxDQUFDLE1BQ1ByQyxFQUFFLENBQUMsZUFBZStLLFdBQVdsSixXQUFXLEVBQ3hDN0IsRUFBRSxDQUFDLFFBQVErSyxXQUFXbE4sSUFBSSxFQUMxQm1DLEVBQUUsQ0FBQyxTQUFTK0ssV0FBV25OLEtBQUssRUFDNUIwRSxNQUFNO1lBRVQsSUFBSVosZ0JBQWdCO2dCQUNsQjNFLFFBQVF5QyxHQUFHLENBQUM7Z0JBQ1oscURBQXFEO2dCQUNyRCxNQUFNLEVBQUUyQyxJQUFJLEVBQUVuRixLQUFLLEVBQUUsR0FBRyxNQUFNVCxtREFBUUEsQ0FDbkNvRCxJQUFJLENBQUMsd0JBQ0xDLE1BQU0sQ0FBQztvQkFDTm1DLGVBQWVnSixXQUFXaEosYUFBYTtvQkFDdkNDLGFBQWErSSxXQUFXL0ksV0FBVztvQkFDbkNDLGNBQWM4SSxXQUFXOUksWUFBWTtvQkFDckNxTCxZQUFZLElBQUlyUSxPQUFPMEQsV0FBVztnQkFDcEMsR0FDQ1gsRUFBRSxDQUFDLE1BQU0wQixlQUFlekIsRUFBRSxFQUMxQm9DLE1BQU07Z0JBRVQsSUFBSXJGLE9BQU87b0JBQ1RELFFBQVFDLEtBQUssQ0FBQyxnREFBZ0RBO29CQUM5RCxNQUFNQTtnQkFDUjtnQkFFQUQsUUFBUXlDLEdBQUcsQ0FBQyw2Q0FBNkMyQztnQkFDekQsTUFBTXVFLFdBQVcsa0JBQWtCOztnQkFDbkMsT0FBT3ZFO1lBQ1Q7WUFFQSx3Q0FBd0M7WUFDeEMsTUFBTSxFQUFFQSxJQUFJLEVBQUVuRixLQUFLLEVBQUUsR0FBRyxNQUFNVCxtREFBUUEsQ0FDbkNvRCxJQUFJLENBQUMsd0JBQ0x5QyxNQUFNLENBQUM7Z0JBQUMySTthQUFXLEVBQ25CMUksTUFBTTtZQUVULElBQUlyRixPQUFPO2dCQUNURCxRQUFRQyxLQUFLLENBQUMsOENBQThDQTtnQkFDNURELFFBQVFDLEtBQUssQ0FBQyxrQkFBa0I2RyxLQUFLQyxTQUFTLENBQUM5RyxPQUFPLE1BQU07Z0JBQzVERCxRQUFRQyxLQUFLLENBQUMsZUFBZUEsTUFBTXVILElBQUk7Z0JBQ3ZDeEgsUUFBUUMsS0FBSyxDQUFDLGtCQUFrQkEsTUFBTW9MLE9BQU87Z0JBQzdDckwsUUFBUUMsS0FBSyxDQUFDLGVBQWVBLE1BQU1rTixJQUFJO2dCQUN2QyxNQUFNbE47WUFDUjtZQUVBRCxRQUFReUMsR0FBRyxDQUFDLDJDQUEyQzJDO1lBQ3ZELE1BQU11RSxXQUFXLGtCQUFrQjs7WUFDbkMsT0FBT3ZFO1FBQ1QsRUFBRSxPQUFPakMsS0FBSztZQUNabkQsUUFBUUMsS0FBSyxDQUFDLHFDQUFxQ2tEO1lBQ25EbkQsUUFBUUMsS0FBSyxDQUFDLGtCQUFrQjZHLEtBQUtDLFNBQVMsQ0FBQzVELEtBQUssTUFBTTtZQUMxRCxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxNQUFNc04sMEJBQTBCLE9BQU9oSixVQUFrQjRGO1FBQ3ZELElBQUk7WUFDRnJOLFFBQVF5QyxHQUFHLENBQUMsaUNBQWlDZ0YsVUFBVTRGO1lBRXZELE1BQU0sRUFBRWpJLElBQUksRUFBRW5GLEtBQUssRUFBRSxHQUFHLE1BQU1ULG1EQUFRQSxDQUNuQ29ELElBQUksQ0FBQyx3QkFDTEMsTUFBTSxDQUFDO2dCQUFFLEdBQUd3SyxPQUFPO2dCQUFFa0QsWUFBWSxJQUFJclEsT0FBTzBELFdBQVc7WUFBRyxHQUMxRFgsRUFBRSxDQUFDLE1BQU13RSxVQUNUbkMsTUFBTSxHQUNOQyxNQUFNO1lBRVQsSUFBSXRGLE9BQU87Z0JBQ1RELFFBQVFDLEtBQUssQ0FBQyx1Q0FBdUNBO2dCQUNyRCxNQUFNQTtZQUNSO1lBRUFELFFBQVF5QyxHQUFHLENBQUMsNkNBQTZDMkM7WUFDekQsTUFBTXVFLFdBQVcsa0JBQWtCOztZQUNuQyxPQUFPdkU7UUFDVCxFQUFFLE9BQU9qQyxLQUFLO1lBQ1puRCxRQUFRQyxLQUFLLENBQUMsdUNBQXVDa0Q7WUFDckQsTUFBTUE7UUFDUjtJQUNGO0lBRUEsTUFBTXVOLDBCQUEwQixPQUFPako7UUFDckMsSUFBSTtZQUNGekgsUUFBUXlDLEdBQUcsQ0FBQyxpQ0FBaUNnRjtZQUU3QyxNQUFNLEVBQUV4SCxLQUFLLEVBQUUsR0FBRyxNQUFNVCxtREFBUUEsQ0FDN0JvRCxJQUFJLENBQUMsd0JBQ0wySyxNQUFNLEdBQ050SyxFQUFFLENBQUMsTUFBTXdFO1lBRVosSUFBSXhILE9BQU87Z0JBQ1RELFFBQVFDLEtBQUssQ0FBQyx1Q0FBdUNBO2dCQUNyRCxNQUFNQTtZQUNSO1lBRUFELFFBQVF5QyxHQUFHLENBQUM7WUFDWixNQUFNa0gsV0FBVyxrQkFBa0I7O1FBQ3JDLEVBQUUsT0FBT3hHLEtBQUs7WUFDWm5ELFFBQVFDLEtBQUssQ0FBQyx1Q0FBdUNrRDtZQUNyRCxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSwwQkFBMEI7SUFDMUIsTUFBTXdOLGFBQWEsT0FBT0w7UUFDeEIsSUFBSTtZQUNGLE1BQU0sRUFBRXJRLEtBQUssRUFBRSxHQUFHLE1BQU1ULG1EQUFRQSxDQUM3Qm9ELElBQUksQ0FBQyxTQUNMMkssTUFBTSxHQUNOdEssRUFBRSxDQUFDLE1BQU1xTjtZQUVaLElBQUlyUSxPQUFPO2dCQUNURCxRQUFRQyxLQUFLLENBQUMsaUNBQWlDQTtnQkFDL0MsTUFBTUE7WUFDUjtZQUVBRCxRQUFReUMsR0FBRyxDQUFDO1lBQ1osTUFBTWtILFdBQVcsa0JBQWtCOztRQUNyQyxFQUFFLE9BQU94RyxLQUFLO1lBQ1puRCxRQUFRQyxLQUFLLENBQUMsd0JBQXdCa0Q7WUFDdEMsTUFBTUE7UUFDUjtJQUNGO0lBRUEsOEJBQThCO0lBQzlCLE1BQU15TixpQkFBaUIsT0FBT0M7UUFDNUIsSUFBSTtZQUNGLG1DQUFtQztZQUNuQyxNQUFNclIsbURBQVFBLENBQUNvRCxJQUFJLENBQUMsd0JBQXdCMkssTUFBTSxHQUFHdEssRUFBRSxDQUFDLGVBQWU0TjtZQUN2RSxNQUFNclIsbURBQVFBLENBQUNvRCxJQUFJLENBQUMsU0FBUzJLLE1BQU0sR0FBR3RLLEVBQUUsQ0FBQyxlQUFlNE47WUFFeEQsMkJBQTJCO1lBQzNCLE1BQU0sRUFBRTVRLEtBQUssRUFBRSxHQUFHLE1BQU1ULG1EQUFRQSxDQUM3Qm9ELElBQUksQ0FBQyxRQUNMMkssTUFBTSxHQUNOdEssRUFBRSxDQUFDLE1BQU00TjtZQUVaLElBQUk1USxPQUFPO2dCQUNURCxRQUFRQyxLQUFLLENBQUMscUNBQXFDQTtnQkFDbkQsTUFBTUE7WUFDUjtZQUVBRCxRQUFReUMsR0FBRyxDQUFDO1lBQ1osTUFBTWtILFdBQVcsa0JBQWtCOztRQUNyQyxFQUFFLE9BQU94RyxLQUFLO1lBQ1puRCxRQUFRQyxLQUFLLENBQUMsNEJBQTRCa0Q7WUFDMUMsTUFBTUE7UUFDUjtJQUNGO0lBRUEsa0JBQWtCO0lBQ2xCLE1BQU0yTixnQkFBZ0IsT0FBT0MsUUFBZ0IzSztRQUMzQyxJQUFJO1lBQ0YsK0JBQStCO1lBQy9CLE1BQU0sRUFBRWhCLE1BQU1sRCxRQUFRLEVBQUVqQyxPQUFPbUksVUFBVSxFQUFFLEdBQUcsTUFBTTVJLG1EQUFRQSxDQUN6RG9ELElBQUksQ0FBQyxRQUNMMEMsTUFBTSxDQUFDLGdCQUNQckMsRUFBRSxDQUFDLE1BQU04TixRQUNUeEwsTUFBTTtZQUVULElBQUk2QyxZQUFZLE1BQU1BO1lBRXRCLGlEQUFpRDtZQUNqRCxNQUFNNEksZUFBZTlPLENBQUFBLHFCQUFBQSwrQkFBQUEsU0FBVStPLFlBQVksS0FBSSxFQUFFO1lBRWpELDhCQUE4QjtZQUM5QixNQUFNQyxVQUFVO2dCQUNkaE8sSUFBSWhELEtBQUtpUixHQUFHLEdBQUdDLFFBQVE7Z0JBQ3ZCQyxTQUFTakw7Z0JBQ1RrTCxXQUFXLElBQUlwUixPQUFPMEQsV0FBVztnQkFDakMyTixXQUFXLE9BQU8sdUNBQXVDO1lBQzNEO1lBRUEsTUFBTUMsZUFBZTttQkFBSVI7Z0JBQWNFO2FBQVE7WUFFL0Msb0NBQW9DO1lBQ3BDLE1BQU0sRUFBRWpSLE9BQU9nSSxXQUFXLEVBQUUsR0FBRyxNQUFNekksbURBQVFBLENBQzFDb0QsSUFBSSxDQUFDLFFBQ0xDLE1BQU0sQ0FBQztnQkFBRW9PLGNBQWNPO1lBQWEsR0FDcEN2TyxFQUFFLENBQUMsTUFBTThOO1lBRVosSUFBSTlJLGFBQWEsTUFBTUE7WUFFdkJqSSxRQUFReUMsR0FBRyxDQUFDO1lBQ1osTUFBTWtILFlBQVksY0FBYztRQUNsQyxFQUFFLE9BQU8xSixPQUFPO1lBQ2RELFFBQVFDLEtBQUssQ0FBQyxzQkFBc0JBO1lBQ3BDLE1BQU1BO1FBQ1I7SUFDRjtJQUVBLE1BQU13UixxQkFBcUIsT0FBT1YsUUFBZ0JXO1FBQ2hELElBQUk7WUFDRiwrQkFBK0I7WUFDL0IsTUFBTSxFQUFFdE0sTUFBTWxELFFBQVEsRUFBRWpDLE9BQU9tSSxVQUFVLEVBQUUsR0FBRyxNQUFNNUksbURBQVFBLENBQ3pEb0QsSUFBSSxDQUFDLFFBQ0wwQyxNQUFNLENBQUMsZ0NBQ1ByQyxFQUFFLENBQUMsTUFBTThOLFFBQ1R4TCxNQUFNO1lBRVQsSUFBSTZDLFlBQVksTUFBTUE7WUFFdEIsTUFBTXVKLHFCQUFxQnpQLENBQUFBLHFCQUFBQSwrQkFBQUEsU0FBVStPLFlBQVksS0FBSSxFQUFFO1lBQ3ZELE1BQU1XLHVCQUF1QjFQLENBQUFBLHFCQUFBQSwrQkFBQUEsU0FBVTJQLGNBQWMsS0FBSSxFQUFFO1lBRTNELDBCQUEwQjtZQUMxQixNQUFNQyxnQkFBZ0JILG1CQUFtQi9NLElBQUksQ0FBQyxDQUFDd0IsT0FBY0EsS0FBS2xELEVBQUUsS0FBS3dPO1lBQ3pFLElBQUksQ0FBQ0ksZUFBZTtnQkFDbEIsTUFBTSxJQUFJbEcsTUFBTTtZQUNsQjtZQUVBLDJCQUEyQjtZQUMzQixNQUFNbUcscUJBQXFCSixtQkFBbUJuTixNQUFNLENBQUMsQ0FBQzRCLE9BQWNBLEtBQUtsRCxFQUFFLEtBQUt3TztZQUVoRiwrQ0FBK0M7WUFDL0MsTUFBTU0sZUFBZTtnQkFDbkIsR0FBR0YsYUFBYTtnQkFDaEJHLFlBQVksSUFBSS9SLE9BQU8wRCxXQUFXO1lBQ3BDO1lBQ0EsTUFBTXNPLHVCQUF1QjttQkFBSU47Z0JBQXNCSTthQUFhO1lBRXBFLHFCQUFxQjtZQUNyQixNQUFNLEVBQUUvUixPQUFPZ0ksV0FBVyxFQUFFLEdBQUcsTUFBTXpJLG1EQUFRQSxDQUMxQ29ELElBQUksQ0FBQyxRQUNMQyxNQUFNLENBQUM7Z0JBQ05vTyxjQUFjYztnQkFDZEYsZ0JBQWdCSztZQUNsQixHQUNDalAsRUFBRSxDQUFDLE1BQU04TjtZQUVaLElBQUk5SSxhQUFhLE1BQU1BO1lBRXZCakksUUFBUXlDLEdBQUcsQ0FBQztZQUNaLE1BQU1rSCxZQUFZLGNBQWM7UUFDbEMsRUFBRSxPQUFPMUosT0FBTztZQUNkRCxRQUFRQyxLQUFLLENBQUMsd0JBQXdCQTtZQUN0QyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxXQUFXO0lBQ1gsTUFBTWtTLFVBQVUsT0FBT0M7UUFDckIsSUFBSTtZQUNGcFMsUUFBUXlDLEdBQUcsQ0FBQyw2QkFBNkJxRSxLQUFLQyxTQUFTLENBQUNxTCxVQUFVLE1BQU07WUFDeEUsTUFBTSxFQUFFaE4sSUFBSSxFQUFFbkYsS0FBSyxFQUFFLEdBQUcsTUFBTVQsbURBQVFBLENBQ25Db0QsSUFBSSxDQUFDLFNBQ0x5QyxNQUFNLENBQUM7Z0JBQUMrTTthQUFTLEVBQ2pCOU0sTUFBTSxHQUNOQyxNQUFNO1lBRVQsSUFBSXRGLE9BQU87Z0JBQ1RELFFBQVFDLEtBQUssQ0FBQyxpQ0FBaUNBO2dCQUMvQ0QsUUFBUUMsS0FBSyxDQUFDLGlCQUFpQkEsTUFBTXVILElBQUk7Z0JBQ3pDeEgsUUFBUUMsS0FBSyxDQUFDLG9CQUFvQkEsTUFBTW9MLE9BQU87Z0JBQy9DckwsUUFBUUMsS0FBSyxDQUFDLG9CQUFvQkEsTUFBTW9TLE9BQU87Z0JBQy9DclMsUUFBUUMsS0FBSyxDQUFDLGlCQUFpQkEsTUFBTWtOLElBQUk7Z0JBQ3pDLE1BQU1sTjtZQUNSO1lBQ0EsTUFBTTBKO1lBQ04sT0FBT3ZFO1FBQ1QsRUFBRSxPQUFPakMsS0FBVTtZQUNqQm5ELFFBQVFDLEtBQUssQ0FBQyxzQkFBc0JrRDtZQUNwQ25ELFFBQVFDLEtBQUssQ0FBQyxrQkFBa0I2RyxLQUFLQyxTQUFTLENBQUM1RCxLQUFLLE1BQU07WUFDMUQsTUFBTUE7UUFDUjtJQUNGO0lBRUEsY0FBYztJQUNkLE1BQU1tUCxhQUFhLE9BQU9DLFFBQWdCbEY7UUFDeEMsSUFBSTtZQUNGLE1BQU0sRUFBRXBOLEtBQUssRUFBRSxHQUFHLE1BQU1ULG1EQUFRQSxDQUM3Qm9ELElBQUksQ0FBQyxTQUNMQyxNQUFNLENBQUN3SyxTQUNQcEssRUFBRSxDQUFDLE1BQU1zUDtZQUVaLElBQUl0UyxPQUFPLE1BQU1BO1lBQ2pCLE1BQU0wSjtRQUNSLEVBQUUsT0FBT3hHLEtBQUs7WUFDWm5ELFFBQVFDLEtBQUssQ0FBQyx3QkFBd0JrRDtZQUN0QyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxjQUFjO0lBQ2QsTUFBTXFQLGFBQWEsT0FBT0Q7UUFDeEIsSUFBSTtZQUNGLE1BQU0sRUFBRXRTLEtBQUssRUFBRSxHQUFHLE1BQU1ULG1EQUFRQSxDQUM3Qm9ELElBQUksQ0FBQyxTQUNMMkssTUFBTSxHQUNOdEssRUFBRSxDQUFDLE1BQU1zUDtZQUVaLElBQUl0UyxPQUFPLE1BQU1BO1lBQ2pCLE1BQU0wSjtRQUNSLEVBQUUsT0FBT3hHLEtBQUs7WUFDWm5ELFFBQVFDLEtBQUssQ0FBQyx3QkFBd0JrRDtZQUN0QyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxnQkFBZ0I7SUFDaEIsTUFBTXNQLGVBQWUsT0FBT0Y7UUFDMUIsSUFBSTtZQUNGLE1BQU0sRUFBRXRTLEtBQUssRUFBRSxHQUFHLE1BQU1ULG1EQUFRQSxDQUM3Qm9ELElBQUksQ0FBQyxTQUNMQyxNQUFNLENBQUM7Z0JBQ042UCxXQUFXO2dCQUNYcEQsY0FBYyxJQUFJcFAsT0FBTzBELFdBQVc7WUFDdEMsR0FDQ1gsRUFBRSxDQUFDLE1BQU1zUDtZQUVaLElBQUl0UyxPQUFPLE1BQU1BO1lBQ2pCLE1BQU0wSjtRQUNSLEVBQUUsT0FBT3hHLEtBQUs7WUFDWm5ELFFBQVFDLEtBQUssQ0FBQywwQkFBMEJrRDtZQUN4QyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxPQUFPO1FBQ0xxRjtRQUNBSDtRQUNBTTtRQUNBRTtRQUNBRTtRQUNBRTtRQUNBRztRQUNBRTtRQUNBcko7UUFDQTBKO1FBQ0FGO1FBQ0EsTUFBTWtKLGlCQUFnQjVCLE1BQWMsRUFBRXJGLEtBQW9CO1lBQ3hELElBQUk7Z0JBQ0YsSUFBSSxDQUFDcUYsUUFBUTtnQkFDYixJQUFJckYsT0FBTztvQkFDVCxlQUFlO29CQUNmLE1BQU0sRUFBRXpMLE9BQU8yUyxXQUFXLEVBQUUsR0FBRyxNQUFNcFQsbURBQVFBLENBQzFDb0QsSUFBSSxDQUFDLG1CQUNMaVEsTUFBTSxDQUFDO3dCQUFFcEgsU0FBU3NGO3dCQUFRckY7b0JBQU0sR0FBRzt3QkFBRW9ILFlBQVk7b0JBQVU7b0JBQzlELElBQUlGLGFBQWEsTUFBTUE7Z0JBQ3pCLE9BQU87b0JBQ0wsZUFBZTtvQkFDZixNQUFNLEVBQUUzUyxPQUFPOFMsUUFBUSxFQUFFLEdBQUcsTUFBTXZULG1EQUFRQSxDQUN2Q29ELElBQUksQ0FBQyxtQkFDTDJLLE1BQU0sR0FDTnRLLEVBQUUsQ0FBQyxXQUFXOE47b0JBQ2pCLElBQUlnQyxVQUFVLE1BQU1BO2dCQUN0QjtnQkFDQSxxQkFBcUI7Z0JBQ3JCckosaUJBQWlCLENBQUNzSjtvQkFDaEIsTUFBTUMsT0FBTzt3QkFBRSxHQUFHRCxJQUFJO29CQUFDO29CQUN2QixJQUFJdEgsT0FBT3VILElBQUksQ0FBQ2xDLE9BQU8sR0FBR3JGO3lCQUNyQixPQUFPdUgsSUFBSSxDQUFDbEMsT0FBTztvQkFDeEIsT0FBT2tDO2dCQUNUO1lBQ0YsRUFBRSxPQUFPdEgsR0FBRztnQkFDVixNQUFNeEksTUFBV3dJO2dCQUNqQixNQUFNUCxNQUFNakksQ0FBQUEsZ0JBQUFBLDBCQUFBQSxJQUFLa0ksT0FBTyxLQUFLLFFBQU9sSSxRQUFRLFdBQVdBLE1BQU0yRCxLQUFLQyxTQUFTLENBQUM1RCxJQUFHO2dCQUMvRW5ELFFBQVFDLEtBQUssQ0FBQyxpQ0FBaUNtTDtnQkFDL0MsOENBQThDO2dCQUM5QyxJQUFJQSxDQUFBQSxnQkFBQUEsMEJBQUFBLElBQUtqTCxRQUFRLENBQUMsaUJBQWVpTCxnQkFBQUEsMEJBQUFBLElBQUtqTCxRQUFRLENBQUMscUJBQW9CO29CQUNqRUgsUUFBUStKLElBQUksQ0FBQztnQkFDZjtnQkFDQSxNQUFNNEI7WUFDUjtRQUNGO1FBQ0FnQjtRQUNBUztRQUNBRTtRQUNBRTtRQUNBRTtRQUNBQztRQUNBQztRQUNBRTtRQUNBQztRQUNBa0I7UUFDQUM7UUFDQUU7UUFDQUc7UUFDQVk7UUFDQUU7UUFDQU07UUFDQUM7UUFDQTNNO1FBQ0F1TTtRQUNBQztRQUNBQztRQUNBSTtRQUNBVztRQUNBVTtRQUNBRztRQUNBRTtRQUNBQztJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxEZXZcXGJhbWFsaXRlLWhyLXN5c3RlbSBCZW1hbm5pbmdzbGlqc3RcXGhvb2tzXFx1c2Utc3VwYWJhc2UtZGF0YS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnXHJcbmltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnQC9saWIvc3VwYWJhc2UnXHJcblxyXG4vLyBGdW5jdGlvbiB0byBjYWxjdWxhdGUgd29yayBkYXlzIGZvciB2YXN0ZSBkaWVuc3QgYWZsb3NzZXJzIGJhc2VkIG9uIGhvdXJzXHJcbi8vIFVzZXMgMTItaG91ciBpbmNyZW1lbnRzOiAwLTEyaCA9IDAuNSBkYXksIDEyLTI0aCA9IDEuMCBkYXksIGV0Yy5cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVdvcmtEYXlzVmFzdGVEaWVuc3Qoc3RhcnREYXRlOiBzdHJpbmcsIHN0YXJ0VGltZTogc3RyaW5nLCBlbmREYXRlOiBzdHJpbmcsIGVuZFRpbWU6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgaWYgKCFzdGFydERhdGUgfHwgIWVuZERhdGUgfHwgIXN0YXJ0VGltZSB8fCAhZW5kVGltZSkgcmV0dXJuIDBcclxuXHJcbiAgLy8gUGFyc2UgYm90aCBERC1NTS1ZWVlZIGFuZCBJU08gZm9ybWF0IGRhdGVzXHJcbiAgY29uc3QgcGFyc2VEYXRlID0gKGRhdGVTdHI6IHN0cmluZyk6IERhdGUgPT4ge1xyXG4gICAgaWYgKCFkYXRlU3RyIHx8IHR5cGVvZiBkYXRlU3RyICE9PSAnc3RyaW5nJykge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGRhdGUgc3RyaW5nOicsIGRhdGVTdHIpXHJcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpIC8vIFJldHVybiBjdXJyZW50IGRhdGUgYXMgZmFsbGJhY2tcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ2hlY2sgaWYgaXQncyBhbHJlYWR5IGFuIElTTyBkYXRlIChjb250YWlucyBUIG9yIGhhcyA0LWRpZ2l0IHllYXIgYXQgc3RhcnQpXHJcbiAgICBpZiAoZGF0ZVN0ci5pbmNsdWRlcygnVCcpIHx8IC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0vLnRlc3QoZGF0ZVN0cikpIHtcclxuICAgICAgLy8gSXQncyBhbHJlYWR5IGFuIElTTyBkYXRlLCB1c2UgaXQgZGlyZWN0bHlcclxuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGRhdGVTdHIpXHJcbiAgICAgIGlmIChpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIElTTyBkYXRlOicsIGRhdGVTdHIpXHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkgLy8gUmV0dXJuIGN1cnJlbnQgZGF0ZSBhcyBmYWxsYmFja1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBkYXRlXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIE90aGVyd2lzZSwgcGFyc2UgYXMgREQtTU0tWVlZWSBmb3JtYXRcclxuICAgIGNvbnN0IHBhcnRzID0gZGF0ZVN0ci5zcGxpdCgnLScpXHJcbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSAzKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgZGF0ZSBmb3JtYXQ6JywgZGF0ZVN0cilcclxuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkgLy8gUmV0dXJuIGN1cnJlbnQgZGF0ZSBhcyBmYWxsYmFja1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBkYXkgPSBwYXJzZUludChwYXJ0c1swXSwgMTApXHJcbiAgICBjb25zdCBtb250aCA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCkgLSAxIC8vIEphdmFTY3JpcHQgbW9udGhzIGFyZSAwLWJhc2VkXHJcbiAgICBjb25zdCB5ZWFyID0gcGFyc2VJbnQocGFydHNbMl0sIDEwKVxyXG4gICAgXHJcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSlcclxuICAgIGlmIChpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBwYXJzZWQgZGF0ZTonLCBkYXRlU3RyKVxyXG4gICAgICByZXR1cm4gbmV3IERhdGUoKSAvLyBSZXR1cm4gY3VycmVudCBkYXRlIGFzIGZhbGxiYWNrXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBkYXRlXHJcbiAgfVxyXG5cclxuICAvLyBQYXJzZSB0aW1lIHN0cmluZyAoSEg6TU06U1Mgb3IgSEg6TU0gZm9ybWF0KVxyXG4gIGNvbnN0IHBhcnNlVGltZSA9ICh0aW1lU3RyOiBzdHJpbmcpOiBudW1iZXIgPT4ge1xyXG4gICAgaWYgKCF0aW1lU3RyIHx8IHR5cGVvZiB0aW1lU3RyICE9PSAnc3RyaW5nJykge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIHRpbWUgc3RyaW5nOicsIHRpbWVTdHIpXHJcbiAgICAgIHJldHVybiAwXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IHRpbWVQYXJ0cyA9IHRpbWVTdHIuc3BsaXQoJzonKVxyXG4gICAgaWYgKHRpbWVQYXJ0cy5sZW5ndGggPCAyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgdGltZSBmb3JtYXQ6JywgdGltZVN0cilcclxuICAgICAgcmV0dXJuIDBcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgaG91cnMgPSBwYXJzZUludCh0aW1lUGFydHNbMF0sIDEwKVxyXG4gICAgY29uc3QgbWludXRlcyA9IHBhcnNlSW50KHRpbWVQYXJ0c1sxXSwgMTApXHJcbiAgICBcclxuICAgIGlmIChpc05hTihob3VycykgfHwgaXNOYU4obWludXRlcykpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCB0aW1lIHZhbHVlczonLCB0aW1lU3RyKVxyXG4gICAgICByZXR1cm4gMFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gaG91cnMgKyAobWludXRlcyAvIDYwKVxyXG4gIH1cclxuXHJcbiAgY29uc3Qgc3RhcnQgPSBwYXJzZURhdGUoc3RhcnREYXRlKVxyXG4gIGNvbnN0IGVuZCA9IHBhcnNlRGF0ZShlbmREYXRlKVxyXG4gIGNvbnN0IHN0YXJ0VGltZUhvdXJzID0gcGFyc2VUaW1lKHN0YXJ0VGltZSlcclxuICBjb25zdCBlbmRUaW1lSG91cnMgPSBwYXJzZVRpbWUoZW5kVGltZSlcclxuXHJcbiAgaWYgKGVuZCA8IHN0YXJ0KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvcjogZW5kIGRhdGUgaXMgYmVmb3JlIHN0YXJ0IGRhdGUnKVxyXG4gICAgcmV0dXJuIDBcclxuICB9XHJcblxyXG4gIC8vIENyZWF0ZSBmdWxsIGRhdGV0aW1lIG9iamVjdHNcclxuICBjb25zdCBzdGFydERhdGVUaW1lID0gbmV3IERhdGUoc3RhcnQpXHJcbiAgc3RhcnREYXRlVGltZS5zZXRIb3VycyhNYXRoLmZsb29yKHN0YXJ0VGltZUhvdXJzKSwgKHN0YXJ0VGltZUhvdXJzICUgMSkgKiA2MCwgMCwgMClcclxuXHJcbiAgY29uc3QgZW5kRGF0ZVRpbWUgPSBuZXcgRGF0ZShlbmQpXHJcbiAgZW5kRGF0ZVRpbWUuc2V0SG91cnMoTWF0aC5mbG9vcihlbmRUaW1lSG91cnMpLCAoZW5kVGltZUhvdXJzICUgMSkgKiA2MCwgMCwgMClcclxuXHJcbiAgLy8gQ2FsY3VsYXRlIGR1cmF0aW9uIGluIGhvdXJzXHJcbiAgY29uc3QgdGltZURpZmZNcyA9IGVuZERhdGVUaW1lLmdldFRpbWUoKSAtIHN0YXJ0RGF0ZVRpbWUuZ2V0VGltZSgpXHJcbiAgY29uc3QgdG90YWxIb3VycyA9IHRpbWVEaWZmTXMgLyAoMTAwMCAqIDYwICogNjApXHJcblxyXG4gIC8vIENvbnZlcnQgdG8gZGF5IGNyZWRpdHMgdXNpbmcgMTItaG91ciBpbmNyZW1lbnRzXHJcbiAgLy8gRm9ybXVsYTogY3JlZGl0cyA9IGNlaWwoaG91cnMgLyAxMikgKiAwLjVcclxuICBjb25zdCBkYXlDcmVkaXRzID0gTWF0aC5jZWlsKHRvdGFsSG91cnMgLyAxMikgKiAwLjVcclxuXHJcbiAgcmV0dXJuIGRheUNyZWRpdHNcclxufVxyXG5cclxuLy8gRnVuY3RpZSBvbSBhdXRvbWF0aXNjaCBjcmV3IG1lbWJlcnMgdGUgYWN0aXZlcmVuIG9wIGh1biBzdGFydGRhdHVtXHJcbmFzeW5jIGZ1bmN0aW9uIGF1dG9BY3RpdmF0ZUNyZXdNZW1iZXJzKGNyZXdEYXRhOiBhbnlbXSkge1xyXG4gIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKVxyXG4gIHRvZGF5LnNldEhvdXJzKDAsIDAsIDAsIDApIC8vIFJlc2V0IG5hYXIgc3RhcnQgdmFuIGRlIGRhZ1xyXG4gIFxyXG4gIGZvciAoY29uc3QgbWVtYmVyIG9mIGNyZXdEYXRhKSB7XHJcbiAgICAvLyBDaGVjayBvZiBkZXplIHBlcnNvb24gbW9ldCB3b3JkZW4gZ2VhY3RpdmVlcmRcclxuICAgIC8vIFN0YXR1cyBrYW4gXCJ0aHVpc1wiIHppam4gKHdhY2h0ZW5kIG9wIHN0YXJ0ZGF0dW0pIG9mIFwibm9nLWluLXRlLWRlbGVuXCJcclxuICAgIGlmIChcclxuICAgICAgKG1lbWJlci5zdGF0dXMgPT09ICd0aHVpcycgfHwgbWVtYmVyLnN0YXR1cyA9PT0gJ25vZy1pbi10ZS1kZWxlbicpICYmXHJcbiAgICAgIG1lbWJlci5leHBlY3RlZF9zdGFydF9kYXRlICYmXHJcbiAgICAgIG1lbWJlci5zaGlwX2lkICYmXHJcbiAgICAgIG1lbWJlci5yZWdpbWVcclxuICAgICkge1xyXG4gICAgICBjb25zdCBzdGFydERhdGUgPSBuZXcgRGF0ZShtZW1iZXIuZXhwZWN0ZWRfc3RhcnRfZGF0ZSlcclxuICAgICAgc3RhcnREYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApXHJcbiAgICAgIFxyXG4gICAgICAvLyBJcyB2YW5kYWFnID49IHN0YXJ0ZGF0dW0/XHJcbiAgICAgIGlmICh0b2RheSA+PSBzdGFydERhdGUpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+agCBBdXRvLWFjdGl2YXRpbmcgJHttZW1iZXIuZmlyc3RfbmFtZX0gJHttZW1iZXIubGFzdF9uYW1lfSAtIFN0YXJ0IGRhdGUgcmVhY2hlZCFgKVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAvLyBVcGRhdGUgbmFhciBcImFhbi1ib29yZFwiIHN0YXR1c1xyXG4gICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgICAgLmZyb20oJ2NyZXcnKVxyXG4gICAgICAgICAgICAudXBkYXRlKHtcclxuICAgICAgICAgICAgICBzdGF0dXM6ICdhYW4tYm9vcmQnLFxyXG4gICAgICAgICAgICAgIG9uX2JvYXJkX3NpbmNlOiBtZW1iZXIuZXhwZWN0ZWRfc3RhcnRfZGF0ZSxcclxuICAgICAgICAgICAgICB0aHVpc19zaW5kczogbnVsbCwgLy8gQ2xlYXIgdGh1aXNfc2luZHMgKHdhcyB0aHVpcywgbnUgYWFuIGJvb3JkKVxyXG4gICAgICAgICAgICAgIGV4cGVjdGVkX3N0YXJ0X2RhdGU6IG51bGwsIC8vIENsZWFyIGV4cGVjdGVkX3N0YXJ0X2RhdGVcclxuICAgICAgICAgICAgICBzdWJfc3RhdHVzOiBudWxsIC8vIENsZWFyIHN1Yl9zdGF0dXNcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmVxKCdpZCcsIG1lbWJlci5pZClcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGF1dG8tYWN0aXZhdGluZyBjcmV3IG1lbWJlcjonLCBlcnJvcilcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgJHttZW1iZXIuZmlyc3RfbmFtZX0gJHttZW1iZXIubGFzdF9uYW1lfSBpcyBub3cgYWN0aXZlIWApXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBhdXRvLWFjdGl2YXRpb246JywgZXJyKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gRnVuY3RpZSBvbSBhdXRvbWF0aXNjaCByb3RhdGllcyB1aXQgdGUgdm9lcmVuXHJcbmFzeW5jIGZ1bmN0aW9uIGF1dG9Sb3RhdGVDcmV3TWVtYmVycyhjcmV3RGF0YTogYW55W10pIHtcclxuICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKClcclxuICB0b2RheS5zZXRIb3VycygwLCAwLCAwLCAwKVxyXG4gIFxyXG4gIGZvciAoY29uc3QgbWVtYmVyIG9mIGNyZXdEYXRhKSB7XHJcbiAgICAvLyBTa2lwIGFscyBnZWVuIHJlZ2ltZSwgemllaywgb2YgXCJBbHRpamRcIlxyXG4gICAgaWYgKCFtZW1iZXIucmVnaW1lIHx8IG1lbWJlci5zdGF0dXMgPT09ICd6aWVrJyB8fCBtZW1iZXIucmVnaW1lID09PSAnQWx0aWpkJykge1xyXG4gICAgICBjb250aW51ZVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCByZWdpbWVXZWVrcyA9IHBhcnNlSW50KG1lbWJlci5yZWdpbWUuc3BsaXQoJy8nKVswXSlcclxuICAgIGNvbnN0IHJlZ2ltZURheXMgPSByZWdpbWVXZWVrcyAqIDdcclxuICAgIFxyXG4gICAgLy8gQ2hlY2sgb2YgaWVtYW5kIHZhbiBhYW4tYm9vcmQgbmFhciB0aHVpcyBtb2V0XHJcbiAgICBpZiAobWVtYmVyLnN0YXR1cyA9PT0gJ2Fhbi1ib29yZCcgJiYgbWVtYmVyLm9uX2JvYXJkX3NpbmNlKSB7XHJcbiAgICAgIGNvbnN0IG9uQm9hcmREYXRlID0gbmV3IERhdGUobWVtYmVyLm9uX2JvYXJkX3NpbmNlKVxyXG4gICAgICBvbkJvYXJkRGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKVxyXG4gICAgICBcclxuICAgICAgY29uc3QgZGF5c1NpbmNlT25Cb2FyZCA9IE1hdGguZmxvb3IoKHRvZGF5LmdldFRpbWUoKSAtIG9uQm9hcmREYXRlLmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpXHJcbiAgICAgIFxyXG4gICAgICBpZiAoZGF5c1NpbmNlT25Cb2FyZCA+PSByZWdpbWVEYXlzKSB7XHJcbiAgICAgICAgY29uc3QgdGh1aXNTaW5kcyA9IG5ldyBEYXRlKG9uQm9hcmREYXRlKVxyXG4gICAgICAgIHRodWlzU2luZHMuc2V0RGF0ZSh0aHVpc1NpbmRzLmdldERhdGUoKSArIHJlZ2ltZURheXMpXHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc29sZS5sb2coYPCflIQgQXV0by1yb3RhdGluZyAke21lbWJlci5maXJzdF9uYW1lfSAke21lbWJlci5sYXN0X25hbWV9IHRvIFRIVUlTYClcclxuICAgICAgICBcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgICAgLmZyb20oJ2NyZXcnKVxyXG4gICAgICAgICAgICAudXBkYXRlKHtcclxuICAgICAgICAgICAgICBzdGF0dXM6ICd0aHVpcycsXHJcbiAgICAgICAgICAgICAgdGh1aXNfc2luZHM6IHRodWlzU2luZHMudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxyXG4gICAgICAgICAgICAgIG9uX2JvYXJkX3NpbmNlOiBudWxsXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5lcSgnaWQnLCBtZW1iZXIuaWQpXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByb3RhdGluZyB0byB0aHVpczonLCBlcnJvcilcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgJHttZW1iZXIuZmlyc3RfbmFtZX0gaXMgbm93IHRodWlzYClcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHJvdGF0aW9uOicsIGVycilcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ2hlY2sgb2YgaWVtYW5kIHZhbiB0aHVpcyBuYWFyIGFhbi1ib29yZCBtb2V0XHJcbiAgICBpZiAobWVtYmVyLnN0YXR1cyA9PT0gJ3RodWlzJyAmJiBtZW1iZXIudGh1aXNfc2luZHMpIHtcclxuICAgICAgY29uc3QgdGh1aXNEYXRlID0gbmV3IERhdGUobWVtYmVyLnRodWlzX3NpbmRzKVxyXG4gICAgICB0aHVpc0RhdGUuc2V0SG91cnMoMCwgMCwgMCwgMClcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGRheXNTaW5jZVRodWlzID0gTWF0aC5mbG9vcigodG9kYXkuZ2V0VGltZSgpIC0gdGh1aXNEYXRlLmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpXHJcbiAgICAgIFxyXG4gICAgICBpZiAoZGF5c1NpbmNlVGh1aXMgPj0gcmVnaW1lRGF5cykge1xyXG4gICAgICAgIGNvbnN0IG9uQm9hcmRTaW5jZSA9IG5ldyBEYXRlKHRodWlzRGF0ZSlcclxuICAgICAgICBvbkJvYXJkU2luY2Uuc2V0RGF0ZShvbkJvYXJkU2luY2UuZ2V0RGF0ZSgpICsgcmVnaW1lRGF5cylcclxuICAgICAgICBcclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+UhCBBdXRvLXJvdGF0aW5nICR7bWVtYmVyLmZpcnN0X25hbWV9ICR7bWVtYmVyLmxhc3RfbmFtZX0gdG8gQUFOLUJPT1JEYClcclxuICAgICAgICBcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgICAgLmZyb20oJ2NyZXcnKVxyXG4gICAgICAgICAgICAudXBkYXRlKHtcclxuICAgICAgICAgICAgICBzdGF0dXM6ICdhYW4tYm9vcmQnLFxyXG4gICAgICAgICAgICAgIG9uX2JvYXJkX3NpbmNlOiBvbkJvYXJkU2luY2UudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxyXG4gICAgICAgICAgICAgIHRodWlzX3NpbmRzOiBudWxsXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5lcSgnaWQnLCBtZW1iZXIuaWQpXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByb3RhdGluZyB0byBhYW4tYm9vcmQ6JywgZXJyb3IpXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFICR7bWVtYmVyLmZpcnN0X25hbWV9IGlzIG5vdyBhYW4tYm9vcmRgKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gcm90YXRpb246JywgZXJyKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gRnVuY3RpZSBvbSBhdXRvbWF0aXNjaCB2YXN0ZSBkaWVuc3QgcmVjb3JkcyB0ZSBiZWhlcmVuXHJcbmFzeW5jIGZ1bmN0aW9uIGF1dG9NYW5hZ2VWYXN0ZURpZW5zdFJlY29yZHMoY3Jld0RhdGE6IGFueVtdLCB2YXN0ZURpZW5zdFJlY29yZHM6IGFueVtdLCB0cmlwc0RhdGE6IGFueVtdKSB7XHJcbiAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpXHJcbiAgY29uc3QgY3VycmVudFllYXIgPSB0b2RheS5nZXRGdWxsWWVhcigpXHJcbiAgY29uc3QgY3VycmVudE1vbnRoID0gdG9kYXkuZ2V0TW9udGgoKSArIDEgLy8gSmF2YVNjcmlwdCBtb250aHMgYXJlIDAtYmFzZWRcclxuICBcclxuICBjb25zb2xlLmxvZyhg8J+UpyBBdXRvLW1hbmFnaW5nIHZhc3RlIGRpZW5zdCByZWNvcmRzIGZvciAke2N1cnJlbnRZZWFyfS0ke2N1cnJlbnRNb250aH1gKVxyXG4gIFxyXG4gIC8vIEdldCBhbGwgYWZsb3NzZXJzIGluIHZhc3RlIGRpZW5zdFxyXG4gIGNvbnN0IHZhc3RlRGllbnN0QWZsb3NzZXJzID0gY3Jld0RhdGEuZmlsdGVyKG1lbWJlciA9PiBtZW1iZXIudmFzdGVfZGllbnN0ID09PSB0cnVlKVxyXG4gIFxyXG4gIGZvciAoY29uc3QgYWZsb3NzZXIgb2YgdmFzdGVEaWVuc3RBZmxvc3NlcnMpIHtcclxuICAgIGNvbnNvbGUubG9nKGDwn5OLIFByb2Nlc3NpbmcgdmFzdGUgZGllbnN0IGFmbG9zc2VyOiAke2FmbG9zc2VyLmZpcnN0X25hbWV9ICR7YWZsb3NzZXIubGFzdF9uYW1lfWApXHJcbiAgICBcclxuICAgIC8vIENoZWNrIGlmIGN1cnJlbnQgbW9udGggcmVjb3JkIGV4aXN0c1xyXG4gICAgY29uc3QgZXhpc3RpbmdSZWNvcmQgPSB2YXN0ZURpZW5zdFJlY29yZHMuZmluZChyZWNvcmQgPT4gXHJcbiAgICAgIHJlY29yZC5hZmxvc3Nlcl9pZCA9PT0gYWZsb3NzZXIuaWQgJiYgXHJcbiAgICAgIHJlY29yZC55ZWFyID09PSBjdXJyZW50WWVhciAmJiBcclxuICAgICAgcmVjb3JkLm1vbnRoID09PSBjdXJyZW50TW9udGhcclxuICAgIClcclxuICAgIFxyXG4gICAgaWYgKCFleGlzdGluZ1JlY29yZCkge1xyXG4gICAgICAvLyBDcmVhdGUgbmV3IG1vbnRobHkgcmVjb3JkXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OFIENyZWF0aW5nIG5ldyBtb250aGx5IHJlY29yZCBmb3IgJHthZmxvc3Nlci5maXJzdF9uYW1lfSAke2FmbG9zc2VyLmxhc3RfbmFtZX1gKVxyXG4gICAgICBcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBuZXdSZWNvcmQgPSB7XHJcbiAgICAgICAgICBhZmxvc3Nlcl9pZDogYWZsb3NzZXIuaWQsXHJcbiAgICAgICAgICB5ZWFyOiBjdXJyZW50WWVhcixcclxuICAgICAgICAgIG1vbnRoOiBjdXJyZW50TW9udGgsXHJcbiAgICAgICAgICByZXF1aXJlZF9kYXlzOiAxNSwgLy8gU3RhbmRhcmQgMTUgZGF5cyBwZXIgbW9udGhcclxuICAgICAgICAgIGFjdHVhbF9kYXlzOiAwLCAvLyBXaWxsIGJlIGNhbGN1bGF0ZWQgZnJvbSB0cmlwc1xyXG4gICAgICAgICAgYmFsYW5jZV9kYXlzOiAwLCAvLyBXaWxsIGJlIGNhbGN1bGF0ZWRcclxuICAgICAgICAgIG5vdGVzOiBgQXV0b21hdGlzY2ggYWFuZ2VtYWFrdCB2b29yICR7Y3VycmVudFllYXJ9LSR7Y3VycmVudE1vbnRofWBcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgIC5mcm9tKCd2YXN0ZV9kaWVuc3RfcmVjb3JkcycpXHJcbiAgICAgICAgICAuaW5zZXJ0KFtuZXdSZWNvcmRdKVxyXG4gICAgICAgICAgLnNlbGVjdCgpXHJcbiAgICAgICAgICAuc2luZ2xlKClcclxuICAgICAgICBcclxuICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHZhc3RlIGRpZW5zdCByZWNvcmQ6JywgZXJyb3IpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgQ3JlYXRlZCBtb250aGx5IHJlY29yZCBmb3IgJHthZmxvc3Nlci5maXJzdF9uYW1lfWApXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiB2YXN0ZSBkaWVuc3QgcmVjb3JkIGNyZWF0aW9uOicsIGVycilcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgYWN0dWFsIGRheXMgZnJvbSBjb21wbGV0ZWQgdHJpcHMgZm9yIGN1cnJlbnQgbW9udGhcclxuICAgIGNvbnN0IGN1cnJlbnRNb250aFRyaXBzID0gdHJpcHNEYXRhLmZpbHRlcih0cmlwID0+IFxyXG4gICAgICB0cmlwLmFmbG9zc2VyX2lkID09PSBhZmxvc3Nlci5pZCAmJiBcclxuICAgICAgdHJpcC5zdGF0dXMgPT09ICd2b2x0b29pZCcgJiZcclxuICAgICAgdHJpcC5laW5kX2RhdHVtICYmXHJcbiAgICAgIG5ldyBEYXRlKHRyaXAuZWluZF9kYXR1bSkuZ2V0RnVsbFllYXIoKSA9PT0gY3VycmVudFllYXIgJiZcclxuICAgICAgbmV3IERhdGUodHJpcC5laW5kX2RhdHVtKS5nZXRNb250aCgpICsgMSA9PT0gY3VycmVudE1vbnRoXHJcbiAgICApXHJcbiAgICBcclxuICAgIGxldCB0b3RhbFdvcmtEYXlzID0gMFxyXG4gICAgZm9yIChjb25zdCB0cmlwIG9mIGN1cnJlbnRNb250aFRyaXBzKSB7XHJcbiAgICAgIGNvbnN0IHdvcmtEYXlzID0gY2FsY3VsYXRlV29ya0RheXModHJpcC5zdGFydF9kYXR1bSwgdHJpcC5zdGFydF90aWpkLCB0cmlwLmVpbmRfZGF0dW0sIHRyaXAuZWluZF90aWpkKVxyXG4gICAgICB0b3RhbFdvcmtEYXlzICs9IHdvcmtEYXlzXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFVwZGF0ZSB0aGUgcmVjb3JkIHdpdGggYWN0dWFsIGRheXMgYW5kIGJhbGFuY2VcclxuICAgIGlmIChleGlzdGluZ1JlY29yZCkge1xyXG4gICAgICBjb25zdCByZXF1aXJlZERheXMgPSAxNVxyXG4gICAgICBcclxuICAgICAgLy8gQ09SUkVDVEUgQkVSRUtFTklORzogRWluZHNhbGRvID0gQmVnaW5zYWxkbyArIChHZXdlcmt0IC0gMTUpXHJcbiAgICAgIC8vIFZvb3IgZWVyc3RlIG1hYW5kOiBCZWdpbnNhbGRvID0gLTE1ICsgc3RhcnRzYWxkb1xyXG4gICAgICBsZXQgYmVnaW5zYWxkbyA9IGV4aXN0aW5nUmVjb3JkLmJhbGFuY2VfZGF5cyB8fCAwXHJcbiAgICAgIFxyXG4gICAgICAvLyBBbHMgZGl0IGRlIGVlcnN0ZSBtYWFuZCBpcyBlbiBlciBpcyBnZWVuIGJlZ2luc2FsZG8sIGdlYnJ1aWsgLTE1ICsgc3RhcnRzYWxkb1xyXG4gICAgICBpZiAoYmVnaW5zYWxkbyA9PT0gMCAmJiBjdXJyZW50TW9udGggPT09IDEpIHtcclxuICAgICAgICAvLyBQcm9iZWVyIHN0YXJ0c2FsZG8gdWl0IG5vdGVzIHRlIGhhbGVuXHJcbiAgICAgICAgY29uc3Qgc3RhcnRzYWxkb05vdGUgPSBhZmxvc3Nlci5ub3Rlcz8uZmluZCgobm90ZTogYW55KSA9PiBcclxuICAgICAgICAgIG5vdGUudGV4dCAmJiAobm90ZS50ZXh0LmluY2x1ZGVzKCdzdGFydHNhbGRvJykgfHwgbm90ZS50ZXh0LmluY2x1ZGVzKCdTdGFydHNhbGRvJykpXHJcbiAgICAgICAgKVxyXG4gICAgICAgIGlmIChzdGFydHNhbGRvTm90ZSkge1xyXG4gICAgICAgICAgY29uc3QgbWF0Y2ggPSBzdGFydHNhbGRvTm90ZS50ZXh0Lm1hdGNoKC8oLT9cXGQrKD86XFwuXFxkKyk/KS8pXHJcbiAgICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnRzYWxkbyA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pXHJcbiAgICAgICAgICAgIGJlZ2luc2FsZG8gPSAtMTUgKyBzdGFydHNhbGRvXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OKIEVlcnN0ZSBtYWFuZDogc3RhcnRzYWxkbyAke3N0YXJ0c2FsZG99LCBiZWdpbnNhbGRvICR7YmVnaW5zYWxkb31gKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmVnaW5zYWxkbyA9PT0gMCkgYmVnaW5zYWxkbyA9IC0xNSAvLyBGYWxsYmFja1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBWb29yIGRlIGVlcnN0ZSBtYWFuZDogdG9vbiBoZXQgYmVnaW5zYWxkbyBhbHMgaHVpZGlnIHNhbGRvXHJcbiAgICAgIC8vIFZvb3Igdm9sZ2VuZGUgbWFhbmRlbjogYmVyZWtlbiBoZXQgZWluZHNhbGRvXHJcbiAgICAgIGxldCBiYWxhbmNlRGF5c1xyXG4gICAgICBpZiAoY3VycmVudE1vbnRoID09PSAxICYmIGJlZ2luc2FsZG8gIT09IC0xNSkge1xyXG4gICAgICAgIC8vIEVlcnN0ZSBtYWFuZCBtZXQgc3RhcnRzYWxkbzogdG9vbiBiZWdpbnNhbGRvXHJcbiAgICAgICAgYmFsYW5jZURheXMgPSBiZWdpbnNhbGRvXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gTm9ybWFsZSBiZXJla2VuaW5nOiBiZWdpbnNhbGRvICsgKGdld2Vya3QgLSAxNSlcclxuICAgICAgICBiYWxhbmNlRGF5cyA9IGJlZ2luc2FsZG8gKyAodG90YWxXb3JrRGF5cyAtIHJlcXVpcmVkRGF5cylcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gQ2FwIHZhbHVlcyB0byBmaXQgaW4gREVDSU1BTCg0LDEpIC0gbWF4IDk5OS45XHJcbiAgICAgIGNvbnN0IGNhcHBlZEFjdHVhbERheXMgPSBNYXRoLm1pbih0b3RhbFdvcmtEYXlzLCA5OTkuOSlcclxuICAgICAgY29uc3QgY2FwcGVkQmFsYW5jZURheXMgPSBNYXRoLm1pbihNYXRoLm1heChiYWxhbmNlRGF5cywgLTk5OS45KSwgOTk5LjkpXHJcbiAgICAgIFxyXG4gICAgICBpZiAoZXhpc3RpbmdSZWNvcmQuYWN0dWFsX2RheXMgIT09IGNhcHBlZEFjdHVhbERheXMgfHwgZXhpc3RpbmdSZWNvcmQuYmFsYW5jZV9kYXlzICE9PSBjYXBwZWRCYWxhbmNlRGF5cykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5OKIFVwZGF0aW5nIHJlY29yZCBmb3IgJHthZmxvc3Nlci5maXJzdF9uYW1lfTogJHtjYXBwZWRBY3R1YWxEYXlzfSBkYXlzIChiYWxhbmNlOiAke2NhcHBlZEJhbGFuY2VEYXlzfSlgKVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgIC5mcm9tKCd2YXN0ZV9kaWVuc3RfcmVjb3JkcycpXHJcbiAgICAgICAgICAudXBkYXRlKHtcclxuICAgICAgICAgICAgYWN0dWFsX2RheXM6IGNhcHBlZEFjdHVhbERheXMsXHJcbiAgICAgICAgICAgIGJhbGFuY2VfZGF5czogY2FwcGVkQmFsYW5jZURheXNcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICAuZXEoJ2lkJywgZXhpc3RpbmdSZWNvcmQuaWQpXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgdXBkYXRpbmcgdmFzdGUgZGllbnN0IHJlY29yZDonLCBlcnJvcilcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGRldGFpbHM6JywgSlNPTi5zdHJpbmdpZnkoZXJyb3IsIG51bGwsIDIpKVxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgUmVjb3JkIGRhdGE6JywgeyBpZDogZXhpc3RpbmdSZWNvcmQuaWQsIGFjdHVhbF9kYXlzOiB0b3RhbFdvcmtEYXlzLCBiYWxhbmNlX2RheXM6IGJhbGFuY2VEYXlzIH0pXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFVwZGF0ZWQgcmVjb3JkIGZvciAke2FmbG9zc2VyLmZpcnN0X25hbWV9YClcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHZhc3RlIGRpZW5zdCByZWNvcmQ6JywgZXJyKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSB3b3JrIGRheXMgZnJvbSB0cmlwIGRhdGFcclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVdvcmtEYXlzKHN0YXJ0RGF0ZTogc3RyaW5nLCBzdGFydFRpbWU6IHN0cmluZywgZW5kRGF0ZTogc3RyaW5nLCBlbmRUaW1lOiBzdHJpbmcpOiBudW1iZXIge1xyXG4gIGlmICghc3RhcnREYXRlIHx8ICFlbmREYXRlKSByZXR1cm4gMFxyXG5cclxuICAvLyBQYXJzZSBib3RoIERELU1NLVlZWVkgYW5kIElTTyBmb3JtYXQgZGF0ZXNcclxuICBjb25zdCBwYXJzZURhdGUgPSAoZGF0ZVN0cjogc3RyaW5nKTogRGF0ZSA9PiB7XHJcbiAgICBpZiAoIWRhdGVTdHIgfHwgdHlwZW9mIGRhdGVTdHIgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgZGF0ZSBzdHJpbmc6JywgZGF0ZVN0cilcclxuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkgLy8gUmV0dXJuIGN1cnJlbnQgZGF0ZSBhcyBmYWxsYmFja1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDaGVjayBpZiBpdCdzIGFscmVhZHkgYW4gSVNPIGRhdGUgKGNvbnRhaW5zIFQgb3IgaGFzIDQtZGlnaXQgeWVhciBhdCBzdGFydClcclxuICAgIGlmIChkYXRlU3RyLmluY2x1ZGVzKCdUJykgfHwgL15cXGR7NH0tXFxkezJ9LVxcZHsyfS8udGVzdChkYXRlU3RyKSkge1xyXG4gICAgICAvLyBJdCdzIGFscmVhZHkgYW4gSVNPIGRhdGUsIHVzZSBpdCBkaXJlY3RseVxyXG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoZGF0ZVN0cilcclxuICAgICAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgSVNPIGRhdGU6JywgZGF0ZVN0cilcclxuICAgICAgICByZXR1cm4gbmV3IERhdGUoKSAvLyBSZXR1cm4gY3VycmVudCBkYXRlIGFzIGZhbGxiYWNrXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGRhdGVcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gT3RoZXJ3aXNlLCBwYXJzZSBhcyBERC1NTS1ZWVlZIGZvcm1hdFxyXG4gICAgY29uc3QgcGFydHMgPSBkYXRlU3RyLnNwbGl0KCctJylcclxuICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDMpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBkYXRlIGZvcm1hdDonLCBkYXRlU3RyKVxyXG4gICAgICByZXR1cm4gbmV3IERhdGUoKSAvLyBSZXR1cm4gY3VycmVudCBkYXRlIGFzIGZhbGxiYWNrXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IFtkYXksIG1vbnRoLCB5ZWFyXSA9IHBhcnRzXHJcbiAgICBjb25zdCBpc29EYXRlID0gYCR7eWVhcn0tJHttb250aC5wYWRTdGFydCgyLCAnMCcpfS0ke2RheS5wYWRTdGFydCgyLCAnMCcpfWBcclxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShpc29EYXRlKVxyXG4gICAgXHJcbiAgICBpZiAoaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgZGF0ZSBhZnRlciBwYXJzaW5nOicsIGlzb0RhdGUsICdmcm9tOicsIGRhdGVTdHIpXHJcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpIC8vIFJldHVybiBjdXJyZW50IGRhdGUgYXMgZmFsbGJhY2tcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIGRhdGVcclxuICB9XHJcblxyXG4gIGNvbnN0IHN0YXJ0ID0gcGFyc2VEYXRlKHN0YXJ0RGF0ZSlcclxuICBjb25zdCBlbmQgPSBwYXJzZURhdGUoZW5kRGF0ZSlcclxuXHJcbiAgLy8gVmFsaWRhdGllOiBhZnN0YXBkYXR1bSBtYWcgbmlldCB2b29yIGluc3RhcGRhdHVtIGxpZ2dlblxyXG4gIGlmIChlbmQgPCBzdGFydCkge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3I6IGVuZCBkYXRlIGlzIGJlZm9yZSBzdGFydCBkYXRlJylcclxuICAgIHJldHVybiAwXHJcbiAgfVxyXG5cclxuICAvLyBTaW1wZWxlIHRlbGxpbmc6IHRlbCBrYWxlbmRlcmRhZ2VuIHZhbiBzdGFydCB0b3QgZWluZCAoaW5jbHVzaWVmIGJlaWRlKVxyXG4gIGNvbnN0IHRpbWVEaWZmID0gZW5kLmdldFRpbWUoKSAtIHN0YXJ0LmdldFRpbWUoKVxyXG4gIGNvbnN0IGRheXNEaWZmID0gTWF0aC5jZWlsKHRpbWVEaWZmIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKSArIDEgLy8gKzEgb21kYXQgd2UgYmVpZGUgZGF0dW1zIGluY2x1c2llZiB0ZWxsZW5cclxuXHJcblxyXG4gIHJldHVybiBkYXlzRGlmZlxyXG59XHJcblxyXG4vLyBGdW5jdGlvbiB0byBhdXRvLXVwZGF0ZSB2YXN0ZSBkaWVuc3QgcmVjb3JkcyB3aGVuIGEgdHJpcCBpcyBjb21wbGV0ZWRcclxuYXN5bmMgZnVuY3Rpb24gYXV0b1VwZGF0ZVZhc3RlRGllbnN0RnJvbVRyaXAoY29tcGxldGVkVHJpcDogYW55KSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKGDwn5SEIEF1dG8tdXBkYXRpbmcgdmFzdGUgZGllbnN0IGZvciBjb21wbGV0ZWQgdHJpcDogJHtjb21wbGV0ZWRUcmlwLmlkfWApXHJcbiAgICBjb25zb2xlLmxvZyhg8J+UhCBUcmlwIGRhdGE6YCwgY29tcGxldGVkVHJpcClcclxuICAgIFxyXG4gICAgLy8gR2V0IHRoZSBhZmxvc3NlclxyXG4gICAgY29uc3QgeyBkYXRhOiBhZmxvc3NlciwgZXJyb3I6IGFmbG9zc2VyRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdjcmV3JylcclxuICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgIC5lcSgnaWQnLCBjb21wbGV0ZWRUcmlwLmFmbG9zc2VyX2lkKVxyXG4gICAgICAuc2luZ2xlKClcclxuICAgIFxyXG4gICAgaWYgKGFmbG9zc2VyRXJyb3IgfHwgIWFmbG9zc2VyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGFmbG9zc2VyOicsIGFmbG9zc2VyRXJyb3IpXHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDaGVjayBpZiBhZmxvc3NlciBpcyBpbiB2YXN0ZSBkaWVuc3RcclxuICAgIGlmICghYWZsb3NzZXIudmFzdGVfZGllbnN0KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdBZmxvc3NlciBpcyBub3QgaW4gdmFzdGUgZGllbnN0LCBza2lwcGluZyBhdXRvLXVwZGF0ZScpXHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBHZXQgdGhlIG1vbnRoL3llYXIgb2YgdGhlIHRyaXAgY29tcGxldGlvblxyXG4gICAgLy8gUGFyc2UgdGhlIGRhdGUgdXNpbmcgb3VyIHNhZmUgcGFyc2VEYXRlIGZ1bmN0aW9uXHJcbiAgICBjb25zdCBwYXJzZURhdGUgPSAoZGF0ZVN0cjogc3RyaW5nKTogRGF0ZSA9PiB7XHJcbiAgICAgIGlmICghZGF0ZVN0ciB8fCB0eXBlb2YgZGF0ZVN0ciAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGRhdGUgc3RyaW5nOicsIGRhdGVTdHIpXHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKClcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhbHJlYWR5IGFuIElTTyBkYXRlIChjb250YWlucyBUIG9yIGhhcyA0LWRpZ2l0IHllYXIgYXQgc3RhcnQpXHJcbiAgICAgIGlmIChkYXRlU3RyLmluY2x1ZGVzKCdUJykgfHwgL15cXGR7NH0tXFxkezJ9LVxcZHsyfS8udGVzdChkYXRlU3RyKSkge1xyXG4gICAgICAgIC8vIEl0J3MgYWxyZWFkeSBhbiBJU08gZGF0ZSwgdXNlIGl0IGRpcmVjdGx5XHJcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGRhdGVTdHIpXHJcbiAgICAgICAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBJU08gZGF0ZTonLCBkYXRlU3RyKVxyXG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKClcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGVcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gT3RoZXJ3aXNlLCBwYXJzZSBhcyBERC1NTS1ZWVlZIGZvcm1hdFxyXG4gICAgICBjb25zdCBwYXJ0cyA9IGRhdGVTdHIuc3BsaXQoJy0nKVxyXG4gICAgICBpZiAocGFydHMubGVuZ3RoICE9PSAzKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBkYXRlIGZvcm1hdDonLCBkYXRlU3RyKVxyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnN0IFtkYXksIG1vbnRoLCB5ZWFyXSA9IHBhcnRzXHJcbiAgICAgIGNvbnN0IGlzb0RhdGUgPSBgJHt5ZWFyfS0ke21vbnRoLnBhZFN0YXJ0KDIsICcwJyl9LSR7ZGF5LnBhZFN0YXJ0KDIsICcwJyl9YFxyXG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoaXNvRGF0ZSlcclxuICAgICAgXHJcbiAgICAgIGlmIChpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGRhdGUgYWZ0ZXIgcGFyc2luZzonLCBpc29EYXRlLCAnZnJvbTonLCBkYXRlU3RyKVxyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHJldHVybiBkYXRlXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IGVuZERhdGUgPSBwYXJzZURhdGUoY29tcGxldGVkVHJpcC5laW5kX2RhdHVtKVxyXG4gICAgY29uc3QgeWVhciA9IGVuZERhdGUuZ2V0RnVsbFllYXIoKVxyXG4gICAgY29uc3QgbW9udGggPSBlbmREYXRlLmdldE1vbnRoKCkgKyAxXHJcbiAgICBcclxuICAgIC8vIENoZWNrIGlmIG1vbnRobHkgcmVjb3JkIGV4aXN0c1xyXG4gICAgY29uc3QgeyBkYXRhOiBleGlzdGluZ1JlY29yZCwgZXJyb3I6IHJlY29yZEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgndmFzdGVfZGllbnN0X3JlY29yZHMnKVxyXG4gICAgICAuc2VsZWN0KCcqJylcclxuICAgICAgLmVxKCdhZmxvc3Nlcl9pZCcsIGNvbXBsZXRlZFRyaXAuYWZsb3NzZXJfaWQpXHJcbiAgICAgIC5lcSgneWVhcicsIHllYXIpXHJcbiAgICAgIC5lcSgnbW9udGgnLCBtb250aClcclxuICAgICAgLnNpbmdsZSgpXHJcbiAgICBcclxuICAgIGlmIChyZWNvcmRFcnJvciAmJiByZWNvcmRFcnJvci5jb2RlICE9PSAnUEdSU1QxMTYnKSB7IC8vIFBHUlNUMTE2ID0gbm8gcm93cyBmb3VuZFxyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB2YXN0ZSBkaWVuc3QgcmVjb3JkOicsIHJlY29yZEVycm9yKVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIFxyXG4gICAgbGV0IHJlY29yZElkID0gZXhpc3RpbmdSZWNvcmQ/LmlkXHJcbiAgICBcclxuICAgIC8vIENyZWF0ZSByZWNvcmQgaWYgaXQgZG9lc24ndCBleGlzdFxyXG4gICAgaWYgKCFleGlzdGluZ1JlY29yZCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+ThSBDcmVhdGluZyBuZXcgbW9udGhseSByZWNvcmQgZm9yICR7YWZsb3NzZXIuZmlyc3RfbmFtZX0gJHthZmxvc3Nlci5sYXN0X25hbWV9YClcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IG5ld1JlY29yZCA9IHtcclxuICAgICAgICBhZmxvc3Nlcl9pZDogY29tcGxldGVkVHJpcC5hZmxvc3Nlcl9pZCxcclxuICAgICAgICB5ZWFyOiB5ZWFyLFxyXG4gICAgICAgIG1vbnRoOiBtb250aCxcclxuICAgICAgICByZXF1aXJlZF9kYXlzOiAxNSxcclxuICAgICAgICBhY3R1YWxfZGF5czogMCxcclxuICAgICAgICBiYWxhbmNlX2RheXM6IDAsXHJcbiAgICAgICAgbm90ZXM6IGBBdXRvbWF0aXNjaCBhYW5nZW1hYWt0IHZvb3IgJHt5ZWFyfS0ke21vbnRofWBcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc3QgeyBkYXRhOiBjcmVhdGVkUmVjb3JkLCBlcnJvcjogY3JlYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ3Zhc3RlX2RpZW5zdF9yZWNvcmRzJylcclxuICAgICAgICAuaW5zZXJ0KFtuZXdSZWNvcmRdKVxyXG4gICAgICAgIC5zZWxlY3QoKVxyXG4gICAgICAgIC5zaW5nbGUoKVxyXG4gICAgICBcclxuICAgICAgaWYgKGNyZWF0ZUVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgdmFzdGUgZGllbnN0IHJlY29yZDonLCBjcmVhdGVFcnJvcilcclxuICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgcmVjb3JkSWQgPSBjcmVhdGVkUmVjb3JkLmlkXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSB3b3JrIGRheXMgZm9yIHRoaXMgdHJpcFxyXG4gICAgY29uc3Qgd29ya0RheXMgPSBjYWxjdWxhdGVXb3JrRGF5cyhcclxuICAgICAgY29tcGxldGVkVHJpcC5zdGFydF9kYXR1bSwgXHJcbiAgICAgIGNvbXBsZXRlZFRyaXAuc3RhcnRfdGlqZCwgXHJcbiAgICAgIGNvbXBsZXRlZFRyaXAuZWluZF9kYXR1bSwgXHJcbiAgICAgIGNvbXBsZXRlZFRyaXAuZWluZF90aWpkXHJcbiAgICApXHJcbiAgICBcclxuICAgIC8vIEdldCBhbGwgY29tcGxldGVkIHRyaXBzIGZvciB0aGlzIG1vbnRoIHRvIGNhbGN1bGF0ZSB0b3RhbFxyXG4gICAgY29uc3QgeyBkYXRhOiBhbGxUcmlwcywgZXJyb3I6IHRyaXBzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCd0cmlwcycpXHJcbiAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAuZXEoJ2FmbG9zc2VyX2lkJywgY29tcGxldGVkVHJpcC5hZmxvc3Nlcl9pZClcclxuICAgICAgLmVxKCdzdGF0dXMnLCAndm9sdG9vaWQnKVxyXG4gICAgICAubm90KCdlaW5kX2RhdHVtJywgJ2lzJywgbnVsbClcclxuICAgIFxyXG4gICAgaWYgKHRyaXBzRXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdHJpcHM6JywgdHJpcHNFcnJvcilcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSB0b3RhbCB3b3JrIGRheXMgZm9yIHRoZSBtb250aFxyXG4gICAgbGV0IHRvdGFsV29ya0RheXMgPSAwXHJcbiAgICBmb3IgKGNvbnN0IHRyaXAgb2YgYWxsVHJpcHMgfHwgW10pIHtcclxuICAgICAgY29uc3QgdHJpcEVuZERhdGUgPSBwYXJzZURhdGUodHJpcC5laW5kX2RhdHVtKVxyXG4gICAgICBpZiAodHJpcEVuZERhdGUuZ2V0RnVsbFllYXIoKSA9PT0geWVhciAmJiB0cmlwRW5kRGF0ZS5nZXRNb250aCgpICsgMSA9PT0gbW9udGgpIHtcclxuICAgICAgICBjb25zdCB0cmlwV29ya0RheXMgPSBjYWxjdWxhdGVXb3JrRGF5cyh0cmlwLnN0YXJ0X2RhdHVtLCB0cmlwLnN0YXJ0X3RpamQsIHRyaXAuZWluZF9kYXR1bSwgdHJpcC5laW5kX3RpamQpXHJcbiAgICAgICAgdG90YWxXb3JrRGF5cyArPSB0cmlwV29ya0RheXNcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBVcGRhdGUgdGhlIHJlY29yZFxyXG4gICAgY29uc3QgcmVxdWlyZWREYXlzID0gMTVcclxuICAgIFxyXG4gICAgLy8gQ09SUkVDVEUgQkVSRUtFTklORzogRWluZHNhbGRvID0gQmVnaW5zYWxkbyArIChHZXdlcmt0IC0gMTUpXHJcbiAgICAvLyBWb29yIGVlcnN0ZSBtYWFuZDogQmVnaW5zYWxkbyA9IC0xNSArIHN0YXJ0c2FsZG9cclxuICAgIGxldCBiZWdpbnNhbGRvID0gMFxyXG4gICAgXHJcbiAgICAvLyBQcm9iZWVyIHN0YXJ0c2FsZG8gdWl0IG5vdGVzIHRlIGhhbGVuIHZvb3IgbmlldXdlIGFmbG9zc2Vyc1xyXG4gICAgY29uc3Qgc3RhcnRzYWxkb05vdGUgPSBhZmxvc3Nlci5ub3Rlcz8uZmluZCgobm90ZTogYW55KSA9PiBcclxuICAgICAgbm90ZS50ZXh0ICYmIChub3RlLnRleHQuaW5jbHVkZXMoJ3N0YXJ0c2FsZG8nKSB8fCBub3RlLnRleHQuaW5jbHVkZXMoJ1N0YXJ0c2FsZG8nKSlcclxuICAgIClcclxuICAgIGlmIChzdGFydHNhbGRvTm90ZSkge1xyXG4gICAgICBjb25zdCBtYXRjaCA9IHN0YXJ0c2FsZG9Ob3RlLnRleHQubWF0Y2goLygtP1xcZCsoPzpcXC5cXGQrKT8pLylcclxuICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRzYWxkbyA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pXHJcbiAgICAgICAgYmVnaW5zYWxkbyA9IC0xNSArIHN0YXJ0c2FsZG9cclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiBOaWV1d2UgYWZsb3NzZXI6IHN0YXJ0c2FsZG8gJHtzdGFydHNhbGRvfSwgYmVnaW5zYWxkbyAke2JlZ2luc2FsZG99YClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGJlZ2luc2FsZG8gPT09IDApIGJlZ2luc2FsZG8gPSAtMTUgLy8gRmFsbGJhY2tcclxuICAgIFxyXG4gICAgLy8gVm9vciBkZSBlZXJzdGUgbWFhbmQ6IHRvb24gaGV0IGJlZ2luc2FsZG8gYWxzIGh1aWRpZyBzYWxkb1xyXG4gICAgLy8gVm9vciB2b2xnZW5kZSBtYWFuZGVuOiBiZXJla2VuIGhldCBlaW5kc2FsZG9cclxuICAgIGxldCBiYWxhbmNlRGF5c1xyXG4gICAgaWYgKG1vbnRoID09PSAxICYmIGJlZ2luc2FsZG8gIT09IC0xNSkge1xyXG4gICAgICAvLyBFZXJzdGUgbWFhbmQgbWV0IHN0YXJ0c2FsZG86IHRvb24gYmVnaW5zYWxkb1xyXG4gICAgICBiYWxhbmNlRGF5cyA9IGJlZ2luc2FsZG9cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIE5vcm1hbGUgYmVyZWtlbmluZzogYmVnaW5zYWxkbyArIChnZXdlcmt0IC0gMTUpXHJcbiAgICAgIGJhbGFuY2VEYXlzID0gYmVnaW5zYWxkbyArICh0b3RhbFdvcmtEYXlzIC0gcmVxdWlyZWREYXlzKVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDYXAgdmFsdWVzIHRvIGZpdCBpbiBERUNJTUFMKDQsMSkgLSBtYXggOTk5LjlcclxuICAgIGNvbnN0IGNhcHBlZEFjdHVhbERheXMgPSBNYXRoLm1pbih0b3RhbFdvcmtEYXlzLCA5OTkuOSlcclxuICAgIGNvbnN0IGNhcHBlZEJhbGFuY2VEYXlzID0gTWF0aC5taW4oTWF0aC5tYXgoYmFsYW5jZURheXMsIC05OTkuOSksIDk5OS45KVxyXG4gICAgXHJcbiAgICBjb25zdCB7IGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ3Zhc3RlX2RpZW5zdF9yZWNvcmRzJylcclxuICAgICAgLnVwZGF0ZSh7XHJcbiAgICAgICAgYWN0dWFsX2RheXM6IGNhcHBlZEFjdHVhbERheXMsXHJcbiAgICAgICAgYmFsYW5jZV9kYXlzOiBjYXBwZWRCYWxhbmNlRGF5c1xyXG4gICAgICB9KVxyXG4gICAgICAuZXEoJ2lkJywgcmVjb3JkSWQpXHJcbiAgICBcclxuICAgIGlmICh1cGRhdGVFcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgdXBkYXRpbmcgdmFzdGUgZGllbnN0IHJlY29yZDonLCB1cGRhdGVFcnJvcilcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGRldGFpbHM6JywgSlNPTi5zdHJpbmdpZnkodXBkYXRlRXJyb3IsIG51bGwsIDIpKVxyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgUmVjb3JkIGRhdGE6JywgeyBpZDogcmVjb3JkSWQsIGFjdHVhbF9kYXlzOiB0b3RhbFdvcmtEYXlzLCBiYWxhbmNlX2RheXM6IGJhbGFuY2VEYXlzIH0pXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFVwZGF0ZWQgdmFzdGUgZGllbnN0IHJlY29yZCBmb3IgJHthZmxvc3Nlci5maXJzdF9uYW1lfTogJHt0b3RhbFdvcmtEYXlzfSBkYXlzIChiYWxhbmNlOiAke2JhbGFuY2VEYXlzfSlgKVxyXG4gICAgfVxyXG4gICAgXHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBhdXRvLXVwZGF0ZSB2YXN0ZSBkaWVuc3Q6JywgZXJyKVxyXG4gIH1cclxufVxyXG5cclxuLy8gRnVuY3Rpb24gdG8gZm9yY2UgcmVjYWxjdWxhdGUgYWxsIHZhc3RlIGRpZW5zdCByZWNvcmRzIHdpdGggbmV3IGxvZ2ljXHJcbmFzeW5jIGZ1bmN0aW9uIGZvcmNlUmVjYWxjdWxhdGVBbGxWYXN0ZURpZW5zdFJlY29yZHMoY3Jld0RhdGE6IGFueVtdLCB0cmlwc0RhdGE6IGFueVtdKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKCfwn5SEIEZvcmNlIHJlY2FsY3VsYXRpbmcgYWxsIHZhc3RlIGRpZW5zdCByZWNvcmRzLi4uJylcclxuICAgIGNvbnNvbGUubG9nKGDwn5OKIENyZXcgZGF0YTogJHtjcmV3RGF0YS5sZW5ndGh9IG1lbWJlcnNgKVxyXG4gICAgY29uc29sZS5sb2coYPCfk4ogVHJpcHMgZGF0YTogJHt0cmlwc0RhdGEubGVuZ3RofSB0cmlwc2ApXHJcbiAgICBcclxuICAgIC8vIEdldCBhbGwgdmFzdGUgZGllbnN0IHJlY29yZHNcclxuICAgIGNvbnN0IHsgZGF0YTogYWxsUmVjb3JkcywgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCd2YXN0ZV9kaWVuc3RfcmVjb3JkcycpXHJcbiAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgXHJcbiAgICBpZiAoZmV0Y2hFcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZmV0Y2hpbmcgdmFzdGUgZGllbnN0IHJlY29yZHM6JywgZmV0Y2hFcnJvcilcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICghYWxsUmVjb3JkcyB8fCBhbGxSZWNvcmRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBjb25zb2xlLmxvZygn4pqg77iPIE5vIHZhc3RlIGRpZW5zdCByZWNvcmRzIGZvdW5kIHRvIHJlY2FsY3VsYXRlJylcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGDwn5OLIEZvdW5kICR7YWxsUmVjb3Jkcy5sZW5ndGh9IHJlY29yZHMgdG8gcmVjYWxjdWxhdGVgKVxyXG4gICAgXHJcbiAgICAvLyBQcm9jZXNzIGVhY2ggcmVjb3JkXHJcbiAgICBmb3IgKGNvbnN0IHJlY29yZCBvZiBhbGxSZWNvcmRzKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYFxcbvCflI0gUHJvY2Vzc2luZyByZWNvcmQgJHtyZWNvcmQuaWR9IGZvciBhZmxvc3NlciAke3JlY29yZC5hZmxvc3Nlcl9pZH1gKVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEZpbmQgdGhlIGFmbG9zc2VyXHJcbiAgICAgICAgY29uc3QgYWZsb3NzZXIgPSBjcmV3RGF0YS5maW5kKGNyZXcgPT4gY3Jldy5pZCA9PT0gcmVjb3JkLmFmbG9zc2VyX2lkKVxyXG4gICAgICAgIGlmICghYWZsb3NzZXIpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGDimqDvuI8gQWZsb3NzZXIgbm90IGZvdW5kIGZvciByZWNvcmQgJHtyZWNvcmQuaWR9YClcclxuICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5GkIEZvdW5kIGFmbG9zc2VyOiAke2FmbG9zc2VyLmZpcnN0X25hbWV9ICR7YWZsb3NzZXIubGFzdF9uYW1lfWApXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gR2V0IGFsbCBjb21wbGV0ZWQgdHJpcHMgZm9yIHRoaXMgYWZsb3NzZXJcclxuICAgICAgICBjb25zdCBhbGxUcmlwcyA9IHRyaXBzRGF0YS5maWx0ZXIoKHRyaXA6IGFueSkgPT4gXHJcbiAgICAgICAgICB0cmlwLmFmbG9zc2VyX2lkID09PSByZWNvcmQuYWZsb3NzZXJfaWQgJiZcclxuICAgICAgICAgIHRyaXAuc3RhdHVzID09PSAndm9sdG9vaWQnICYmXHJcbiAgICAgICAgICB0cmlwLnN0YXJ0X2RhdHVtICYmIHRyaXAuZWluZF9kYXR1bSAmJiB0cmlwLnN0YXJ0X3RpamQgJiYgdHJpcC5laW5kX3RpamRcclxuICAgICAgICApXHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc29sZS5sb2coYPCfmqIgRm91bmQgJHthbGxUcmlwcy5sZW5ndGh9IGNvbXBsZXRlZCB0cmlwcyBmb3IgdGhpcyBhZmxvc3NlcmApXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRvdGFsIHdvcmsgZGF5cyB3aXRoIG5ldyBsb2dpY1xyXG4gICAgICAgIGxldCB0b3RhbFdvcmtEYXlzID0gMFxyXG4gICAgICAgIGZvciAoY29uc3QgdHJpcCBvZiBhbGxUcmlwcykge1xyXG4gICAgICAgICAgY29uc3Qgd29ya0RheXMgPSBjYWxjdWxhdGVXb3JrRGF5cyh0cmlwLnN0YXJ0X2RhdHVtLCB0cmlwLnN0YXJ0X3RpamQsIHRyaXAuZWluZF9kYXR1bSwgdHJpcC5laW5kX3RpamQpXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgICDwn5OFIFRyaXAgJHt0cmlwLmlkfTogJHt0cmlwLnN0YXJ0X2RhdHVtfSB0byAke3RyaXAuZWluZF9kYXR1bX0gPSAke3dvcmtEYXlzfSBkYXlzYClcclxuICAgICAgICAgIHRvdGFsV29ya0RheXMgKz0gd29ya0RheXNcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc29sZS5sb2coYPCfk4ogVG90YWwgd29yayBkYXlzIGNhbGN1bGF0ZWQ6ICR7dG90YWxXb3JrRGF5c31gKVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENhcCB2YWx1ZXMgdG8gZml0IGluIERFQ0lNQUwoNCwxKVxyXG4gICAgICAgIGNvbnN0IHJlcXVpcmVkRGF5cyA9IDE1XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ09SUkVDVEUgQkVSRUtFTklORzogRWluZHNhbGRvID0gQmVnaW5zYWxkbyArIChHZXdlcmt0IC0gMTUpXHJcbiAgICAgICAgLy8gVm9vciBlZXJzdGUgbWFhbmQ6IEJlZ2luc2FsZG8gPSAtMTUgKyBzdGFydHNhbGRvXHJcbiAgICAgICAgbGV0IGJlZ2luc2FsZG8gPSByZWNvcmQuYmFsYW5jZV9kYXlzIHx8IDBcclxuICAgICAgICBcclxuICAgICAgICAvLyBBbHMgZGl0IGRlIGVlcnN0ZSBtYWFuZCBpcyBlbiBlciBpcyBnZWVuIGJlZ2luc2FsZG8sIGdlYnJ1aWsgLTE1ICsgc3RhcnRzYWxkb1xyXG4gICAgICAgIGlmIChiZWdpbnNhbGRvID09PSAwICYmIHJlY29yZC5tb250aCA9PT0gMSkge1xyXG4gICAgICAgICAgLy8gUHJvYmVlciBzdGFydHNhbGRvIHVpdCBub3RlcyB0ZSBoYWxlblxyXG4gICAgICAgICAgY29uc3Qgc3RhcnRzYWxkb05vdGUgPSBhZmxvc3Nlci5ub3Rlcz8uZmluZCgobm90ZTogYW55KSA9PiBcclxuICAgICAgICAgICAgbm90ZS50ZXh0ICYmIChub3RlLnRleHQuaW5jbHVkZXMoJ3N0YXJ0c2FsZG8nKSB8fCBub3RlLnRleHQuaW5jbHVkZXMoJ1N0YXJ0c2FsZG8nKSlcclxuICAgICAgICAgIClcclxuICAgICAgICAgIGlmIChzdGFydHNhbGRvTm90ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHN0YXJ0c2FsZG9Ob3RlLnRleHQubWF0Y2goLygtP1xcZCsoPzpcXC5cXGQrKT8pLylcclxuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgY29uc3Qgc3RhcnRzYWxkbyA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pXHJcbiAgICAgICAgICAgICAgYmVnaW5zYWxkbyA9IC0xNSArIHN0YXJ0c2FsZG9cclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiBFZXJzdGUgbWFhbmQgaGVyYmVyZWtlbmluZzogc3RhcnRzYWxkbyAke3N0YXJ0c2FsZG99LCBiZWdpbnNhbGRvICR7YmVnaW5zYWxkb31gKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoYmVnaW5zYWxkbyA9PT0gMCkgYmVnaW5zYWxkbyA9IC0xNSAvLyBGYWxsYmFja1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBWb29yIGRlIGVlcnN0ZSBtYWFuZDogdG9vbiBoZXQgYmVnaW5zYWxkbyBhbHMgaHVpZGlnIHNhbGRvXHJcbiAgICAgICAgLy8gVm9vciB2b2xnZW5kZSBtYWFuZGVuOiBiZXJla2VuIGhldCBlaW5kc2FsZG9cclxuICAgICAgICBsZXQgYmFsYW5jZURheXNcclxuICAgICAgICBpZiAocmVjb3JkLm1vbnRoID09PSAxICYmIGJlZ2luc2FsZG8gIT09IC0xNSkge1xyXG4gICAgICAgICAgLy8gRWVyc3RlIG1hYW5kIG1ldCBzdGFydHNhbGRvOiB0b29uIGJlZ2luc2FsZG9cclxuICAgICAgICAgIGJhbGFuY2VEYXlzID0gYmVnaW5zYWxkb1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBOb3JtYWxlIGJlcmVrZW5pbmc6IGJlZ2luc2FsZG8gKyAoZ2V3ZXJrdCAtIDE1KVxyXG4gICAgICAgICAgYmFsYW5jZURheXMgPSBiZWdpbnNhbGRvICsgKHRvdGFsV29ya0RheXMgLSByZXF1aXJlZERheXMpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNhcHBlZEFjdHVhbERheXMgPSBNYXRoLm1pbih0b3RhbFdvcmtEYXlzLCA5OTkuOSlcclxuICAgICAgICBjb25zdCBjYXBwZWRCYWxhbmNlRGF5cyA9IE1hdGgubWluKE1hdGgubWF4KGJhbGFuY2VEYXlzLCAtOTk5LjkpLCA5OTkuOSlcclxuICAgICAgICBcclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+SviBVcGRhdGluZyByZWNvcmQ6IGFjdHVhbD0ke2NhcHBlZEFjdHVhbERheXN9LCBiYWxhbmNlPSR7Y2FwcGVkQmFsYW5jZURheXN9YClcclxuICAgICAgICBcclxuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlY29yZFxyXG4gICAgICAgIGNvbnN0IHsgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgICAgLmZyb20oJ3Zhc3RlX2RpZW5zdF9yZWNvcmRzJylcclxuICAgICAgICAgIC51cGRhdGUoe1xyXG4gICAgICAgICAgICBhY3R1YWxfZGF5czogY2FwcGVkQWN0dWFsRGF5cyxcclxuICAgICAgICAgICAgYmFsYW5jZV9kYXlzOiBjYXBwZWRCYWxhbmNlRGF5c1xyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIC5lcSgnaWQnLCByZWNvcmQuaWQpXHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHVwZGF0ZUVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGDinYwgRXJyb3IgdXBkYXRpbmcgcmVjb3JkICR7cmVjb3JkLmlkfTpgLCB1cGRhdGVFcnJvcilcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYOKchSBTdWNjZXNzZnVsbHkgdXBkYXRlZCByZWNvcmQgZm9yICR7YWZsb3NzZXIuZmlyc3RfbmFtZX06ICR7Y2FwcGVkQWN0dWFsRGF5c30gZGF5cyAoYmFsYW5jZTogJHtjYXBwZWRCYWxhbmNlRGF5c30pYClcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBFcnJvciBwcm9jZXNzaW5nIHJlY29yZCAke3JlY29yZC5pZH06YCwgZXJyKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCfwn46JIEZvcmNlIHJlY2FsY3VsYXRpb24gY29tcGxldGVkIScpXHJcbiAgICBcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBpbiBmb3JjZSByZWNhbGN1bGF0ZTonLCBlcnIpXHJcbiAgfVxyXG59XHJcblxyXG4vLyBGdW5jdGlvbiB0byByZXNldCBhbGwgdmFzdGUgZGllbnN0IHJlY29yZHMgdG8gMFxyXG5hc3luYyBmdW5jdGlvbiByZXNldEFsbFZhc3RlRGllbnN0UmVjb3JkcygpIHtcclxuICB0cnkge1xyXG4gICAgY29uc29sZS5sb2coJ/Cfp7kgUmVzZXR0aW5nIGFsbCB2YXN0ZSBkaWVuc3QgcmVjb3JkcyB0byAwLi4uJylcclxuICAgIFxyXG4gICAgLy8gR2V0IGFsbCB2YXN0ZSBkaWVuc3QgcmVjb3Jkc1xyXG4gICAgY29uc3QgeyBkYXRhOiBhbGxSZWNvcmRzLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ3Zhc3RlX2RpZW5zdF9yZWNvcmRzJylcclxuICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICBcclxuICAgIGlmIChmZXRjaEVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHZhc3RlIGRpZW5zdCByZWNvcmRzIGZvciByZXNldDonLCBmZXRjaEVycm9yKVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKCFhbGxSZWNvcmRzIHx8IGFsbFJlY29yZHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdObyB2YXN0ZSBkaWVuc3QgcmVjb3JkcyBmb3VuZCB0byByZXNldCcpXHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZyhgRm91bmQgJHthbGxSZWNvcmRzLmxlbmd0aH0gcmVjb3JkcyB0byByZXNldGApXHJcbiAgICBcclxuICAgIC8vIFJlc2V0IGVhY2ggcmVjb3JkIHRvIDBcclxuICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIGFsbFJlY29yZHMpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB7IGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgIC5mcm9tKCd2YXN0ZV9kaWVuc3RfcmVjb3JkcycpXHJcbiAgICAgICAgICAudXBkYXRlKHtcclxuICAgICAgICAgICAgYWN0dWFsX2RheXM6IDAsXHJcbiAgICAgICAgICAgIGJhbGFuY2VfZGF5czogLTE1IC8vIC0xNSBiZWNhdXNlIHJlcXVpcmVkX2RheXMgaXMgMTVcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICAuZXEoJ2lkJywgcmVjb3JkLmlkKVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICh1cGRhdGVFcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihg4p2MIEVycm9yIHJlc2V0dGluZyByZWNvcmQgJHtyZWNvcmQuaWR9OmAsIHVwZGF0ZUVycm9yKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFJlc2V0IHJlY29yZCAke3JlY29yZC5pZH0gdG8gMGApXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciByZXNldHRpbmcgcmVjb3JkICR7cmVjb3JkLmlkfTpgLCBlcnIpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ/CfjokgUmVzZXQgY29tcGxldGVkIScpXHJcbiAgICBcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHJlc2V0IGFsbCByZWNvcmRzOicsIGVycilcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VTdXBhYmFzZURhdGEoKSB7XHJcbiAgY29uc3QgW3NoaXBzLCBzZXRTaGlwc10gPSB1c2VTdGF0ZTxhbnlbXT4oW10pXHJcbiAgY29uc3QgW2NyZXcsIHNldENyZXddID0gdXNlU3RhdGU8YW55W10+KFtdKVxyXG4gIGNvbnN0IFtzaWNrTGVhdmUsIHNldFNpY2tMZWF2ZV0gPSB1c2VTdGF0ZTxhbnlbXT4oW10pXHJcbiAgY29uc3QgW3N0YW5kQmFja1JlY29yZHMsIHNldFN0YW5kQmFja1JlY29yZHNdID0gdXNlU3RhdGU8YW55W10+KFtdKVxyXG4gIGNvbnN0IFtsb2Fucywgc2V0TG9hbnNdID0gdXNlU3RhdGU8YW55W10+KFtdKVxyXG4gIGNvbnN0IFt0cmlwcywgc2V0VHJpcHNdID0gdXNlU3RhdGU8YW55W10+KFtdKVxyXG4gIGNvbnN0IFt2YXN0ZURpZW5zdFJlY29yZHMsIHNldFZhc3RlRGllbnN0UmVjb3Jkc10gPSB1c2VTdGF0ZTxhbnlbXT4oW10pXHJcbiAgY29uc3QgW3Rhc2tzLCBzZXRUYXNrc10gPSB1c2VTdGF0ZTxhbnlbXT4oW10pXHJcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSlcclxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpXHJcbiAgY29uc3QgW2NyZXdDb2xvclRhZ3MsIHNldENyZXdDb2xvclRhZ3NdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgc3RyaW5nPj4oe30pXHJcblxyXG4gIC8vIExvYWQgYWxsIGRhdGEgZnJvbSBTdXBhYmFzZVxyXG4gIGNvbnN0IGxvYWREYXRhID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgc2V0TG9hZGluZyh0cnVlKVxyXG4gICAgICBzZXRFcnJvcihudWxsKVxyXG4gICAgICBjb25zb2xlLmxvZygnTG9hZGluZyBkYXRhIGZyb20gU3VwYWJhc2UuLi4nKVxyXG5cclxuICAgICAgLy8gQ2hlY2sgaWYgdXNlciBpcyBhdXRoZW50aWNhdGVkXHJcbiAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbigpXHJcbiAgICAgIGNvbnNvbGUubG9nKCdDdXJyZW50IHNlc3Npb246Jywgc2Vzc2lvbiA/ICdVc2VyIGxvZ2dlZCBpbicgOiAnTm8gdXNlciBzZXNzaW9uJylcclxuICAgICAgXHJcbiAgICAgIGlmICghc2Vzc2lvbikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignTm8gYWN0aXZlIHNlc3Npb24gLSB1c2VyIG5lZWRzIHRvIGxvZ2luJylcclxuICAgICAgICBzZXRTaGlwcyhbXSlcclxuICAgICAgICBzZXRDcmV3KFtdKVxyXG4gICAgICAgIHNldFNpY2tMZWF2ZShbXSlcclxuICAgICAgICBzZXRTdGFuZEJhY2tSZWNvcmRzKFtdKVxyXG4gICAgICAgIHNldExvYW5zKFtdKVxyXG4gICAgICAgIHNldFRyaXBzKFtdKVxyXG4gICAgICAgIHNldFZhc3RlRGllbnN0UmVjb3JkcyhbXSlcclxuICAgICAgICBzZXRUYXNrcyhbXSlcclxuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKVxyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUZXN0IFN1cGFiYXNlIGNvbm5lY3Rpb25cclxuICAgICAgY29uc29sZS5sb2coJ1Rlc3RpbmcgU3VwYWJhc2UgY29ubmVjdGlvbi4uLicpXHJcbiAgICAgIGNvbnN0IHsgZGF0YTogdGVzdERhdGEsIGVycm9yOiB0ZXN0RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ3NpY2tfbGVhdmUnKVxyXG4gICAgICAgIC5zZWxlY3QoJ2lkJylcclxuICAgICAgICAubGltaXQoMSlcclxuICAgICAgXHJcbiAgICAgIGlmICh0ZXN0RXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBjb25uZWN0aW9uIHRlc3QgZmFpbGVkOicsIHRlc3RFcnJvcilcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdUZXN0IGVycm9yIGRldGFpbHM6JywgSlNPTi5zdHJpbmdpZnkodGVzdEVycm9yLCBudWxsLCAyKSlcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmxvZygn4pyFIFN1cGFiYXNlIGNvbm5lY3Rpb24gdGVzdCBzdWNjZXNzZnVsJylcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTG9hZCBzaGlwc1xyXG4gICAgICBjb25zb2xlLmxvZygnTG9hZGluZyBzaGlwcy4uLicpXHJcbiAgICAgIGNvbnN0IHsgZGF0YTogc2hpcHNEYXRhLCBlcnJvcjogc2hpcHNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnc2hpcHMnKVxyXG4gICAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAgIC5vcmRlcignbmFtZScpXHJcblxyXG4gICAgICBpZiAoc2hpcHNFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgc2hpcHM6Jywgc2hpcHNFcnJvcilcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdTaGlwcyBlcnJvciBkZXRhaWxzOicsIEpTT04uc3RyaW5naWZ5KHNoaXBzRXJyb3IsIG51bGwsIDIpKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdTaGlwcyBsb2FkZWQ6Jywgc2hpcHNEYXRhPy5sZW5ndGggfHwgMClcclxuICAgICAgICBzZXRTaGlwcyhzaGlwc0RhdGEgfHwgW10pXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIExvYWQgY3Jld1xyXG4gICAgICBjb25zb2xlLmxvZygnTG9hZGluZyBjcmV3Li4uJylcclxuICAgICAgY29uc3QgeyBkYXRhOiBjcmV3RGF0YSwgZXJyb3I6IGNyZXdFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnY3JldycpXHJcbiAgICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgICAgLm9yZGVyKCdmaXJzdF9uYW1lJylcclxuXHJcbiAgICAgIGlmIChjcmV3RXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGNyZXc6JywgY3Jld0Vycm9yKVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NyZXcgZXJyb3IgZGV0YWlsczonLCBKU09OLnN0cmluZ2lmeShjcmV3RXJyb3IsIG51bGwsIDIpKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdDcmV3IGxvYWRlZDonLCBjcmV3RGF0YT8ubGVuZ3RoIHx8IDApXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVGVtcG9yYXJpbHkgZGlzYWJsZSBhdXRvLWFjdGl2YXRpb24gYW5kIHJvdGF0aW9uIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHNcclxuICAgICAgICAvLyBhd2FpdCBhdXRvQWN0aXZhdGVDcmV3TWVtYmVycyhjcmV3RGF0YSB8fCBbXSlcclxuICAgICAgICAvLyBhd2FpdCBhdXRvUm90YXRlQ3Jld01lbWJlcnMoY3Jld0RhdGEgfHwgW10pXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gU2V0IGNyZXcgZGF0YSBkaXJlY3RseSB3aXRob3V0IHJlbG9hZGluZ1xyXG4gICAgICAgIHNldENyZXcoY3Jld0RhdGEgfHwgW10pXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIExvYWQgc2ljayBsZWF2ZVxyXG4gICAgICBjb25zb2xlLmxvZygnTG9hZGluZyBzaWNrIGxlYXZlLi4uJylcclxuICAgICAgY29uc3QgeyBkYXRhOiBzaWNrTGVhdmVEYXRhLCBlcnJvcjogc2lja0xlYXZlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ3NpY2tfbGVhdmUnKVxyXG4gICAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAgIC5vcmRlcignc3RhcnRfZGF0ZScsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxyXG5cclxuICAgICAgaWYgKHNpY2tMZWF2ZUVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBzaWNrIGxlYXZlOicsIHNpY2tMZWF2ZUVycm9yKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdTaWNrIGxlYXZlIGxvYWRlZDonLCBzaWNrTGVhdmVEYXRhPy5sZW5ndGggfHwgMClcclxuICAgICAgICBzZXRTaWNrTGVhdmUoc2lja0xlYXZlRGF0YSB8fCBbXSlcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTG9hZCBzdGFuZCBiYWNrIHJlY29yZHNcclxuICAgICAgY29uc29sZS5sb2coJ0xvYWRpbmcgc3RhbmQgYmFjayByZWNvcmRzLi4uJylcclxuICAgICAgY29uc3QgeyBkYXRhOiBzdGFuZEJhY2tEYXRhLCBlcnJvcjogc3RhbmRCYWNrRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ3N0YW5kX2JhY2tfcmVjb3JkcycpXHJcbiAgICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXHJcblxyXG4gICAgICBpZiAoc3RhbmRCYWNrRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHN0YW5kIGJhY2sgcmVjb3JkczonLCBzdGFuZEJhY2tFcnJvcilcclxuICAgICAgICBzZXRTdGFuZEJhY2tSZWNvcmRzKFtdKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdTdGFuZCBiYWNrIHJlY29yZHMgbG9hZGVkOicsIHN0YW5kQmFja0RhdGE/Lmxlbmd0aCB8fCAwKVxyXG4gICAgICAgIHNldFN0YW5kQmFja1JlY29yZHMoc3RhbmRCYWNrRGF0YSB8fCBbXSlcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTG9hZCBsb2Fuc1xyXG4gICAgICBjb25zb2xlLmxvZygnTG9hZGluZyBsb2Fucy4uLicpXHJcbiAgICAgIGNvbnN0IHsgZGF0YTogbG9hbnNEYXRhLCBlcnJvcjogbG9hbnNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnbG9hbnMnKVxyXG4gICAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxyXG5cclxuICAgICAgaWYgKGxvYW5zRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGxvYW5zOicsIGxvYW5zRXJyb3IpXHJcbiAgICAgICAgc2V0TG9hbnMoW10pXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0xvYW5zIGxvYWRlZDonLCBsb2Fuc0RhdGE/Lmxlbmd0aCB8fCAwKVxyXG4gICAgICAgIHNldExvYW5zKGxvYW5zRGF0YSB8fCBbXSlcclxuICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTG9hZCB0cmlwc1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTG9hZGluZyB0cmlwcy4uLicpXHJcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogdHJpcHNEYXRhLCBlcnJvcjogdHJpcHNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgICAgICAuZnJvbSgndHJpcHMnKVxyXG4gICAgICAgICAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAgICAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxyXG5cclxuICAgICAgICAgICAgaWYgKHRyaXBzRXJyb3IpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHRyaXBzOicsIHRyaXBzRXJyb3IpXHJcbiAgICAgICAgICAgICAgc2V0VHJpcHMoW10pXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1RyaXBzIGxvYWRlZDonLCB0cmlwc0RhdGE/Lmxlbmd0aCB8fCAwKVxyXG4gICAgICAgICAgICAgIHNldFRyaXBzKHRyaXBzRGF0YSB8fCBbXSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTG9hZCB2YXN0ZSBkaWVuc3QgcmVjb3Jkc1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTG9hZGluZyB2YXN0ZSBkaWVuc3QgcmVjb3Jkcy4uLicpXHJcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogdmFzdGVEaWVuc3REYXRhLCBlcnJvcjogdmFzdGVEaWVuc3RFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgICAgICAuZnJvbSgndmFzdGVfZGllbnN0X3JlY29yZHMnKVxyXG4gICAgICAgICAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAgICAgICAgIC5vcmRlcigneWVhcicsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxyXG4gICAgICAgICAgICAgIC5vcmRlcignbW9udGgnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcclxuXHJcbiAgICAgICAgICAgIGlmICh2YXN0ZURpZW5zdEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyB2YXN0ZSBkaWVuc3QgcmVjb3JkczonLCB2YXN0ZURpZW5zdEVycm9yKVxyXG4gICAgICAgICAgICAgIHNldFZhc3RlRGllbnN0UmVjb3JkcyhbXSlcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVmFzdGUgZGllbnN0IHJlY29yZHMgbG9hZGVkOicsIHZhc3RlRGllbnN0RGF0YT8ubGVuZ3RoIHx8IDApXHJcbiAgICAgICAgICAgICAgc2V0VmFzdGVEaWVuc3RSZWNvcmRzKHZhc3RlRGllbnN0RGF0YSB8fCBbXSlcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBBdXRvLW1hbmFnZSB2YXN0ZSBkaWVuc3QgcmVjb3JkcyBhZnRlciBsb2FkaW5nIGFsbCBkYXRhXHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ/CflKcgQXV0by1tYW5hZ2luZyB2YXN0ZSBkaWVuc3QgcmVjb3Jkcy4uLicpXHJcbiAgICAgICAgICAgICAgYXdhaXQgYXV0b01hbmFnZVZhc3RlRGllbnN0UmVjb3JkcyhjcmV3RGF0YSB8fCBbXSwgdmFzdGVEaWVuc3REYXRhIHx8IFtdLCB0cmlwc0RhdGEgfHwgW10pXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgIC8vIExvYWQgdGFza3NcclxuICAgICAgY29uc29sZS5sb2coJ0xvYWRpbmcgdGFza3MuLi4nKVxyXG4gICAgICBjb25zdCB7IGRhdGE6IHRhc2tzRGF0YSwgZXJyb3I6IHRhc2tzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ3Rhc2tzJylcclxuICAgICAgICAuc2VsZWN0KCcqJylcclxuICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcclxuXHJcbiAgICAgIGlmICh0YXNrc0Vycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyB0YXNrczonLCB0YXNrc0Vycm9yKVxyXG4gICAgICAgIHNldFRhc2tzKFtdKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdUYXNrcyBsb2FkZWQ6JywgdGFza3NEYXRhPy5sZW5ndGggfHwgMClcclxuICAgICAgICBzZXRUYXNrcyh0YXNrc0RhdGEgfHwgW10pXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCdEYXRhIGxvYWRpbmcgY29tcGxldGVkIScpXHJcblxyXG4gICAgICAvLyBMb2FkIGNyZXcgY29sb3IgdGFncyBsYXN0LCBub24tYmxvY2tpbmcgZm9yIG1haW4gZGF0YVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHsgZGF0YTogY29sb3JSb3dzLCBlcnJvcjogY29sb3JFcnIgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgICAuZnJvbSgnY3Jld19jb2xvcl90YWdzJylcclxuICAgICAgICAgIC5zZWxlY3QoJ2NyZXdfaWQsIGNvbG9yJylcclxuICAgICAgICBpZiAoY29sb3JFcnIpIHtcclxuICAgICAgICAgIGNvbnN0IG1zZyA9IChjb2xvckVyciBhcyBhbnkpPy5tZXNzYWdlIHx8IFN0cmluZyhjb2xvckVycilcclxuICAgICAgICAgIGNvbnNvbGUud2FybignU2tpcHBpbmcgY3Jld19jb2xvcl90YWdzICh0YWJsZSBtaXNzaW5nIG9yIG5vIGFjY2Vzcyk6JywgbXNnKVxyXG4gICAgICAgICAgc2V0Q3Jld0NvbG9yVGFncyh7fSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc3QgbWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge31cclxuICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIGNvbG9yUm93cyB8fCBbXSkge1xyXG4gICAgICAgICAgICBpZiAocm93LmNyZXdfaWQgJiYgcm93LmNvbG9yKSBtYXBbcm93LmNyZXdfaWRdID0gcm93LmNvbG9yXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzZXRDcmV3Q29sb3JUYWdzKG1hcClcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIGxvYWRpbmcgY3Jld19jb2xvcl90YWdzOicsIChlIGFzIGFueSk/Lm1lc3NhZ2UgfHwgZSlcclxuICAgICAgICBzZXRDcmV3Q29sb3JUYWdzKHt9KVxyXG4gICAgICB9XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGxvYWREYXRhOicsIGVycilcclxuICAgICAgc2V0RXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJylcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBMb2FkIGRhdGEgb24gbW91bnRcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgbG9hZERhdGEoKVxyXG4gICAgXHJcbiAgICAvLyBUZW1wb3JhcmlseSBkaXNhYmxlIGRhaWx5IGNoZWNrIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHNcclxuICAgIC8vIGNvbnN0IGRhaWx5Q2hlY2sgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAvLyAgIGNvbnNvbGUubG9nKCdSdW5uaW5nIGRhaWx5IGF1dG8tYWN0aXZhdGlvbiBjaGVjay4uLicpXHJcbiAgICAvLyAgIGxvYWREYXRhKCkgLy8gRGl0IHphbCBhdXRvQWN0aXZhdGVDcmV3TWVtYmVycyBhYW5yb2VwZW5cclxuICAgIC8vIH0sIDI0ICogNjAgKiA2MCAqIDEwMDApIC8vIDI0IHV1clxyXG4gICAgXHJcbiAgICAvLyByZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbChkYWlseUNoZWNrKVxyXG4gIH0sIFtdKVxyXG5cclxuICAvLyBTdWJzY3JpYmUgdG8gcmVhbC10aW1lIGNoYW5nZXNcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgLy8gU3Vic2NyaWJlIHRvIHNoaXBzIGNoYW5nZXNcclxuICAgIGNvbnN0IHNoaXBzU3Vic2NyaXB0aW9uID0gc3VwYWJhc2VcclxuICAgICAgLmNoYW5uZWwoJ3NoaXBzLWNoYW5nZXMnKVxyXG4gICAgICAub24oJ3Bvc3RncmVzX2NoYW5nZXMnLCB7IGV2ZW50OiAnKicsIHNjaGVtYTogJ3B1YmxpYycsIHRhYmxlOiAnc2hpcHMnIH0sICgpID0+IHtcclxuICAgICAgICBsb2FkRGF0YSgpXHJcbiAgICAgIH0pXHJcbiAgICAgIC5zdWJzY3JpYmUoKVxyXG5cclxuICAgIC8vIFN1YnNjcmliZSB0byBjcmV3IGNoYW5nZXNcclxuICAgIGNvbnN0IGNyZXdTdWJzY3JpcHRpb24gPSBzdXBhYmFzZVxyXG4gICAgICAuY2hhbm5lbCgnY3Jldy1jaGFuZ2VzJylcclxuICAgICAgLm9uKCdwb3N0Z3Jlc19jaGFuZ2VzJywgeyBldmVudDogJyonLCBzY2hlbWE6ICdwdWJsaWMnLCB0YWJsZTogJ2NyZXcnIH0sICgpID0+IHtcclxuICAgICAgICBsb2FkRGF0YSgpXHJcbiAgICAgIH0pXHJcbiAgICAgIC5zdWJzY3JpYmUoKVxyXG5cclxuICAgIC8vIFN1YnNjcmliZSB0byBzaWNrIGxlYXZlIGNoYW5nZXNcclxuICAgIGNvbnN0IHNpY2tMZWF2ZVN1YnNjcmlwdGlvbiA9IHN1cGFiYXNlXHJcbiAgICAgIC5jaGFubmVsKCdzaWNrLWxlYXZlLWNoYW5nZXMnKVxyXG4gICAgICAub24oJ3Bvc3RncmVzX2NoYW5nZXMnLCB7IGV2ZW50OiAnKicsIHNjaGVtYTogJ3B1YmxpYycsIHRhYmxlOiAnc2lja19sZWF2ZScgfSwgKCkgPT4ge1xyXG4gICAgICAgIGxvYWREYXRhKClcclxuICAgICAgfSlcclxuICAgICAgLnN1YnNjcmliZSgpXHJcblxyXG4gICAgLy8gU3Vic2NyaWJlIHRvIHN0YW5kIGJhY2sgcmVjb3JkcyBjaGFuZ2VzXHJcbiAgICBjb25zdCBzdGFuZEJhY2tTdWJzY3JpcHRpb24gPSBzdXBhYmFzZVxyXG4gICAgICAuY2hhbm5lbCgnc3RhbmQtYmFjay1jaGFuZ2VzJylcclxuICAgICAgLm9uKCdwb3N0Z3Jlc19jaGFuZ2VzJywgeyBldmVudDogJyonLCBzY2hlbWE6ICdwdWJsaWMnLCB0YWJsZTogJ3N0YW5kX2JhY2tfcmVjb3JkcycgfSwgKCkgPT4ge1xyXG4gICAgICAgIGxvYWREYXRhKClcclxuICAgICAgfSlcclxuICAgICAgLnN1YnNjcmliZSgpXHJcblxyXG4gICAgLy8gU3Vic2NyaWJlIHRvIGxvYW5zIGNoYW5nZXNcclxuICAgIGNvbnN0IGxvYW5zU3Vic2NyaXB0aW9uID0gc3VwYWJhc2VcclxuICAgICAgLmNoYW5uZWwoJ2xvYW5zLWNoYW5nZXMnKVxyXG4gICAgICAub24oJ3Bvc3RncmVzX2NoYW5nZXMnLCB7IGV2ZW50OiAnKicsIHNjaGVtYTogJ3B1YmxpYycsIHRhYmxlOiAnbG9hbnMnIH0sICgpID0+IHtcclxuICAgICAgICBsb2FkRGF0YSgpXHJcbiAgICAgIH0pXHJcbiAgICAgIC5zdWJzY3JpYmUoKVxyXG5cclxuICAgIC8vIFN1YnNjcmliZSB0byB0cmlwcyBjaGFuZ2VzXHJcbiAgICBjb25zdCB0cmlwc1N1YnNjcmlwdGlvbiA9IHN1cGFiYXNlXHJcbiAgICAgIC5jaGFubmVsKCd0cmlwcy1jaGFuZ2VzJylcclxuICAgICAgLm9uKCdwb3N0Z3Jlc19jaGFuZ2VzJywgeyBldmVudDogJyonLCBzY2hlbWE6ICdwdWJsaWMnLCB0YWJsZTogJ3RyaXBzJyB9LCAoKSA9PiB7XHJcbiAgICAgICAgbG9hZERhdGEoKVxyXG4gICAgICB9KVxyXG4gICAgICAuc3Vic2NyaWJlKClcclxuXHJcbiAgICAvLyBTdWJzY3JpYmUgdG8gdGFza3MgY2hhbmdlc1xyXG4gICAgY29uc3QgdGFza3NTdWJzY3JpcHRpb24gPSBzdXBhYmFzZVxyXG4gICAgICAuY2hhbm5lbCgndGFza3MtY2hhbmdlcycpXHJcbiAgICAgIC5vbigncG9zdGdyZXNfY2hhbmdlcycsIHsgZXZlbnQ6ICcqJywgc2NoZW1hOiAncHVibGljJywgdGFibGU6ICd0YXNrcycgfSwgKCkgPT4ge1xyXG4gICAgICAgIGxvYWREYXRhKClcclxuICAgICAgfSlcclxuICAgICAgLnN1YnNjcmliZSgpXHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgc2hpcHNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKVxyXG4gICAgICBjcmV3U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKClcclxuICAgICAgc2lja0xlYXZlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKClcclxuICAgICAgc3RhbmRCYWNrU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKClcclxuICAgICAgbG9hbnNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKVxyXG4gICAgICB0cmlwc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpXHJcbiAgICAgIHRhc2tzU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKClcclxuICAgIH1cclxuICB9LCBbXSlcclxuXHJcbiAgLy8gQWRkIGNyZXcgbWVtYmVyXHJcbiAgY29uc3QgYWRkQ3JldyA9IGFzeW5jIChjcmV3RGF0YTogYW55KSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnQWRkaW5nIGNyZXcgbWVtYmVyIHRvIFN1cGFiYXNlOicsIGNyZXdEYXRhKVxyXG4gICAgICBjb25zb2xlLmxvZygnQ3JldyBkYXRhIGRldGFpbHM6JywgSlNPTi5zdHJpbmdpZnkoY3Jld0RhdGEsIG51bGwsIDIpKVxyXG4gICAgICBcclxuICAgICAgLy8gVmFsaWRhdGUgcmVxdWlyZWQgZmllbGRzXHJcbiAgICAgIGNvbnN0IHJlcXVpcmVkRmllbGRzID0gWydpZCcsICdmaXJzdF9uYW1lJywgJ2xhc3RfbmFtZScsICduYXRpb25hbGl0eScsICdwb3NpdGlvbiddXHJcbiAgICAgIGNvbnN0IG1pc3NpbmdGaWVsZHMgPSByZXF1aXJlZEZpZWxkcy5maWx0ZXIoZmllbGQgPT4gIWNyZXdEYXRhW2ZpZWxkXSlcclxuICAgICAgXHJcbiAgICAgIGlmIChtaXNzaW5nRmllbGRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgTWlzc2luZyByZXF1aXJlZCBmaWVsZHM6ICR7bWlzc2luZ0ZpZWxkcy5qb2luKCcsICcpfWApXHJcbiAgICAgICAgY29uc29sZS5lcnJvcignVmFsaWRhdGlvbiBlcnJvcjonLCBlcnJvcilcclxuICAgICAgICB0aHJvdyBlcnJvclxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBDaGVjayBmb3IgZHVwbGljYXRlIGNyZXcgbWVtYmVyXHJcbiAgICAgIGNvbnN0IHsgZGF0YTogZXhpc3RpbmdDcmV3LCBlcnJvcjogY2hlY2tFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnY3JldycpXHJcbiAgICAgICAgLnNlbGVjdCgnaWQnKVxyXG4gICAgICAgIC5lcSgnZmlyc3RfbmFtZScsIGNyZXdEYXRhLmZpcnN0X25hbWUpXHJcbiAgICAgICAgLmVxKCdsYXN0X25hbWUnLCBjcmV3RGF0YS5sYXN0X25hbWUpXHJcbiAgICAgICAgLmVxKCduYXRpb25hbGl0eScsIGNyZXdEYXRhLm5hdGlvbmFsaXR5KVxyXG4gICAgICAgIC5zaW5nbGUoKVxyXG4gICAgICBcclxuICAgICAgaWYgKGV4aXN0aW5nQ3JldyAmJiAhY2hlY2tFcnJvcikge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBDcmV3IG1lbWJlciB3aXRoIG5hbWUgJHtjcmV3RGF0YS5maXJzdF9uYW1lfSAke2NyZXdEYXRhLmxhc3RfbmFtZX0gYWxyZWFkeSBleGlzdHNgKVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0R1cGxpY2F0ZSBjcmV3IG1lbWJlcjonLCBlcnJvcilcclxuICAgICAgICB0aHJvdyBlcnJvclxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdjcmV3JylcclxuICAgICAgICAuaW5zZXJ0KFtjcmV3RGF0YV0pXHJcbiAgICAgICAgLnNlbGVjdCgpXHJcbiAgICAgICAgLnNpbmdsZSgpXHJcblxyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBlcnJvciBhZGRpbmcgY3JldzonLCBlcnJvcilcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZXRhaWxzOicsIEpTT04uc3RyaW5naWZ5KGVycm9yLCBudWxsLCAyKSlcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjb2RlOicsIGVycm9yLmNvZGUpXHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbWVzc2FnZTonLCBlcnJvci5tZXNzYWdlKVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGhpbnQ6JywgZXJyb3IuaGludClcclxuICAgICAgICB0aHJvdyBlcnJvclxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZygnQ3JldyBtZW1iZXIgYWRkZWQgc3VjY2Vzc2Z1bGx5OicsIGRhdGEpXHJcbiAgICAgIGF3YWl0IGxvYWREYXRhKClcclxuICAgICAgcmV0dXJuIGRhdGFcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgY3JldzonLCBlcnIpXHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFpbHM6JywgSlNPTi5zdHJpbmdpZnkoZXJyLCBudWxsLCAyKSlcclxuICAgICAgdGhyb3cgZXJyXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBVcGRhdGUgY3JldyBtZW1iZXJcclxuICBjb25zdCB1cGRhdGVDcmV3ID0gYXN5bmMgKGlkOiBzdHJpbmcsIHVwZGF0ZXM6IGFueSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ1VwZGF0aW5nIGNyZXcgbWVtYmVyIGluIFN1cGFiYXNlOicsIGlkLCB1cGRhdGVzKVxyXG4gICAgICBcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnY3JldycpXHJcbiAgICAgICAgLnVwZGF0ZSh1cGRhdGVzKVxyXG4gICAgICAgIC5lcSgnaWQnLCBpZClcclxuICAgICAgICAuc2VsZWN0KClcclxuICAgICAgICAuc2luZ2xlKClcclxuXHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N1cGFiYXNlIGVycm9yIHVwZGF0aW5nIGNyZXc6JywgZXJyb3IpXHJcbiAgICAgICAgdGhyb3cgZXJyb3JcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5sb2coJ0NyZXcgbWVtYmVyIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5JylcclxuICAgICAgYXdhaXQgbG9hZERhdGEoKVxyXG4gICAgICByZXR1cm4gZGF0YVxyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGNyZXc6JywgZXJyKVxyXG4gICAgICB0aHJvdyBlcnJcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIERlbGV0ZSBjcmV3IG1lbWJlclxyXG4gIGNvbnN0IGRlbGV0ZUNyZXcgPSBhc3luYyAoaWQ6IHN0cmluZykgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnY3JldycpXHJcbiAgICAgICAgLmRlbGV0ZSgpXHJcbiAgICAgICAgLmVxKCdpZCcsIGlkKVxyXG4gICAgICBcclxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG4gICAgICBcclxuICAgICAgYXdhaXQgbG9hZERhdGEoKSAvLyBSZWxvYWQgYWxsIGRhdGFcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBjcmV3OicsIGVycilcclxuICAgICAgdGhyb3cgZXJyXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgc2hpcFxyXG4gIGNvbnN0IGFkZFNoaXAgPSBhc3luYyAoc2hpcERhdGE6IGFueSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ0FkZGluZyBzaGlwIHRvIFN1cGFiYXNlOicsIHNoaXBEYXRhKVxyXG4gICAgICBcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnc2hpcHMnKVxyXG4gICAgICAgIC5pbnNlcnQoW3NoaXBEYXRhXSlcclxuICAgICAgICAuc2VsZWN0KClcclxuICAgICAgICAuc2luZ2xlKClcclxuXHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N1cGFiYXNlIGVycm9yIGFkZGluZyBzaGlwOicsIGVycm9yKVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFpbHM6JywgSlNPTi5zdHJpbmdpZnkoZXJyb3IsIG51bGwsIDIpKVxyXG4gICAgICAgIHRocm93IGVycm9yXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCdTaGlwIGFkZGVkIHN1Y2Nlc3NmdWxseTonLCBkYXRhKVxyXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpXHJcbiAgICAgIHJldHVybiBkYXRhXHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIHNoaXA6JywgZXJyKVxyXG4gICAgICB0aHJvdyBlcnJcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFVwZGF0ZSBzaGlwXHJcbiAgY29uc3QgdXBkYXRlU2hpcCA9IGFzeW5jIChpZDogc3RyaW5nLCB1cGRhdGVzOiBhbnkpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ3NoaXBzJylcclxuICAgICAgICAudXBkYXRlKHVwZGF0ZXMpXHJcbiAgICAgICAgLmVxKCdpZCcsIGlkKVxyXG4gICAgICAgIC5zZWxlY3QoKVxyXG4gICAgICAgIC5zaW5nbGUoKVxyXG4gICAgICBcclxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG4gICAgICBcclxuICAgICAgYXdhaXQgbG9hZERhdGEoKSAvLyBSZWxvYWQgYWxsIGRhdGFcclxuICAgICAgcmV0dXJuIGRhdGFcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBzaGlwOicsIGVycilcclxuICAgICAgdGhyb3cgZXJyXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBEZWxldGUgc2hpcFxyXG4gIGNvbnN0IGRlbGV0ZVNoaXAgPSBhc3luYyAoaWQ6IHN0cmluZykgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnc2hpcHMnKVxyXG4gICAgICAgIC5kZWxldGUoKVxyXG4gICAgICAgIC5lcSgnaWQnLCBpZClcclxuXHJcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcclxuXHJcbiAgICAgIGF3YWl0IGxvYWREYXRhKCkgLy8gUmVsb2FkIGFsbCBkYXRhXHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgc2hpcDonLCBlcnIpXHJcbiAgICAgIHRocm93IGVyclxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQWRkIHNpY2sgbGVhdmVcclxuICBjb25zdCBhZGRTaWNrTGVhdmUgPSBhc3luYyAoc2lja0xlYXZlRGF0YTogYW55KSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnQWRkaW5nIHNpY2sgbGVhdmUgdG8gU3VwYWJhc2U6Jywgc2lja0xlYXZlRGF0YSlcclxuICAgICAgXHJcbiAgICAgIC8vIEVuc3VyZSBub3RlcyBpcyBub3QgbnVsbFxyXG4gICAgICBpZiAoc2lja0xlYXZlRGF0YS5ub3RlcyA9PT0gbnVsbCB8fCBzaWNrTGVhdmVEYXRhLm5vdGVzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBzaWNrTGVhdmVEYXRhLm5vdGVzID0gXCJcIlxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdzaWNrX2xlYXZlJylcclxuICAgICAgICAuaW5zZXJ0KFtzaWNrTGVhdmVEYXRhXSlcclxuICAgICAgICAuc2VsZWN0KClcclxuICAgICAgICAuc2luZ2xlKClcclxuXHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N1cGFiYXNlIGVycm9yIGFkZGluZyBzaWNrIGxlYXZlOicsIGVycm9yKVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFpbHM6JywgSlNPTi5zdHJpbmdpZnkoZXJyb3IsIG51bGwsIDIpKVxyXG4gICAgICAgIHRocm93IGVycm9yXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCdTaWNrIGxlYXZlIGFkZGVkIHN1Y2Nlc3NmdWxseTonLCBkYXRhKVxyXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpIC8vIFJlbG9hZCBhbGwgZGF0YVxyXG4gICAgICByZXR1cm4gZGF0YVxyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBzaWNrIGxlYXZlOicsIGVycilcclxuICAgICAgdGhyb3cgZXJyXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBVcGRhdGUgc2ljayBsZWF2ZVxyXG4gIGNvbnN0IHVwZGF0ZVNpY2tMZWF2ZSA9IGFzeW5jIChpZDogc3RyaW5nLCB1cGRhdGVzOiBhbnkpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdVcGRhdGluZyBzaWNrIGxlYXZlIGluIFN1cGFiYXNlOicsIGlkLCB1cGRhdGVzKVxyXG4gICAgICBcclxuICAgICAgLy8gRW5zdXJlIG5vdGVzIGlzIG5vdCBudWxsXHJcbiAgICAgIGlmICh1cGRhdGVzLm5vdGVzID09PSBudWxsIHx8IHVwZGF0ZXMubm90ZXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHVwZGF0ZXMubm90ZXMgPSBcIlwiXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ3NpY2tfbGVhdmUnKVxyXG4gICAgICAgIC51cGRhdGUodXBkYXRlcylcclxuICAgICAgICAuZXEoJ2lkJywgaWQpXHJcbiAgICAgICAgLnNlbGVjdCgpXHJcbiAgICAgICAgLnNpbmdsZSgpXHJcblxyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBlcnJvciB1cGRhdGluZyBzaWNrIGxlYXZlOicsIGVycm9yKVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFpbHM6JywgSlNPTi5zdHJpbmdpZnkoZXJyb3IsIG51bGwsIDIpKVxyXG4gICAgICAgIHRocm93IGVycm9yXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCdTaWNrIGxlYXZlIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5OicsIGRhdGEpXHJcbiAgICAgIGF3YWl0IGxvYWREYXRhKCkgLy8gUmVsb2FkIGFsbCBkYXRhXHJcbiAgICAgIHJldHVybiBkYXRhXHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgc2ljayBsZWF2ZTonLCBlcnIpXHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFpbHM6JywgSlNPTi5zdHJpbmdpZnkoZXJyLCBudWxsLCAyKSlcclxuICAgICAgdGhyb3cgZXJyXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBhZGRTdGFuZEJhY2tSZWNvcmQgPSBhc3luYyAocmVjb3JkRGF0YTogYW55KSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnPT09IEFERElORyBTVEFORCBCQUNLIFJFQ09SRCA9PT0nKVxyXG4gICAgICBjb25zb2xlLmxvZygnT3JpZ2luYWwgcmVjb3JkIGRhdGE6JywgcmVjb3JkRGF0YSlcclxuICAgICAgXHJcbiAgICAgIC8vIEdlbmVyYXRlIGEgVVVJRCBmb3IgdGhlIGlkIGZpZWxkXHJcbiAgICAgIGNvbnN0IHV1aWQgPSBjcnlwdG8ucmFuZG9tVVVJRCgpXHJcbiAgICAgIGNvbnNvbGUubG9nKCdHZW5lcmF0ZWQgVVVJRDonLCB1dWlkKVxyXG4gICAgICBcclxuICAgICAgLy8gUmVtb3ZlIGlkIGlmIGl0IGV4aXN0cyBhbmQgYWRkIG91ciBnZW5lcmF0ZWQgVVVJRFxyXG4gICAgICBjb25zdCB7IGlkLCAuLi5kYXRhV2l0aG91dElkIH0gPSByZWNvcmREYXRhXHJcbiAgICAgIFxyXG4gICAgICAvLyBDcmVhdGUgYSBzYWZlIGRhdGEgb2JqZWN0IHdpdGggb25seSBrbm93biBkYXRhYmFzZSBjb2x1bW5zXHJcbiAgICAgIGNvbnN0IGRhdGFUb0luc2VydCA9IHtcclxuICAgICAgICBpZDogdXVpZCxcclxuICAgICAgICBjcmV3X21lbWJlcl9pZDogZGF0YVdpdGhvdXRJZC5jcmV3X21lbWJlcl9pZCxcclxuICAgICAgICBzdGFydF9kYXRlOiBkYXRhV2l0aG91dElkLnN0YXJ0X2RhdGUsXHJcbiAgICAgICAgZW5kX2RhdGU6IGRhdGFXaXRob3V0SWQuZW5kX2RhdGUsXHJcbiAgICAgICAgZGF5c19jb3VudDogZGF0YVdpdGhvdXRJZC5kYXlzX2NvdW50LFxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkYXRhV2l0aG91dElkLmRlc2NyaXB0aW9uLFxyXG4gICAgICAgIHN0YW5kX2JhY2tfZGF5c19yZXF1aXJlZDogZGF0YVdpdGhvdXRJZC5zdGFuZF9iYWNrX2RheXNfcmVxdWlyZWQsXHJcbiAgICAgICAgc3RhbmRfYmFja19kYXlzX2NvbXBsZXRlZDogZGF0YVdpdGhvdXRJZC5zdGFuZF9iYWNrX2RheXNfY29tcGxldGVkLFxyXG4gICAgICAgIHN0YW5kX2JhY2tfZGF5c19yZW1haW5pbmc6IGRhdGFXaXRob3V0SWQuc3RhbmRfYmFja19kYXlzX3JlbWFpbmluZyxcclxuICAgICAgICBzdGFuZF9iYWNrX3N0YXR1czogZGF0YVdpdGhvdXRJZC5zdGFuZF9iYWNrX3N0YXR1cyxcclxuICAgICAgICBzdGFuZF9iYWNrX2hpc3Rvcnk6IGRhdGFXaXRob3V0SWQuc3RhbmRfYmFja19oaXN0b3J5IHx8IFtdXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEFkZCBvcHRpb25hbCBmaWVsZHMgaWYgdGhleSBleGlzdCAoZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXHJcbiAgICAgIGlmIChkYXRhV2l0aG91dElkLnJlYXNvbikge1xyXG4gICAgICAgIChkYXRhVG9JbnNlcnQgYXMgYW55KS5yZWFzb24gPSBkYXRhV2l0aG91dElkLnJlYXNvblxyXG4gICAgICB9XHJcbiAgICAgIGlmIChkYXRhV2l0aG91dElkLm5vdGVzKSB7XHJcbiAgICAgICAgKGRhdGFUb0luc2VydCBhcyBhbnkpLm5vdGVzID0gZGF0YVdpdGhvdXRJZC5ub3Rlc1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygnRGF0YSB0byBpbnNlcnQgKHdpdGggZ2VuZXJhdGVkIFVVSUQpOicsIGRhdGFUb0luc2VydClcclxuICAgICAgY29uc29sZS5sb2coJ0RhdGEgdG8gaW5zZXJ0IEpTT046JywgSlNPTi5zdHJpbmdpZnkoZGF0YVRvSW5zZXJ0LCBudWxsLCAyKSlcclxuICAgICAgXHJcbiAgICAgIC8vIFZhbGlkYXRlIHJlcXVpcmVkIGZpZWxkc1xyXG4gICAgICBjb25zdCByZXF1aXJlZEZpZWxkcyA9IFsnaWQnLCAnY3Jld19tZW1iZXJfaWQnLCAnc3RhcnRfZGF0ZScsICdlbmRfZGF0ZScsICdkYXlzX2NvdW50JywgJ3N0YW5kX2JhY2tfZGF5c19yZXF1aXJlZCcsICdzdGFuZF9iYWNrX2RheXNfY29tcGxldGVkJywgJ3N0YW5kX2JhY2tfZGF5c19yZW1haW5pbmcnLCAnc3RhbmRfYmFja19zdGF0dXMnXVxyXG4gICAgICBjb25zdCBtaXNzaW5nRmllbGRzID0gcmVxdWlyZWRGaWVsZHMuZmlsdGVyKGZpZWxkID0+ICEoZGF0YVRvSW5zZXJ0IGFzIGFueSlbZmllbGRdICYmIChkYXRhVG9JbnNlcnQgYXMgYW55KVtmaWVsZF0gIT09IDApXHJcbiAgICAgIFxyXG4gICAgICBpZiAobWlzc2luZ0ZpZWxkcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignTWlzc2luZyByZXF1aXJlZCBmaWVsZHM6JywgbWlzc2luZ0ZpZWxkcylcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgcmVxdWlyZWQgZmllbGRzOiAke21pc3NpbmdGaWVsZHMuam9pbignLCAnKX1gKVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygnQWxsIHJlcXVpcmVkIGZpZWxkcyBwcmVzZW50LCBpbnNlcnRpbmcgdG8gZGF0YWJhc2UuLi4nKVxyXG4gICAgICBcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnc3RhbmRfYmFja19yZWNvcmRzJylcclxuICAgICAgICAuaW5zZXJ0KFtkYXRhVG9JbnNlcnRdKVxyXG4gICAgICAgIC5zZWxlY3QoKVxyXG4gICAgICBcclxuICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFN1cGFiYXNlIGVycm9yIGFkZGluZyBzdGFuZCBiYWNrIHJlY29yZDonLCBlcnJvcilcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZGV0YWlsczonLCBKU09OLnN0cmluZ2lmeShlcnJvciwgbnVsbCwgMikpXHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGNvZGU6JywgZXJyb3IuY29kZSlcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgbWVzc2FnZTonLCBlcnJvci5tZXNzYWdlKVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBoaW50OicsIGVycm9yLmhpbnQpXHJcbiAgICAgICAgdGhyb3cgZXJyb3JcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coJ+KchSBTdGFuZCBiYWNrIHJlY29yZCBhZGRlZCBzdWNjZXNzZnVsbHk6JywgZGF0YSlcclxuICAgICAgYXdhaXQgbG9hZERhdGEoKSAvLyBSZWxvYWQgYWxsIGRhdGFcclxuICAgICAgcmV0dXJuIGRhdGFcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgYWRkaW5nIHN0YW5kIGJhY2sgcmVjb3JkOicsIGVycilcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGRldGFpbHM6JywgSlNPTi5zdHJpbmdpZnkoZXJyLCBudWxsLCAyKSlcclxuICAgICAgdGhyb3cgZXJyXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCB1cGRhdGVTdGFuZEJhY2tSZWNvcmQgPSBhc3luYyAocmVjb3JkSWQ6IHN0cmluZywgdXBkYXRlczogYW55KSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnVXBkYXRpbmcgc3RhbmQgYmFjayByZWNvcmQgaW4gU3VwYWJhc2U6JywgcmVjb3JkSWQsIHVwZGF0ZXMpXHJcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ3N0YW5kX2JhY2tfcmVjb3JkcycpXHJcbiAgICAgICAgLnVwZGF0ZSh1cGRhdGVzKVxyXG4gICAgICAgIC5lcSgnaWQnLCByZWNvcmRJZClcclxuICAgICAgICAuc2VsZWN0KClcclxuICAgICAgXHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N1cGFiYXNlIGVycm9yIHVwZGF0aW5nIHN0YW5kIGJhY2sgcmVjb3JkOicsIGVycm9yKVxyXG4gICAgICAgIHRocm93IGVycm9yXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCdTdGFuZCBiYWNrIHJlY29yZCB1cGRhdGVkIHN1Y2Nlc3NmdWxseTonLCBkYXRhKVxyXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpIC8vIFJlbG9hZCBhbGwgZGF0YVxyXG4gICAgICByZXR1cm4gZGF0YVxyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHN0YW5kIGJhY2sgcmVjb3JkOicsIGVycilcclxuICAgICAgdGhyb3cgZXJyXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBhZGRMb2FuID0gYXN5bmMgKGxvYW5EYXRhOiBhbnkpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgbG9hbiB0byBTdXBhYmFzZTonLCBsb2FuRGF0YSlcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnbG9hbnMnKVxyXG4gICAgICAgIC5pbnNlcnQoW2xvYW5EYXRhXSlcclxuICAgICAgICAuc2VsZWN0KClcclxuICAgICAgXHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N1cGFiYXNlIGVycm9yIGFkZGluZyBsb2FuOicsIGVycm9yKVxyXG4gICAgICAgIHRocm93IGVycm9yXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCdMb2FuIGFkZGVkIHN1Y2Nlc3NmdWxseTonLCBkYXRhKVxyXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpIC8vIFJlbG9hZCBhbGwgZGF0YVxyXG4gICAgICByZXR1cm4gZGF0YVxyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBsb2FuOicsIGVycilcclxuICAgICAgdGhyb3cgZXJyXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBjb21wbGV0ZUxvYW4gPSBhc3luYyAobG9hbklkOiBzdHJpbmcsIG5vdGVzPzogc3RyaW5nKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnQ29tcGxldGluZyBsb2FuIGluIFN1cGFiYXNlOicsIGxvYW5JZClcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnbG9hbnMnKVxyXG4gICAgICAgIC51cGRhdGUoe1xyXG4gICAgICAgICAgc3RhdHVzOiAndm9sdG9vaWQnLFxyXG4gICAgICAgICAgY29tcGxldGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgICBub3Rlczogbm90ZXMgfHwgXCJcIlxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmVxKCdpZCcsIGxvYW5JZClcclxuICAgICAgICAuc2VsZWN0KClcclxuICAgICAgXHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N1cGFiYXNlIGVycm9yIGNvbXBsZXRpbmcgbG9hbjonLCBlcnJvcilcclxuICAgICAgICB0aHJvdyBlcnJvclxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygnTG9hbiBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5OicsIGRhdGEpXHJcbiAgICAgIGF3YWl0IGxvYWREYXRhKCkgLy8gUmVsb2FkIGFsbCBkYXRhXHJcbiAgICAgIHJldHVybiBkYXRhXHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY29tcGxldGluZyBsb2FuOicsIGVycilcclxuICAgICAgdGhyb3cgZXJyXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBtYWtlUGF5bWVudCA9IGFzeW5jIChsb2FuSWQ6IHN0cmluZywgcGF5bWVudEFtb3VudDogbnVtYmVyLCBub3RlPzogc3RyaW5nKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnTWFraW5nIHBheW1lbnQgZm9yIGxvYW46JywgbG9hbklkLCBwYXltZW50QW1vdW50KVxyXG4gICAgICBcclxuICAgICAgLy8gRmlyc3QsIGdldCB0aGUgY3VycmVudCBsb2FuXHJcbiAgICAgIGNvbnN0IHsgZGF0YTogbG9hbiwgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ2xvYW5zJylcclxuICAgICAgICAuc2VsZWN0KCcqJylcclxuICAgICAgICAuZXEoJ2lkJywgbG9hbklkKVxyXG4gICAgICAgIC5zaW5nbGUoKVxyXG4gICAgICBcclxuICAgICAgaWYgKGZldGNoRXJyb3IgfHwgIWxvYW4pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvYW4gbm90IGZvdW5kJylcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gQ2FsY3VsYXRlIG5ldyB2YWx1ZXNcclxuICAgICAgY29uc3QgbmV3UGFpZCA9IChsb2FuLmFtb3VudF9wYWlkIHx8IDApICsgcGF5bWVudEFtb3VudFxyXG4gICAgICBjb25zdCBuZXdSZW1haW5pbmcgPSBsb2FuLmFtb3VudCAtIG5ld1BhaWRcclxuICAgICAgY29uc3QgbmV3U3RhdHVzID0gbmV3UmVtYWluaW5nIDw9IDAgPyAndm9sdG9vaWQnIDogJ29wZW4nXHJcbiAgICAgIFxyXG4gICAgICAvLyBDcmVhdGUgcGF5bWVudCBoaXN0b3J5IGVudHJ5XHJcbiAgICAgIGNvbnN0IHBheW1lbnRFbnRyeSA9IHtcclxuICAgICAgICBkYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgYW1vdW50OiBwYXltZW50QW1vdW50LFxyXG4gICAgICAgIG5vdGU6IG5vdGUgfHwgJ0JldGFsaW5nIGFmZ2V0ZWtlbmQnLFxyXG4gICAgICAgIHBhaWRCeTogJ1VzZXInXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIFVwZGF0ZSBsb2FuXHJcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ2xvYW5zJylcclxuICAgICAgICAudXBkYXRlKHtcclxuICAgICAgICAgIGFtb3VudF9wYWlkOiBuZXdQYWlkLFxyXG4gICAgICAgICAgYW1vdW50X3JlbWFpbmluZzogbmV3UmVtYWluaW5nLFxyXG4gICAgICAgICAgc3RhdHVzOiBuZXdTdGF0dXMsXHJcbiAgICAgICAgICBjb21wbGV0ZWRfYXQ6IG5ld1N0YXR1cyA9PT0gJ3ZvbHRvb2lkJyA/IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSA6IG51bGwsXHJcbiAgICAgICAgICBwYXltZW50X2hpc3Rvcnk6IFsuLi4obG9hbi5wYXltZW50X2hpc3RvcnkgfHwgW10pLCBwYXltZW50RW50cnldXHJcbiAgICAgICAgfSlcclxuICAgICAgICAuZXEoJ2lkJywgbG9hbklkKVxyXG4gICAgICAgIC5zZWxlY3QoKVxyXG4gICAgICBcclxuICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignU3VwYWJhc2UgZXJyb3IgbWFraW5nIHBheW1lbnQ6JywgZXJyb3IpXHJcbiAgICAgICAgdGhyb3cgZXJyb3JcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coJ1BheW1lbnQgbWFkZSBzdWNjZXNzZnVsbHk6JywgZGF0YSlcclxuICAgICAgYXdhaXQgbG9hZERhdGEoKSAvLyBSZWxvYWQgYWxsIGRhdGFcclxuICAgICAgcmV0dXJuIGRhdGFcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBtYWtpbmcgcGF5bWVudDonLCBlcnIpXHJcbiAgICAgIHRocm93IGVyclxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gVHJpcCBmdW5jdGlvbnNcclxuICBjb25zdCBhZGRUcmlwID0gYXN5bmMgKHRyaXBEYXRhOiBhbnkpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgdHJpcDonLCB0cmlwRGF0YSlcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ3RyaXBzJylcclxuICAgICAgICAuaW5zZXJ0KFt0cmlwRGF0YV0pXHJcbiAgICAgICAgLnNlbGVjdCgpXHJcbiAgICAgIFxyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgdHJpcDonLCBlcnJvcilcclxuICAgICAgICB0aHJvdyBlcnJvclxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygnVHJpcCBhZGRlZCBzdWNjZXNzZnVsbHk6JywgZGF0YSlcclxuICAgICAgYXdhaXQgbG9hZERhdGEoKSAvLyBSZWxvYWQgYWxsIGRhdGFcclxuICAgICAgcmV0dXJuIGRhdGFcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgdHJpcDonLCBlcnIpXHJcbiAgICAgIHRocm93IGVyclxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3QgdXBkYXRlVHJpcCA9IGFzeW5jICh0cmlwSWQ6IHN0cmluZywgdXBkYXRlczogYW55KSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnVXBkYXRpbmcgdHJpcDonLCB0cmlwSWQsIHVwZGF0ZXMpXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCd0cmlwcycpXHJcbiAgICAgICAgLnVwZGF0ZSh7IC4uLnVwZGF0ZXMsIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9KVxyXG4gICAgICAgIC5lcSgnaWQnLCB0cmlwSWQpXHJcbiAgICAgICAgLnNlbGVjdCgpXHJcbiAgICAgICAgLnNpbmdsZSgpXHJcbiAgICAgIFxyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyB0cmlwOicsIGVycm9yKVxyXG4gICAgICAgIHRocm93IGVycm9yXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCdUcmlwIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5OicsIGRhdGEpXHJcbiAgICAgIFxyXG4gICAgICAvLyBJZiB0cmlwIGlzIGNvbXBsZXRlZCwgYXV0by11cGRhdGUgdmFzdGUgZGllbnN0IHJlY29yZHNcclxuICAgICAgaWYgKHVwZGF0ZXMuc3RhdHVzID09PSAndm9sdG9vaWQnICYmIGRhdGEuYWZsb3NzZXJfaWQpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+agCBUcmlwIGNvbXBsZXRlZCAtIGF1dG8tdXBkYXRpbmcgdmFzdGUgZGllbnN0IHJlY29yZHMnKVxyXG4gICAgICAgIGF3YWl0IGF1dG9VcGRhdGVWYXN0ZURpZW5zdEZyb21UcmlwKGRhdGEpXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGF3YWl0IGxvYWREYXRhKCkgLy8gUmVsb2FkIGFsbCBkYXRhXHJcbiAgICAgIHJldHVybiBkYXRhXHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgdHJpcDonLCBlcnIpXHJcbiAgICAgIHRocm93IGVyclxyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIC8vIFZhc3RlIGRpZW5zdCBmdW5jdGlvbnNcclxuICBjb25zdCBhZGRWYXN0ZURpZW5zdFJlY29yZCA9IGFzeW5jIChyZWNvcmREYXRhOiBhbnkpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgdmFzdGUgZGllbnN0IHJlY29yZDonLCByZWNvcmREYXRhKVxyXG4gICAgICBjb25zb2xlLmxvZygnUmVjb3JkIGRhdGEgZGV0YWlsczonLCBKU09OLnN0cmluZ2lmeShyZWNvcmREYXRhLCBudWxsLCAyKSlcclxuICAgICAgXHJcbiAgICAgIC8vIFZhbGlkYXRlIHJlcXVpcmVkIGZpZWxkc1xyXG4gICAgICBjb25zdCByZXF1aXJlZEZpZWxkcyA9IFsnYWZsb3NzZXJfaWQnLCAneWVhcicsICdtb250aCcsICdyZXF1aXJlZF9kYXlzJywgJ2FjdHVhbF9kYXlzJywgJ2JhbGFuY2VfZGF5cyddXHJcbiAgICAgIGNvbnN0IG1pc3NpbmdGaWVsZHMgPSByZXF1aXJlZEZpZWxkcy5maWx0ZXIoZmllbGQgPT4gcmVjb3JkRGF0YVtmaWVsZF0gPT09IHVuZGVmaW5lZCB8fCByZWNvcmREYXRhW2ZpZWxkXSA9PT0gbnVsbClcclxuICAgICAgXHJcbiAgICAgIGlmIChtaXNzaW5nRmllbGRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgTWlzc2luZyByZXF1aXJlZCBmaWVsZHM6ICR7bWlzc2luZ0ZpZWxkcy5qb2luKCcsICcpfWApXHJcbiAgICAgICAgY29uc29sZS5lcnJvcignVmFsaWRhdGlvbiBlcnJvcjonLCBlcnJvcilcclxuICAgICAgICB0aHJvdyBlcnJvclxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBDaGVjayBpZiByZWNvcmQgYWxyZWFkeSBleGlzdHMgZm9yIHRoaXMgYWZsb3NzZXIveWVhci9tb250aCBjb21iaW5hdGlvblxyXG4gICAgICBjb25zdCB7IGRhdGE6IGV4aXN0aW5nUmVjb3JkLCBlcnJvcjogY2hlY2tFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgndmFzdGVfZGllbnN0X3JlY29yZHMnKVxyXG4gICAgICAgIC5zZWxlY3QoJ2lkJylcclxuICAgICAgICAuZXEoJ2FmbG9zc2VyX2lkJywgcmVjb3JkRGF0YS5hZmxvc3Nlcl9pZClcclxuICAgICAgICAuZXEoJ3llYXInLCByZWNvcmREYXRhLnllYXIpXHJcbiAgICAgICAgLmVxKCdtb250aCcsIHJlY29yZERhdGEubW9udGgpXHJcbiAgICAgICAgLnNpbmdsZSgpXHJcbiAgICAgIFxyXG4gICAgICBpZiAoZXhpc3RpbmdSZWNvcmQpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnUmVjb3JkIGFscmVhZHkgZXhpc3RzIGZvciB0aGlzIGFmbG9zc2VyL3llYXIvbW9udGggY29tYmluYXRpb24sIHVwZGF0aW5nIGluc3RlYWQnKVxyXG4gICAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyByZWNvcmQgaW5zdGVhZCBvZiBjcmVhdGluZyBuZXcgb25lXHJcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgIC5mcm9tKCd2YXN0ZV9kaWVuc3RfcmVjb3JkcycpXHJcbiAgICAgICAgICAudXBkYXRlKHtcclxuICAgICAgICAgICAgcmVxdWlyZWRfZGF5czogcmVjb3JkRGF0YS5yZXF1aXJlZF9kYXlzLFxyXG4gICAgICAgICAgICBhY3R1YWxfZGF5czogcmVjb3JkRGF0YS5hY3R1YWxfZGF5cyxcclxuICAgICAgICAgICAgYmFsYW5jZV9kYXlzOiByZWNvcmREYXRhLmJhbGFuY2VfZGF5cyxcclxuICAgICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLmVxKCdpZCcsIGV4aXN0aW5nUmVjb3JkLmlkKVxyXG4gICAgICAgICAgLnNlbGVjdCgpXHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBleGlzdGluZyB2YXN0ZSBkaWVuc3QgcmVjb3JkOicsIGVycm9yKVxyXG4gICAgICAgICAgdGhyb3cgZXJyb3JcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc29sZS5sb2coJ1Zhc3RlIGRpZW5zdCByZWNvcmQgdXBkYXRlZCBzdWNjZXNzZnVsbHk6JywgZGF0YSlcclxuICAgICAgICBhd2FpdCBsb2FkRGF0YSgpIC8vIFJlbG9hZCBhbGwgZGF0YVxyXG4gICAgICAgIHJldHVybiBkYXRhXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIElmIG5vIGV4aXN0aW5nIHJlY29yZCwgY3JlYXRlIG5ldyBvbmVcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgndmFzdGVfZGllbnN0X3JlY29yZHMnKVxyXG4gICAgICAgIC5pbnNlcnQoW3JlY29yZERhdGFdKVxyXG4gICAgICAgIC5zZWxlY3QoKVxyXG4gICAgICBcclxuICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignU3VwYWJhc2UgZXJyb3IgYWRkaW5nIHZhc3RlIGRpZW5zdCByZWNvcmQ6JywgZXJyb3IpXHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGV0YWlsczonLCBKU09OLnN0cmluZ2lmeShlcnJvciwgbnVsbCwgMikpXHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY29kZTonLCBlcnJvci5jb2RlKVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG1lc3NhZ2U6JywgZXJyb3IubWVzc2FnZSlcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBoaW50OicsIGVycm9yLmhpbnQpXHJcbiAgICAgICAgdGhyb3cgZXJyb3JcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coJ1Zhc3RlIGRpZW5zdCByZWNvcmQgYWRkZWQgc3VjY2Vzc2Z1bGx5OicsIGRhdGEpXHJcbiAgICAgIGF3YWl0IGxvYWREYXRhKCkgLy8gUmVsb2FkIGFsbCBkYXRhXHJcbiAgICAgIHJldHVybiBkYXRhXHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIHZhc3RlIGRpZW5zdCByZWNvcmQ6JywgZXJyKVxyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZXRhaWxzOicsIEpTT04uc3RyaW5naWZ5KGVyciwgbnVsbCwgMikpXHJcbiAgICAgIHRocm93IGVyclxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3QgdXBkYXRlVmFzdGVEaWVuc3RSZWNvcmQgPSBhc3luYyAocmVjb3JkSWQ6IHN0cmluZywgdXBkYXRlczogYW55KSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnVXBkYXRpbmcgdmFzdGUgZGllbnN0IHJlY29yZDonLCByZWNvcmRJZCwgdXBkYXRlcylcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ3Zhc3RlX2RpZW5zdF9yZWNvcmRzJylcclxuICAgICAgICAudXBkYXRlKHsgLi4udXBkYXRlcywgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH0pXHJcbiAgICAgICAgLmVxKCdpZCcsIHJlY29yZElkKVxyXG4gICAgICAgIC5zZWxlY3QoKVxyXG4gICAgICAgIC5zaW5nbGUoKVxyXG4gICAgICBcclxuICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgdmFzdGUgZGllbnN0IHJlY29yZDonLCBlcnJvcilcclxuICAgICAgICB0aHJvdyBlcnJvclxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygnVmFzdGUgZGllbnN0IHJlY29yZCB1cGRhdGVkIHN1Y2Nlc3NmdWxseTonLCBkYXRhKVxyXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpIC8vIFJlbG9hZCBhbGwgZGF0YVxyXG4gICAgICByZXR1cm4gZGF0YVxyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHZhc3RlIGRpZW5zdCByZWNvcmQ6JywgZXJyKVxyXG4gICAgICB0aHJvdyBlcnJcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IGRlbGV0ZVZhc3RlRGllbnN0UmVjb3JkID0gYXN5bmMgKHJlY29yZElkOiBzdHJpbmcpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdEZWxldGluZyB2YXN0ZSBkaWVuc3QgcmVjb3JkOicsIHJlY29yZElkKVxyXG4gICAgICBcclxuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgndmFzdGVfZGllbnN0X3JlY29yZHMnKVxyXG4gICAgICAgIC5kZWxldGUoKVxyXG4gICAgICAgIC5lcSgnaWQnLCByZWNvcmRJZClcclxuICAgICAgXHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIHZhc3RlIGRpZW5zdCByZWNvcmQ6JywgZXJyb3IpXHJcbiAgICAgICAgdGhyb3cgZXJyb3JcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coJ1Zhc3RlIGRpZW5zdCByZWNvcmQgZGVsZXRlZCBzdWNjZXNzZnVsbHknKVxyXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpIC8vIFJlbG9hZCBhbGwgZGF0YVxyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIHZhc3RlIGRpZW5zdCByZWNvcmQ6JywgZXJyKVxyXG4gICAgICB0aHJvdyBlcnJcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIERlbGV0ZSB0cmlwIHBlcm1hbmVudGx5XHJcbiAgY29uc3QgZGVsZXRlVHJpcCA9IGFzeW5jICh0cmlwSWQ6IHN0cmluZykgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgndHJpcHMnKVxyXG4gICAgICAgIC5kZWxldGUoKVxyXG4gICAgICAgIC5lcSgnaWQnLCB0cmlwSWQpXHJcbiAgICAgIFxyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBlcnJvciBkZWxldGluZyB0cmlwOicsIGVycm9yKVxyXG4gICAgICAgIHRocm93IGVycm9yXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCdUcmlwIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5JylcclxuICAgICAgYXdhaXQgbG9hZERhdGEoKSAvLyBSZWxvYWQgYWxsIGRhdGFcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyB0cmlwOicsIGVycilcclxuICAgICAgdGhyb3cgZXJyXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBEZWxldGUgYWZsb3NzZXIgcGVybWFuZW50bHlcclxuICBjb25zdCBkZWxldGVBZmxvc3NlciA9IGFzeW5jIChhZmxvc3NlcklkOiBzdHJpbmcpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEZpcnN0IGRlbGV0ZSBhbGwgcmVsYXRlZCByZWNvcmRzXHJcbiAgICAgIGF3YWl0IHN1cGFiYXNlLmZyb20oJ3Zhc3RlX2RpZW5zdF9yZWNvcmRzJykuZGVsZXRlKCkuZXEoJ2FmbG9zc2VyX2lkJywgYWZsb3NzZXJJZClcclxuICAgICAgYXdhaXQgc3VwYWJhc2UuZnJvbSgndHJpcHMnKS5kZWxldGUoKS5lcSgnYWZsb3NzZXJfaWQnLCBhZmxvc3NlcklkKVxyXG4gICAgICBcclxuICAgICAgLy8gVGhlbiBkZWxldGUgdGhlIGFmbG9zc2VyXHJcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ2NyZXcnKVxyXG4gICAgICAgIC5kZWxldGUoKVxyXG4gICAgICAgIC5lcSgnaWQnLCBhZmxvc3NlcklkKVxyXG4gICAgICBcclxuICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignU3VwYWJhc2UgZXJyb3IgZGVsZXRpbmcgYWZsb3NzZXI6JywgZXJyb3IpXHJcbiAgICAgICAgdGhyb3cgZXJyb3JcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coJ0FmbG9zc2VyIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5JylcclxuICAgICAgYXdhaXQgbG9hZERhdGEoKSAvLyBSZWxvYWQgYWxsIGRhdGFcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBhZmxvc3NlcjonLCBlcnIpXHJcbiAgICAgIHRocm93IGVyclxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gTm90ZXMgZnVuY3Rpb25zXHJcbiAgY29uc3QgYWRkTm90ZVRvQ3JldyA9IGFzeW5jIChjcmV3SWQ6IHN0cmluZywgbm90ZTogc3RyaW5nKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBHZXQgY3VycmVudCBjcmV3IG1lbWJlciBkYXRhXHJcbiAgICAgIGNvbnN0IHsgZGF0YTogY3Jld0RhdGEsIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdjcmV3JylcclxuICAgICAgICAuc2VsZWN0KCdhY3RpdmVfbm90ZXMnKVxyXG4gICAgICAgIC5lcSgnaWQnLCBjcmV3SWQpXHJcbiAgICAgICAgLnNpbmdsZSgpO1xyXG5cclxuICAgICAgaWYgKGZldGNoRXJyb3IpIHRocm93IGZldGNoRXJyb3I7XHJcblxyXG4gICAgICAvLyBQYXJzZSBleGlzdGluZyBub3RlcyBvciBpbml0aWFsaXplIGVtcHR5IGFycmF5XHJcbiAgICAgIGNvbnN0IGN1cnJlbnROb3RlcyA9IGNyZXdEYXRhPy5hY3RpdmVfbm90ZXMgfHwgW107XHJcbiAgICAgIFxyXG4gICAgICAvLyBBZGQgbmV3IG5vdGUgd2l0aCB0aW1lc3RhbXBcclxuICAgICAgY29uc3QgbmV3Tm90ZSA9IHtcclxuICAgICAgICBpZDogRGF0ZS5ub3coKS50b1N0cmluZygpLCAvLyBTaW1wbGUgSUQgZ2VuZXJhdGlvblxyXG4gICAgICAgIGNvbnRlbnQ6IG5vdGUsXHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgY3JlYXRlZEJ5OiAndXNlcicgLy8gWW91IGNvdWxkIGdldCB0aGlzIGZyb20gYXV0aCBjb250ZXh0XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCB1cGRhdGVkTm90ZXMgPSBbLi4uY3VycmVudE5vdGVzLCBuZXdOb3RlXTtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBjcmV3IG1lbWJlciB3aXRoIG5ldyBub3Rlc1xyXG4gICAgICBjb25zdCB7IGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnY3JldycpXHJcbiAgICAgICAgLnVwZGF0ZSh7IGFjdGl2ZV9ub3RlczogdXBkYXRlZE5vdGVzIH0pXHJcbiAgICAgICAgLmVxKCdpZCcsIGNyZXdJZCk7XHJcblxyXG4gICAgICBpZiAodXBkYXRlRXJyb3IpIHRocm93IHVwZGF0ZUVycm9yO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coJ05vdGUgYWRkZWQgc3VjY2Vzc2Z1bGx5JylcclxuICAgICAgYXdhaXQgbG9hZERhdGEoKTsgLy8gUmVsb2FkIGRhdGFcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBub3RlOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgcmVtb3ZlTm90ZUZyb21DcmV3ID0gYXN5bmMgKGNyZXdJZDogc3RyaW5nLCBub3RlSWQ6IHN0cmluZykgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gR2V0IGN1cnJlbnQgY3JldyBtZW1iZXIgZGF0YVxyXG4gICAgICBjb25zdCB7IGRhdGE6IGNyZXdEYXRhLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnY3JldycpXHJcbiAgICAgICAgLnNlbGVjdCgnYWN0aXZlX25vdGVzLCBhcmNoaXZlZF9ub3RlcycpXHJcbiAgICAgICAgLmVxKCdpZCcsIGNyZXdJZClcclxuICAgICAgICAuc2luZ2xlKCk7XHJcblxyXG4gICAgICBpZiAoZmV0Y2hFcnJvcikgdGhyb3cgZmV0Y2hFcnJvcjtcclxuXHJcbiAgICAgIGNvbnN0IGN1cnJlbnRBY3RpdmVOb3RlcyA9IGNyZXdEYXRhPy5hY3RpdmVfbm90ZXMgfHwgW107XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRBcmNoaXZlZE5vdGVzID0gY3Jld0RhdGE/LmFyY2hpdmVkX25vdGVzIHx8IFtdO1xyXG5cclxuICAgICAgLy8gRmluZCB0aGUgbm90ZSB0byByZW1vdmVcclxuICAgICAgY29uc3Qgbm90ZVRvQXJjaGl2ZSA9IGN1cnJlbnRBY3RpdmVOb3Rlcy5maW5kKChub3RlOiBhbnkpID0+IG5vdGUuaWQgPT09IG5vdGVJZCk7XHJcbiAgICAgIGlmICghbm90ZVRvQXJjaGl2ZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90ZSBub3QgZm91bmQnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIGZyb20gYWN0aXZlIG5vdGVzXHJcbiAgICAgIGNvbnN0IHVwZGF0ZWRBY3RpdmVOb3RlcyA9IGN1cnJlbnRBY3RpdmVOb3Rlcy5maWx0ZXIoKG5vdGU6IGFueSkgPT4gbm90ZS5pZCAhPT0gbm90ZUlkKTtcclxuXHJcbiAgICAgIC8vIEFkZCB0byBhcmNoaXZlZCBub3RlcyB3aXRoIGFyY2hpdmUgdGltZXN0YW1wXHJcbiAgICAgIGNvbnN0IGFyY2hpdmVkTm90ZSA9IHtcclxuICAgICAgICAuLi5ub3RlVG9BcmNoaXZlLFxyXG4gICAgICAgIGFyY2hpdmVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgICB9O1xyXG4gICAgICBjb25zdCB1cGRhdGVkQXJjaGl2ZWROb3RlcyA9IFsuLi5jdXJyZW50QXJjaGl2ZWROb3RlcywgYXJjaGl2ZWROb3RlXTtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBjcmV3IG1lbWJlclxyXG4gICAgICBjb25zdCB7IGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnY3JldycpXHJcbiAgICAgICAgLnVwZGF0ZSh7IFxyXG4gICAgICAgICAgYWN0aXZlX25vdGVzOiB1cGRhdGVkQWN0aXZlTm90ZXMsXHJcbiAgICAgICAgICBhcmNoaXZlZF9ub3RlczogdXBkYXRlZEFyY2hpdmVkTm90ZXNcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5lcSgnaWQnLCBjcmV3SWQpO1xyXG5cclxuICAgICAgaWYgKHVwZGF0ZUVycm9yKSB0aHJvdyB1cGRhdGVFcnJvcjtcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCdOb3RlIGFyY2hpdmVkIHN1Y2Nlc3NmdWxseScpXHJcbiAgICAgIGF3YWl0IGxvYWREYXRhKCk7IC8vIFJlbG9hZCBkYXRhXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyBub3RlOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gQWRkIHRhc2tcclxuICBjb25zdCBhZGRUYXNrID0gYXN5bmMgKHRhc2tEYXRhOiBhbnkpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OdIEFkZGluZyB0YXNrIHdpdGggZGF0YTonLCBKU09OLnN0cmluZ2lmeSh0YXNrRGF0YSwgbnVsbCwgMikpXHJcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ3Rhc2tzJylcclxuICAgICAgICAuaW5zZXJ0KFt0YXNrRGF0YV0pXHJcbiAgICAgICAgLnNlbGVjdCgpXHJcbiAgICAgICAgLnNpbmdsZSgpXHJcbiAgICAgIFxyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgU3VwYWJhc2UgZXJyb3IgYWRkaW5nIHRhc2s6JywgZXJyb3IpXHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGNvZGU6JywgZXJyb3IuY29kZSlcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgbWVzc2FnZTonLCBlcnJvci5tZXNzYWdlKVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBkZXRhaWxzOicsIGVycm9yLmRldGFpbHMpXHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGhpbnQ6JywgZXJyb3IuaGludClcclxuICAgICAgICB0aHJvdyBlcnJvclxyXG4gICAgICB9XHJcbiAgICAgIGF3YWl0IGxvYWREYXRhKClcclxuICAgICAgcmV0dXJuIGRhdGFcclxuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyB0YXNrOicsIGVycilcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGV0YWlsczonLCBKU09OLnN0cmluZ2lmeShlcnIsIG51bGwsIDIpKVxyXG4gICAgICB0aHJvdyBlcnJcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFVwZGF0ZSB0YXNrXHJcbiAgY29uc3QgdXBkYXRlVGFzayA9IGFzeW5jICh0YXNrSWQ6IHN0cmluZywgdXBkYXRlczogYW55KSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCd0YXNrcycpXHJcbiAgICAgICAgLnVwZGF0ZSh1cGRhdGVzKVxyXG4gICAgICAgIC5lcSgnaWQnLCB0YXNrSWQpXHJcbiAgICAgIFxyXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXHJcbiAgICAgIGF3YWl0IGxvYWREYXRhKClcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyB0YXNrOicsIGVycilcclxuICAgICAgdGhyb3cgZXJyXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBEZWxldGUgdGFza1xyXG4gIGNvbnN0IGRlbGV0ZVRhc2sgPSBhc3luYyAodGFza0lkOiBzdHJpbmcpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ3Rhc2tzJylcclxuICAgICAgICAuZGVsZXRlKClcclxuICAgICAgICAuZXEoJ2lkJywgdGFza0lkKVxyXG4gICAgICBcclxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpXHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgdGFzazonLCBlcnIpXHJcbiAgICAgIHRocm93IGVyclxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ29tcGxldGUgdGFza1xyXG4gIGNvbnN0IGNvbXBsZXRlVGFzayA9IGFzeW5jICh0YXNrSWQ6IHN0cmluZykgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgndGFza3MnKVxyXG4gICAgICAgIC51cGRhdGUoeyBcclxuICAgICAgICAgIGNvbXBsZXRlZDogdHJ1ZSxcclxuICAgICAgICAgIGNvbXBsZXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgICAgfSlcclxuICAgICAgICAuZXEoJ2lkJywgdGFza0lkKVxyXG4gICAgICBcclxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpXHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY29tcGxldGluZyB0YXNrOicsIGVycilcclxuICAgICAgdGhyb3cgZXJyXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgc2hpcHMsXHJcbiAgICBjcmV3LFxyXG4gICAgc2lja0xlYXZlLFxyXG4gICAgc3RhbmRCYWNrUmVjb3JkcyxcclxuICAgIGxvYW5zLFxyXG4gICAgdHJpcHMsXHJcbiAgICB0YXNrcyxcclxuICAgIGxvYWRpbmcsXHJcbiAgICBlcnJvcixcclxuICAgIGxvYWREYXRhLFxyXG4gICAgY3Jld0NvbG9yVGFncyxcclxuICAgIGFzeW5jIHNldENyZXdDb2xvclRhZyhjcmV3SWQ6IHN0cmluZywgY29sb3I6IHN0cmluZyB8IG51bGwpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAoIWNyZXdJZCkgcmV0dXJuXHJcbiAgICAgICAgaWYgKGNvbG9yKSB7XHJcbiAgICAgICAgICAvLyB1cHNlcnQgY29sb3JcclxuICAgICAgICAgIGNvbnN0IHsgZXJyb3I6IHVwc2VydEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgICAgICAuZnJvbSgnY3Jld19jb2xvcl90YWdzJylcclxuICAgICAgICAgICAgLnVwc2VydCh7IGNyZXdfaWQ6IGNyZXdJZCwgY29sb3IgfSwgeyBvbkNvbmZsaWN0OiAnY3Jld19pZCcgfSlcclxuICAgICAgICAgIGlmICh1cHNlcnRFcnJvcikgdGhyb3cgdXBzZXJ0RXJyb3JcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gZGVsZXRlIGNvbG9yXHJcbiAgICAgICAgICBjb25zdCB7IGVycm9yOiBkZWxFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgICAgLmZyb20oJ2NyZXdfY29sb3JfdGFncycpXHJcbiAgICAgICAgICAgIC5kZWxldGUoKVxyXG4gICAgICAgICAgICAuZXEoJ2NyZXdfaWQnLCBjcmV3SWQpXHJcbiAgICAgICAgICBpZiAoZGVsRXJyb3IpIHRocm93IGRlbEVycm9yXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHVwZGF0ZSBsb2NhbCBzdGF0ZVxyXG4gICAgICAgIHNldENyZXdDb2xvclRhZ3MoKHByZXYpID0+IHtcclxuICAgICAgICAgIGNvbnN0IG5leHQgPSB7IC4uLnByZXYgfVxyXG4gICAgICAgICAgaWYgKGNvbG9yKSBuZXh0W2NyZXdJZF0gPSBjb2xvclxyXG4gICAgICAgICAgZWxzZSBkZWxldGUgbmV4dFtjcmV3SWRdXHJcbiAgICAgICAgICByZXR1cm4gbmV4dFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zdCBlcnI6IGFueSA9IGVcclxuICAgICAgICBjb25zdCBtc2cgPSBlcnI/Lm1lc3NhZ2UgfHwgKHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnID8gZXJyIDogSlNPTi5zdHJpbmdpZnkoZXJyKSlcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZXR0aW5nIGNyZXcgY29sb3IgdGFnOicsIG1zZylcclxuICAgICAgICAvLyBJZiB0YWJsZSBtaXNzaW5nLCBzdXJmYWNlIGEgY2xlYXIgaGludCBvbmNlXHJcbiAgICAgICAgaWYgKG1zZz8uaW5jbHVkZXMoJ3JlbGF0aW9uJykgJiYgbXNnPy5pbmNsdWRlcygnY3Jld19jb2xvcl90YWdzJykpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybignSGludDogY3JlYXRlIHRhYmxlIGNyZXdfY29sb3JfdGFncyAoY3Jld19pZCB1dWlkIHByaW1hcnkga2V5IHJlZmVyZW5jZXMgY3JldyhpZCksIGNvbG9yIHRleHQgbm90IG51bGwpJylcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgZVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgYWRkQ3JldyxcclxuICAgIHVwZGF0ZUNyZXcsXHJcbiAgICBkZWxldGVDcmV3LFxyXG4gICAgYWRkU2hpcCxcclxuICAgIHVwZGF0ZVNoaXAsXHJcbiAgICBkZWxldGVTaGlwLFxyXG4gICAgYWRkU2lja0xlYXZlLFxyXG4gICAgdXBkYXRlU2lja0xlYXZlLFxyXG4gICAgYWRkU3RhbmRCYWNrUmVjb3JkLFxyXG4gICAgdXBkYXRlU3RhbmRCYWNrUmVjb3JkLFxyXG4gICAgYWRkTG9hbixcclxuICAgIGNvbXBsZXRlTG9hbixcclxuICAgIG1ha2VQYXltZW50LFxyXG4gICAgYWRkVHJpcCxcclxuICAgIHVwZGF0ZVRyaXAsXHJcbiAgICBkZWxldGVUcmlwLFxyXG4gICAgZGVsZXRlQWZsb3NzZXIsXHJcbiAgICB2YXN0ZURpZW5zdFJlY29yZHMsXHJcbiAgICBhZGRWYXN0ZURpZW5zdFJlY29yZCxcclxuICAgIHVwZGF0ZVZhc3RlRGllbnN0UmVjb3JkLFxyXG4gICAgZGVsZXRlVmFzdGVEaWVuc3RSZWNvcmQsXHJcbiAgICBhZGROb3RlVG9DcmV3LFxyXG4gICAgcmVtb3ZlTm90ZUZyb21DcmV3LFxyXG4gICAgYWRkVGFzayxcclxuICAgIHVwZGF0ZVRhc2ssXHJcbiAgICBkZWxldGVUYXNrLFxyXG4gICAgY29tcGxldGVUYXNrXHJcbiAgfVxyXG59IFxyXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJzdXBhYmFzZSIsImNhbGN1bGF0ZVdvcmtEYXlzVmFzdGVEaWVuc3QiLCJzdGFydERhdGUiLCJzdGFydFRpbWUiLCJlbmREYXRlIiwiZW5kVGltZSIsInBhcnNlRGF0ZSIsImRhdGVTdHIiLCJjb25zb2xlIiwiZXJyb3IiLCJEYXRlIiwiaW5jbHVkZXMiLCJ0ZXN0IiwiZGF0ZSIsImlzTmFOIiwiZ2V0VGltZSIsInBhcnRzIiwic3BsaXQiLCJsZW5ndGgiLCJkYXkiLCJwYXJzZUludCIsIm1vbnRoIiwieWVhciIsInBhcnNlVGltZSIsInRpbWVTdHIiLCJ0aW1lUGFydHMiLCJob3VycyIsIm1pbnV0ZXMiLCJzdGFydCIsImVuZCIsInN0YXJ0VGltZUhvdXJzIiwiZW5kVGltZUhvdXJzIiwic3RhcnREYXRlVGltZSIsInNldEhvdXJzIiwiTWF0aCIsImZsb29yIiwiZW5kRGF0ZVRpbWUiLCJ0aW1lRGlmZk1zIiwidG90YWxIb3VycyIsImRheUNyZWRpdHMiLCJjZWlsIiwiYXV0b0FjdGl2YXRlQ3Jld01lbWJlcnMiLCJjcmV3RGF0YSIsInRvZGF5IiwibWVtYmVyIiwic3RhdHVzIiwiZXhwZWN0ZWRfc3RhcnRfZGF0ZSIsInNoaXBfaWQiLCJyZWdpbWUiLCJsb2ciLCJmaXJzdF9uYW1lIiwibGFzdF9uYW1lIiwiZnJvbSIsInVwZGF0ZSIsIm9uX2JvYXJkX3NpbmNlIiwidGh1aXNfc2luZHMiLCJzdWJfc3RhdHVzIiwiZXEiLCJpZCIsImVyciIsImF1dG9Sb3RhdGVDcmV3TWVtYmVycyIsInJlZ2ltZVdlZWtzIiwicmVnaW1lRGF5cyIsIm9uQm9hcmREYXRlIiwiZGF5c1NpbmNlT25Cb2FyZCIsInRodWlzU2luZHMiLCJzZXREYXRlIiwiZ2V0RGF0ZSIsInRvSVNPU3RyaW5nIiwidGh1aXNEYXRlIiwiZGF5c1NpbmNlVGh1aXMiLCJvbkJvYXJkU2luY2UiLCJhdXRvTWFuYWdlVmFzdGVEaWVuc3RSZWNvcmRzIiwidmFzdGVEaWVuc3RSZWNvcmRzIiwidHJpcHNEYXRhIiwiY3VycmVudFllYXIiLCJnZXRGdWxsWWVhciIsImN1cnJlbnRNb250aCIsImdldE1vbnRoIiwidmFzdGVEaWVuc3RBZmxvc3NlcnMiLCJmaWx0ZXIiLCJ2YXN0ZV9kaWVuc3QiLCJhZmxvc3NlciIsImV4aXN0aW5nUmVjb3JkIiwiZmluZCIsInJlY29yZCIsImFmbG9zc2VyX2lkIiwibmV3UmVjb3JkIiwicmVxdWlyZWRfZGF5cyIsImFjdHVhbF9kYXlzIiwiYmFsYW5jZV9kYXlzIiwibm90ZXMiLCJkYXRhIiwiaW5zZXJ0Iiwic2VsZWN0Iiwic2luZ2xlIiwiY3VycmVudE1vbnRoVHJpcHMiLCJ0cmlwIiwiZWluZF9kYXR1bSIsInRvdGFsV29ya0RheXMiLCJ3b3JrRGF5cyIsImNhbGN1bGF0ZVdvcmtEYXlzIiwic3RhcnRfZGF0dW0iLCJzdGFydF90aWpkIiwiZWluZF90aWpkIiwicmVxdWlyZWREYXlzIiwiYmVnaW5zYWxkbyIsInN0YXJ0c2FsZG9Ob3RlIiwibm90ZSIsInRleHQiLCJtYXRjaCIsInN0YXJ0c2FsZG8iLCJwYXJzZUZsb2F0IiwiYmFsYW5jZURheXMiLCJjYXBwZWRBY3R1YWxEYXlzIiwibWluIiwiY2FwcGVkQmFsYW5jZURheXMiLCJtYXgiLCJKU09OIiwic3RyaW5naWZ5IiwiaXNvRGF0ZSIsInBhZFN0YXJ0IiwidGltZURpZmYiLCJkYXlzRGlmZiIsImF1dG9VcGRhdGVWYXN0ZURpZW5zdEZyb21UcmlwIiwiY29tcGxldGVkVHJpcCIsImFmbG9zc2VyRXJyb3IiLCJyZWNvcmRFcnJvciIsImNvZGUiLCJyZWNvcmRJZCIsImNyZWF0ZWRSZWNvcmQiLCJjcmVhdGVFcnJvciIsImFsbFRyaXBzIiwidHJpcHNFcnJvciIsIm5vdCIsInRyaXBFbmREYXRlIiwidHJpcFdvcmtEYXlzIiwidXBkYXRlRXJyb3IiLCJmb3JjZVJlY2FsY3VsYXRlQWxsVmFzdGVEaWVuc3RSZWNvcmRzIiwiYWxsUmVjb3JkcyIsImZldGNoRXJyb3IiLCJjcmV3IiwicmVzZXRBbGxWYXN0ZURpZW5zdFJlY29yZHMiLCJ1c2VTdXBhYmFzZURhdGEiLCJzaGlwcyIsInNldFNoaXBzIiwic2V0Q3JldyIsInNpY2tMZWF2ZSIsInNldFNpY2tMZWF2ZSIsInN0YW5kQmFja1JlY29yZHMiLCJzZXRTdGFuZEJhY2tSZWNvcmRzIiwibG9hbnMiLCJzZXRMb2FucyIsInRyaXBzIiwic2V0VHJpcHMiLCJzZXRWYXN0ZURpZW5zdFJlY29yZHMiLCJ0YXNrcyIsInNldFRhc2tzIiwibG9hZGluZyIsInNldExvYWRpbmciLCJzZXRFcnJvciIsImNyZXdDb2xvclRhZ3MiLCJzZXRDcmV3Q29sb3JUYWdzIiwibG9hZERhdGEiLCJzZXNzaW9uIiwiYXV0aCIsImdldFNlc3Npb24iLCJ3YXJuIiwidGVzdERhdGEiLCJ0ZXN0RXJyb3IiLCJsaW1pdCIsInNoaXBzRGF0YSIsInNoaXBzRXJyb3IiLCJvcmRlciIsImNyZXdFcnJvciIsInNpY2tMZWF2ZURhdGEiLCJzaWNrTGVhdmVFcnJvciIsImFzY2VuZGluZyIsInN0YW5kQmFja0RhdGEiLCJzdGFuZEJhY2tFcnJvciIsImxvYW5zRGF0YSIsImxvYW5zRXJyb3IiLCJ2YXN0ZURpZW5zdERhdGEiLCJ2YXN0ZURpZW5zdEVycm9yIiwidGFza3NEYXRhIiwidGFza3NFcnJvciIsImNvbG9yUm93cyIsImNvbG9yRXJyIiwibXNnIiwibWVzc2FnZSIsIlN0cmluZyIsIm1hcCIsInJvdyIsImNyZXdfaWQiLCJjb2xvciIsImUiLCJFcnJvciIsInNoaXBzU3Vic2NyaXB0aW9uIiwiY2hhbm5lbCIsIm9uIiwiZXZlbnQiLCJzY2hlbWEiLCJ0YWJsZSIsInN1YnNjcmliZSIsImNyZXdTdWJzY3JpcHRpb24iLCJzaWNrTGVhdmVTdWJzY3JpcHRpb24iLCJzdGFuZEJhY2tTdWJzY3JpcHRpb24iLCJsb2Fuc1N1YnNjcmlwdGlvbiIsInRyaXBzU3Vic2NyaXB0aW9uIiwidGFza3NTdWJzY3JpcHRpb24iLCJ1bnN1YnNjcmliZSIsImFkZENyZXciLCJyZXF1aXJlZEZpZWxkcyIsIm1pc3NpbmdGaWVsZHMiLCJmaWVsZCIsImpvaW4iLCJleGlzdGluZ0NyZXciLCJjaGVja0Vycm9yIiwibmF0aW9uYWxpdHkiLCJoaW50IiwidXBkYXRlQ3JldyIsInVwZGF0ZXMiLCJkZWxldGVDcmV3IiwiZGVsZXRlIiwiYWRkU2hpcCIsInNoaXBEYXRhIiwidXBkYXRlU2hpcCIsImRlbGV0ZVNoaXAiLCJhZGRTaWNrTGVhdmUiLCJ1bmRlZmluZWQiLCJ1cGRhdGVTaWNrTGVhdmUiLCJhZGRTdGFuZEJhY2tSZWNvcmQiLCJyZWNvcmREYXRhIiwidXVpZCIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJkYXRhV2l0aG91dElkIiwiZGF0YVRvSW5zZXJ0IiwiY3Jld19tZW1iZXJfaWQiLCJzdGFydF9kYXRlIiwiZW5kX2RhdGUiLCJkYXlzX2NvdW50IiwiZGVzY3JpcHRpb24iLCJzdGFuZF9iYWNrX2RheXNfcmVxdWlyZWQiLCJzdGFuZF9iYWNrX2RheXNfY29tcGxldGVkIiwic3RhbmRfYmFja19kYXlzX3JlbWFpbmluZyIsInN0YW5kX2JhY2tfc3RhdHVzIiwic3RhbmRfYmFja19oaXN0b3J5IiwicmVhc29uIiwidXBkYXRlU3RhbmRCYWNrUmVjb3JkIiwiYWRkTG9hbiIsImxvYW5EYXRhIiwiY29tcGxldGVMb2FuIiwibG9hbklkIiwiY29tcGxldGVkX2F0IiwibWFrZVBheW1lbnQiLCJwYXltZW50QW1vdW50IiwibG9hbiIsIm5ld1BhaWQiLCJhbW91bnRfcGFpZCIsIm5ld1JlbWFpbmluZyIsImFtb3VudCIsIm5ld1N0YXR1cyIsInBheW1lbnRFbnRyeSIsInBhaWRCeSIsImFtb3VudF9yZW1haW5pbmciLCJwYXltZW50X2hpc3RvcnkiLCJhZGRUcmlwIiwidHJpcERhdGEiLCJ1cGRhdGVUcmlwIiwidHJpcElkIiwidXBkYXRlZF9hdCIsImFkZFZhc3RlRGllbnN0UmVjb3JkIiwidXBkYXRlVmFzdGVEaWVuc3RSZWNvcmQiLCJkZWxldGVWYXN0ZURpZW5zdFJlY29yZCIsImRlbGV0ZVRyaXAiLCJkZWxldGVBZmxvc3NlciIsImFmbG9zc2VySWQiLCJhZGROb3RlVG9DcmV3IiwiY3Jld0lkIiwiY3VycmVudE5vdGVzIiwiYWN0aXZlX25vdGVzIiwibmV3Tm90ZSIsIm5vdyIsInRvU3RyaW5nIiwiY29udGVudCIsImNyZWF0ZWRBdCIsImNyZWF0ZWRCeSIsInVwZGF0ZWROb3RlcyIsInJlbW92ZU5vdGVGcm9tQ3JldyIsIm5vdGVJZCIsImN1cnJlbnRBY3RpdmVOb3RlcyIsImN1cnJlbnRBcmNoaXZlZE5vdGVzIiwiYXJjaGl2ZWRfbm90ZXMiLCJub3RlVG9BcmNoaXZlIiwidXBkYXRlZEFjdGl2ZU5vdGVzIiwiYXJjaGl2ZWROb3RlIiwiYXJjaGl2ZWRBdCIsInVwZGF0ZWRBcmNoaXZlZE5vdGVzIiwiYWRkVGFzayIsInRhc2tEYXRhIiwiZGV0YWlscyIsInVwZGF0ZVRhc2siLCJ0YXNrSWQiLCJkZWxldGVUYXNrIiwiY29tcGxldGVUYXNrIiwiY29tcGxldGVkIiwic2V0Q3Jld0NvbG9yVGFnIiwidXBzZXJ0RXJyb3IiLCJ1cHNlcnQiLCJvbkNvbmZsaWN0IiwiZGVsRXJyb3IiLCJwcmV2IiwibmV4dCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/use-supabase-data.ts\n"));

/***/ })

});