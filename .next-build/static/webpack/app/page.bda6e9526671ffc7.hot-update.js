"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/use-supabase-data.ts":
/*!************************************!*\
  !*** ./hooks/use-supabase-data.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateWorkDays: () => (/* binding */ calculateWorkDays),\n/* harmony export */   calculateWorkDaysVasteDienst: () => (/* binding */ calculateWorkDaysVasteDienst),\n/* harmony export */   useSupabaseData: () => (/* binding */ useSupabaseData)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n\n\n// Function to calculate work days for vaste dienst aflossers based on hours\n// Uses 12-hour increments: 0-12h = 0.5 day, 12-24h = 1.0 day, etc.\nfunction calculateWorkDaysVasteDienst(startDate, startTime, endDate, endTime) {\n    if (!startDate || !endDate || !startTime || !endTime) return 0;\n    // Parse both DD-MM-YYYY and ISO format dates\n    const parseDate = (dateStr)=>{\n        if (!dateStr || typeof dateStr !== 'string') {\n            console.error('Invalid date string:', dateStr);\n            return new Date() // Return current date as fallback\n            ;\n        }\n        // Check if it's already an ISO date (contains T or has 4-digit year at start)\n        if (dateStr.includes('T') || /^\\d{4}-\\d{2}-\\d{2}/.test(dateStr)) {\n            // It's already an ISO date, use it directly\n            const date = new Date(dateStr);\n            if (isNaN(date.getTime())) {\n                console.error('Invalid ISO date:', dateStr);\n                return new Date() // Return current date as fallback\n                ;\n            }\n            return date;\n        }\n        // Otherwise, parse as DD-MM-YYYY format\n        const parts = dateStr.split('-');\n        if (parts.length !== 3) {\n            console.error('Invalid date format:', dateStr);\n            return new Date() // Return current date as fallback\n            ;\n        }\n        const day = parseInt(parts[0], 10);\n        const month = parseInt(parts[1], 10) - 1 // JavaScript months are 0-based\n        ;\n        const year = parseInt(parts[2], 10);\n        const date = new Date(year, month, day);\n        if (isNaN(date.getTime())) {\n            console.error('Invalid parsed date:', dateStr);\n            return new Date() // Return current date as fallback\n            ;\n        }\n        return date;\n    };\n    // Parse time string (HH:MM:SS or HH:MM format)\n    const parseTime = (timeStr)=>{\n        if (!timeStr || typeof timeStr !== 'string') {\n            console.error('Invalid time string:', timeStr);\n            return 0;\n        }\n        const timeParts = timeStr.split(':');\n        if (timeParts.length < 2) {\n            console.error('Invalid time format:', timeStr);\n            return 0;\n        }\n        const hours = parseInt(timeParts[0], 10);\n        const minutes = parseInt(timeParts[1], 10);\n        if (isNaN(hours) || isNaN(minutes)) {\n            console.error('Invalid time values:', timeStr);\n            return 0;\n        }\n        return hours + minutes / 60;\n    };\n    const start = parseDate(startDate);\n    const end = parseDate(endDate);\n    const startTimeHours = parseTime(startTime);\n    const endTimeHours = parseTime(endTime);\n    if (end < start) {\n        console.error('Error: end date is before start date');\n        return 0;\n    }\n    // Create full datetime objects\n    const startDateTime = new Date(start);\n    startDateTime.setHours(Math.floor(startTimeHours), startTimeHours % 1 * 60, 0, 0);\n    const endDateTime = new Date(end);\n    endDateTime.setHours(Math.floor(endTimeHours), endTimeHours % 1 * 60, 0, 0);\n    // Calculate duration in hours\n    const timeDiffMs = endDateTime.getTime() - startDateTime.getTime();\n    const totalHours = timeDiffMs / (1000 * 60 * 60);\n    // Convert to day credits using 12-hour increments\n    // Formula: credits = ceil(hours / 12) * 0.5\n    const dayCredits = Math.ceil(totalHours / 12) * 0.5;\n    return dayCredits;\n}\n// Functie om automatisch crew members te activeren op hun startdatum\nasync function autoActivateCrewMembers(crewData) {\n    const today = new Date();\n    today.setHours(0, 0, 0, 0) // Reset naar start van de dag\n    ;\n    for (const member of crewData){\n        // Check of deze persoon moet worden geactiveerd\n        // Status kan \"thuis\" zijn (wachtend op startdatum) of \"nog-in-te-delen\"\n        if ((member.status === 'thuis' || member.status === 'nog-in-te-delen') && member.expected_start_date && member.ship_id && member.regime) {\n            const startDate = new Date(member.expected_start_date);\n            startDate.setHours(0, 0, 0, 0);\n            // Is vandaag >= startdatum?\n            if (today >= startDate) {\n                console.log(\"\\uD83D\\uDE80 Auto-activating \".concat(member.first_name, \" \").concat(member.last_name, \" - Start date reached!\"));\n                try {\n                    // Update naar \"aan-boord\" status\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').update({\n                        status: 'aan-boord',\n                        on_board_since: member.expected_start_date,\n                        thuis_sinds: null,\n                        expected_start_date: null,\n                        sub_status: null // Clear sub_status\n                    }).eq('id', member.id);\n                    if (error) {\n                        console.error('Error auto-activating crew member:', error);\n                    } else {\n                        console.log(\"âœ… \".concat(member.first_name, \" \").concat(member.last_name, \" is now active!\"));\n                    }\n                } catch (err) {\n                    console.error('Error in auto-activation:', err);\n                }\n            }\n        }\n    }\n}\n// Functie om automatisch rotaties uit te voeren\nasync function autoRotateCrewMembers(crewData) {\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    for (const member of crewData){\n        // Skip als geen regime, ziek, of \"Altijd\"\n        if (!member.regime || member.status === 'ziek' || member.regime === 'Altijd') {\n            continue;\n        }\n        const regimeWeeks = parseInt(member.regime.split('/')[0]);\n        const regimeDays = regimeWeeks * 7;\n        // Check of iemand van aan-boord naar thuis moet\n        if (member.status === 'aan-boord' && member.on_board_since) {\n            const onBoardDate = new Date(member.on_board_since);\n            onBoardDate.setHours(0, 0, 0, 0);\n            const daysSinceOnBoard = Math.floor((today.getTime() - onBoardDate.getTime()) / (1000 * 60 * 60 * 24));\n            if (daysSinceOnBoard >= regimeDays) {\n                const thuisSinds = new Date(onBoardDate);\n                thuisSinds.setDate(thuisSinds.getDate() + regimeDays);\n                console.log(\"\\uD83D\\uDD04 Auto-rotating \".concat(member.first_name, \" \").concat(member.last_name, \" to THUIS\"));\n                try {\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').update({\n                        status: 'thuis',\n                        thuis_sinds: thuisSinds.toISOString().split('T')[0],\n                        on_board_since: null\n                    }).eq('id', member.id);\n                    if (error) {\n                        console.error('Error rotating to thuis:', error);\n                    } else {\n                        console.log(\"âœ… \".concat(member.first_name, \" is now thuis\"));\n                    }\n                } catch (err) {\n                    console.error('Error in rotation:', err);\n                }\n            }\n        }\n        // Check of iemand van thuis naar aan-boord moet\n        if (member.status === 'thuis' && member.thuis_sinds) {\n            const thuisDate = new Date(member.thuis_sinds);\n            thuisDate.setHours(0, 0, 0, 0);\n            const daysSinceThuis = Math.floor((today.getTime() - thuisDate.getTime()) / (1000 * 60 * 60 * 24));\n            if (daysSinceThuis >= regimeDays) {\n                const onBoardSince = new Date(thuisDate);\n                onBoardSince.setDate(onBoardSince.getDate() + regimeDays);\n                console.log(\"\\uD83D\\uDD04 Auto-rotating \".concat(member.first_name, \" \").concat(member.last_name, \" to AAN-BOORD\"));\n                try {\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').update({\n                        status: 'aan-boord',\n                        on_board_since: onBoardSince.toISOString().split('T')[0],\n                        thuis_sinds: null\n                    }).eq('id', member.id);\n                    if (error) {\n                        console.error('Error rotating to aan-boord:', error);\n                    } else {\n                        console.log(\"âœ… \".concat(member.first_name, \" is now aan-boord\"));\n                    }\n                } catch (err) {\n                    console.error('Error in rotation:', err);\n                }\n            }\n        }\n    }\n}\n// Functie om automatisch vaste dienst records te beheren\nasync function autoManageVasteDienstRecords(crewData, vasteDienstRecords, tripsData) {\n    const today = new Date();\n    const currentYear = today.getFullYear();\n    const currentMonth = today.getMonth() + 1 // JavaScript months are 0-based\n    ;\n    console.log(\"\\uD83D\\uDD27 Auto-managing vaste dienst records for \".concat(currentYear, \"-\").concat(currentMonth));\n    // Get all aflossers in vaste dienst\n    const vasteDienstAflossers = crewData.filter((member)=>member.vaste_dienst === true);\n    for (const aflosser of vasteDienstAflossers){\n        console.log(\"\\uD83D\\uDCCB Processing vaste dienst aflosser: \".concat(aflosser.first_name, \" \").concat(aflosser.last_name));\n        // Check if current month record exists\n        const existingRecord = vasteDienstRecords.find((record)=>record.aflosser_id === aflosser.id && record.year === currentYear && record.month === currentMonth);\n        if (!existingRecord) {\n            // Create new monthly record\n            console.log(\"\\uD83D\\uDCC5 Creating new monthly record for \".concat(aflosser.first_name, \" \").concat(aflosser.last_name));\n            try {\n                const newRecord = {\n                    aflosser_id: aflosser.id,\n                    year: currentYear,\n                    month: currentMonth,\n                    required_days: 15,\n                    actual_days: 0,\n                    balance_days: 0,\n                    notes: \"Automatisch aangemaakt voor \".concat(currentYear, \"-\").concat(currentMonth)\n                };\n                const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').insert([\n                    newRecord\n                ]).select().single();\n                if (error) {\n                    console.error('Error creating vaste dienst record:', error);\n                } else {\n                    console.log(\"âœ… Created monthly record for \".concat(aflosser.first_name));\n                }\n            } catch (err) {\n                console.error('Error in vaste dienst record creation:', err);\n            }\n        }\n        // Calculate actual days from completed trips for current month\n        const currentMonthTrips = tripsData.filter((trip)=>trip.aflosser_id === aflosser.id && trip.status === 'voltooid' && trip.eind_datum && new Date(trip.eind_datum).getFullYear() === currentYear && new Date(trip.eind_datum).getMonth() + 1 === currentMonth);\n        let totalWorkDays = 0;\n        for (const trip of currentMonthTrips){\n            const workDays = calculateWorkDays(trip.start_datum, trip.start_tijd, trip.eind_datum, trip.eind_tijd);\n            totalWorkDays += workDays;\n        }\n        // Update the record with actual days and balance\n        if (existingRecord) {\n            const requiredDays = 15;\n            // CORRECTE BEREKENING: Eindsaldo = Beginsaldo + (Gewerkt - 15)\n            // Voor eerste maand: Beginsaldo = -15 + startsaldo\n            let beginsaldo = existingRecord.balance_days || 0;\n            // Als dit de eerste maand is en er is geen beginsaldo, gebruik -15 + startsaldo\n            if (beginsaldo === 0 && currentMonth === 1) {\n                var _aflosser_notes;\n                // Probeer startsaldo uit notes te halen\n                const startsaldoNote = (_aflosser_notes = aflosser.notes) === null || _aflosser_notes === void 0 ? void 0 : _aflosser_notes.find((note)=>note.text && (note.text.includes('startsaldo') || note.text.includes('Startsaldo')));\n                if (startsaldoNote) {\n                    const match = startsaldoNote.text.match(/(-?\\d+(?:\\.\\d+)?)/);\n                    if (match) {\n                        const startsaldo = parseFloat(match[1]);\n                        beginsaldo = -15 + startsaldo;\n                        console.log(\"\\uD83D\\uDCCA Eerste maand: startsaldo \".concat(startsaldo, \", beginsaldo \").concat(beginsaldo));\n                    }\n                }\n                if (beginsaldo === 0) beginsaldo = -15 // Fallback\n                ;\n            }\n            // Voor de eerste maand: toon het beginsaldo als huidig saldo\n            // Voor volgende maanden: bereken het eindsaldo\n            let balanceDays;\n            if (currentMonth === 1 && beginsaldo !== -15) {\n                // Eerste maand met startsaldo: toon beginsaldo\n                balanceDays = beginsaldo;\n            } else {\n                // Normale berekening: beginsaldo + (gewerkt - 15)\n                balanceDays = beginsaldo + (totalWorkDays - requiredDays);\n            }\n            // Cap values to fit in DECIMAL(4,1) - max 999.9\n            const cappedActualDays = Math.min(totalWorkDays, 999.9);\n            const cappedBalanceDays = Math.min(Math.max(balanceDays, -999.9), 999.9);\n            if (existingRecord.actual_days !== cappedActualDays || existingRecord.balance_days !== cappedBalanceDays) {\n                console.log(\"\\uD83D\\uDCCA Updating record for \".concat(aflosser.first_name, \": \").concat(cappedActualDays, \" days (balance: \").concat(cappedBalanceDays, \")\"));\n                try {\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').update({\n                        actual_days: cappedActualDays,\n                        balance_days: cappedBalanceDays\n                    }).eq('id', existingRecord.id);\n                    if (error) {\n                        console.error('âŒ Error updating vaste dienst record:', error);\n                        console.error('âŒ Error details:', JSON.stringify(error, null, 2));\n                        console.error('âŒ Record data:', {\n                            id: existingRecord.id,\n                            actual_days: totalWorkDays,\n                            balance_days: balanceDays\n                        });\n                    } else {\n                        console.log(\"âœ… Updated record for \".concat(aflosser.first_name));\n                    }\n                } catch (err) {\n                    console.error('Error updating vaste dienst record:', err);\n                }\n            }\n        }\n    }\n}\n// Helper function to calculate work days from trip data\nfunction calculateWorkDays(startDate, startTime, endDate, endTime) {\n    if (!startDate || !endDate) return 0;\n    // Parse both DD-MM-YYYY and ISO format dates\n    const parseDate = (dateStr)=>{\n        if (!dateStr || typeof dateStr !== 'string') {\n            console.error('Invalid date string:', dateStr);\n            return new Date() // Return current date as fallback\n            ;\n        }\n        // Check if it's already an ISO date (contains T or has 4-digit year at start)\n        if (dateStr.includes('T') || /^\\d{4}-\\d{2}-\\d{2}/.test(dateStr)) {\n            // It's already an ISO date, use it directly\n            const date = new Date(dateStr);\n            if (isNaN(date.getTime())) {\n                console.error('Invalid ISO date:', dateStr);\n                return new Date() // Return current date as fallback\n                ;\n            }\n            return date;\n        }\n        // Otherwise, parse as DD-MM-YYYY format\n        const parts = dateStr.split('-');\n        if (parts.length !== 3) {\n            console.error('Invalid date format:', dateStr);\n            return new Date() // Return current date as fallback\n            ;\n        }\n        const [day, month, year] = parts;\n        const isoDate = \"\".concat(year, \"-\").concat(month.padStart(2, '0'), \"-\").concat(day.padStart(2, '0'));\n        const date = new Date(isoDate);\n        if (isNaN(date.getTime())) {\n            console.error('Invalid date after parsing:', isoDate, 'from:', dateStr);\n            return new Date() // Return current date as fallback\n            ;\n        }\n        return date;\n    };\n    const start = parseDate(startDate);\n    const end = parseDate(endDate);\n    // Validatie: afstapdatum mag niet voor instapdatum liggen\n    if (end < start) {\n        console.error('Error: end date is before start date');\n        return 0;\n    }\n    // Simpele telling: tel kalenderdagen van start tot eind (inclusief beide)\n    const timeDiff = end.getTime() - start.getTime();\n    const daysDiff = Math.ceil(timeDiff / (1000 * 60 * 60 * 24)) + 1 // +1 omdat we beide datums inclusief tellen\n    ;\n    return daysDiff;\n}\n// Function to auto-update vaste dienst records when a trip is completed\nasync function autoUpdateVasteDienstFromTrip(completedTrip) {\n    try {\n        var _aflosser_notes;\n        console.log(\"\\uD83D\\uDD04 Auto-updating vaste dienst for completed trip: \".concat(completedTrip.id));\n        console.log(\"\\uD83D\\uDD04 Trip data:\", completedTrip);\n        // Get the aflosser\n        const { data: aflosser, error: aflosserError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').select('*').eq('id', completedTrip.aflosser_id).single();\n        if (aflosserError || !aflosser) {\n            console.error('Error fetching aflosser:', aflosserError);\n            return;\n        }\n        // Check if aflosser is in vaste dienst\n        if (!aflosser.vaste_dienst) {\n            console.log('Aflosser is not in vaste dienst, skipping auto-update');\n            return;\n        }\n        // Get the month/year of the trip completion\n        // Parse the date using our safe parseDate function\n        const parseDate = (dateStr)=>{\n            if (!dateStr || typeof dateStr !== 'string') {\n                console.error('Invalid date string:', dateStr);\n                return new Date();\n            }\n            // Check if it's already an ISO date (contains T or has 4-digit year at start)\n            if (dateStr.includes('T') || /^\\d{4}-\\d{2}-\\d{2}/.test(dateStr)) {\n                // It's already an ISO date, use it directly\n                const date = new Date(dateStr);\n                if (isNaN(date.getTime())) {\n                    console.error('Invalid ISO date:', dateStr);\n                    return new Date();\n                }\n                return date;\n            }\n            // Otherwise, parse as DD-MM-YYYY format\n            const parts = dateStr.split('-');\n            if (parts.length !== 3) {\n                console.error('Invalid date format:', dateStr);\n                return new Date();\n            }\n            const [day, month, year] = parts;\n            const isoDate = \"\".concat(year, \"-\").concat(month.padStart(2, '0'), \"-\").concat(day.padStart(2, '0'));\n            const date = new Date(isoDate);\n            if (isNaN(date.getTime())) {\n                console.error('Invalid date after parsing:', isoDate, 'from:', dateStr);\n                return new Date();\n            }\n            return date;\n        };\n        const endDate = parseDate(completedTrip.eind_datum);\n        const year = endDate.getFullYear();\n        const month = endDate.getMonth() + 1;\n        // Check if monthly record exists\n        const { data: existingRecord, error: recordError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').select('*').eq('aflosser_id', completedTrip.aflosser_id).eq('year', year).eq('month', month).single();\n        if (recordError && recordError.code !== 'PGRST116') {\n            console.error('Error fetching vaste dienst record:', recordError);\n            return;\n        }\n        let recordId = existingRecord === null || existingRecord === void 0 ? void 0 : existingRecord.id;\n        // Create record if it doesn't exist\n        if (!existingRecord) {\n            console.log(\"\\uD83D\\uDCC5 Creating new monthly record for \".concat(aflosser.first_name, \" \").concat(aflosser.last_name));\n            const newRecord = {\n                aflosser_id: completedTrip.aflosser_id,\n                year: year,\n                month: month,\n                required_days: 15,\n                actual_days: 0,\n                balance_days: 0,\n                notes: \"Automatisch aangemaakt voor \".concat(year, \"-\").concat(month)\n            };\n            const { data: createdRecord, error: createError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').insert([\n                newRecord\n            ]).select().single();\n            if (createError) {\n                console.error('Error creating vaste dienst record:', createError);\n                return;\n            }\n            recordId = createdRecord.id;\n        }\n        // Calculate work days for this trip\n        const workDays = calculateWorkDays(completedTrip.start_datum, completedTrip.start_tijd, completedTrip.eind_datum, completedTrip.eind_tijd);\n        // Get all completed trips for this month to calculate total\n        const { data: allTrips, error: tripsError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('trips').select('*').eq('aflosser_id', completedTrip.aflosser_id).eq('status', 'voltooid').not('eind_datum', 'is', null);\n        if (tripsError) {\n            console.error('Error fetching trips:', tripsError);\n            return;\n        }\n        // Calculate total work days for the month\n        let totalWorkDays = 0;\n        for (const trip of allTrips || []){\n            const tripEndDate = parseDate(trip.eind_datum);\n            if (tripEndDate.getFullYear() === year && tripEndDate.getMonth() + 1 === month) {\n                const tripWorkDays = calculateWorkDays(trip.start_datum, trip.start_tijd, trip.eind_datum, trip.eind_tijd);\n                totalWorkDays += tripWorkDays;\n            }\n        }\n        // Update the record\n        const requiredDays = 15;\n        // CORRECTE BEREKENING: Eindsaldo = Beginsaldo + (Gewerkt - 15)\n        // Voor eerste maand: Beginsaldo = -15 + startsaldo\n        let beginsaldo = 0;\n        // Probeer startsaldo uit notes te halen voor nieuwe aflossers\n        const startsaldoNote = (_aflosser_notes = aflosser.notes) === null || _aflosser_notes === void 0 ? void 0 : _aflosser_notes.find((note)=>note.text && (note.text.includes('startsaldo') || note.text.includes('Startsaldo')));\n        if (startsaldoNote) {\n            const match = startsaldoNote.text.match(/(-?\\d+(?:\\.\\d+)?)/);\n            if (match) {\n                const startsaldo = parseFloat(match[1]);\n                beginsaldo = -15 + startsaldo;\n                console.log(\"\\uD83D\\uDCCA Nieuwe aflosser: startsaldo \".concat(startsaldo, \", beginsaldo \").concat(beginsaldo));\n            }\n        }\n        if (beginsaldo === 0) beginsaldo = -15 // Fallback\n        ;\n        // Voor de eerste maand: toon het beginsaldo als huidig saldo\n        // Voor volgende maanden: bereken het eindsaldo\n        let balanceDays;\n        if (month === 1 && beginsaldo !== -15) {\n            // Eerste maand met startsaldo: toon beginsaldo\n            balanceDays = beginsaldo;\n        } else {\n            // Normale berekening: beginsaldo + (gewerkt - 15)\n            balanceDays = beginsaldo + (totalWorkDays - requiredDays);\n        }\n        // Cap values to fit in DECIMAL(4,1) - max 999.9\n        const cappedActualDays = Math.min(totalWorkDays, 999.9);\n        const cappedBalanceDays = Math.min(Math.max(balanceDays, -999.9), 999.9);\n        const { error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').update({\n            actual_days: cappedActualDays,\n            balance_days: cappedBalanceDays\n        }).eq('id', recordId);\n        if (updateError) {\n            console.error('âŒ Error updating vaste dienst record:', updateError);\n            console.error('âŒ Error details:', JSON.stringify(updateError, null, 2));\n            console.error('âŒ Record data:', {\n                id: recordId,\n                actual_days: totalWorkDays,\n                balance_days: balanceDays\n            });\n        } else {\n            console.log(\"âœ… Updated vaste dienst record for \".concat(aflosser.first_name, \": \").concat(totalWorkDays, \" days (balance: \").concat(balanceDays, \")\"));\n        }\n    } catch (err) {\n        console.error('Error in auto-update vaste dienst:', err);\n    }\n}\n// Function to force recalculate all vaste dienst records with new logic\nasync function forceRecalculateAllVasteDienstRecords(crewData, tripsData) {\n    try {\n        console.log('ðŸ”„ Force recalculating all vaste dienst records...');\n        console.log(\"\\uD83D\\uDCCA Crew data: \".concat(crewData.length, \" members\"));\n        console.log(\"\\uD83D\\uDCCA Trips data: \".concat(tripsData.length, \" trips\"));\n        // Get all vaste dienst records\n        const { data: allRecords, error: fetchError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').select('*');\n        if (fetchError) {\n            console.error('âŒ Error fetching vaste dienst records:', fetchError);\n            return;\n        }\n        if (!allRecords || allRecords.length === 0) {\n            console.log('âš ï¸ No vaste dienst records found to recalculate');\n            return;\n        }\n        console.log(\"\\uD83D\\uDCCB Found \".concat(allRecords.length, \" records to recalculate\"));\n        // Process each record\n        for (const record of allRecords){\n            try {\n                console.log(\"\\n\\uD83D\\uDD0D Processing record \".concat(record.id, \" for aflosser \").concat(record.aflosser_id));\n                // Find the aflosser\n                const aflosser = crewData.find((crew)=>crew.id === record.aflosser_id);\n                if (!aflosser) {\n                    console.log(\"âš ï¸ Aflosser not found for record \".concat(record.id));\n                    continue;\n                }\n                console.log(\"\\uD83D\\uDC64 Found aflosser: \".concat(aflosser.first_name, \" \").concat(aflosser.last_name));\n                // Get all completed trips for this aflosser\n                const allTrips = tripsData.filter((trip)=>trip.aflosser_id === record.aflosser_id && trip.status === 'voltooid' && trip.start_datum && trip.eind_datum && trip.start_tijd && trip.eind_tijd);\n                console.log(\"\\uD83D\\uDEA2 Found \".concat(allTrips.length, \" completed trips for this aflosser\"));\n                // Calculate total work days with new logic\n                let totalWorkDays = 0;\n                for (const trip of allTrips){\n                    const workDays = calculateWorkDays(trip.start_datum, trip.start_tijd, trip.eind_datum, trip.eind_tijd);\n                    console.log(\"  \\uD83D\\uDCC5 Trip \".concat(trip.id, \": \").concat(trip.start_datum, \" to \").concat(trip.eind_datum, \" = \").concat(workDays, \" days\"));\n                    totalWorkDays += workDays;\n                }\n                console.log(\"\\uD83D\\uDCCA Total work days calculated: \".concat(totalWorkDays));\n                // Cap values to fit in DECIMAL(4,1)\n                const requiredDays = 15;\n                // CORRECTE BEREKENING: Eindsaldo = Beginsaldo + (Gewerkt - 15)\n                // Voor eerste maand: Beginsaldo = -15 + startsaldo\n                let beginsaldo = record.balance_days || 0;\n                // Als dit de eerste maand is en er is geen beginsaldo, gebruik -15 + startsaldo\n                if (beginsaldo === 0 && record.month === 1) {\n                    var _aflosser_notes;\n                    // Probeer startsaldo uit notes te halen\n                    const startsaldoNote = (_aflosser_notes = aflosser.notes) === null || _aflosser_notes === void 0 ? void 0 : _aflosser_notes.find((note)=>note.text && (note.text.includes('startsaldo') || note.text.includes('Startsaldo')));\n                    if (startsaldoNote) {\n                        const match = startsaldoNote.text.match(/(-?\\d+(?:\\.\\d+)?)/);\n                        if (match) {\n                            const startsaldo = parseFloat(match[1]);\n                            beginsaldo = -15 + startsaldo;\n                            console.log(\"\\uD83D\\uDCCA Eerste maand herberekening: startsaldo \".concat(startsaldo, \", beginsaldo \").concat(beginsaldo));\n                        }\n                    }\n                    if (beginsaldo === 0) beginsaldo = -15 // Fallback\n                    ;\n                }\n                // Voor de eerste maand: toon het beginsaldo als huidig saldo\n                // Voor volgende maanden: bereken het eindsaldo\n                let balanceDays;\n                if (record.month === 1 && beginsaldo !== -15) {\n                    // Eerste maand met startsaldo: toon beginsaldo\n                    balanceDays = beginsaldo;\n                } else {\n                    // Normale berekening: beginsaldo + (gewerkt - 15)\n                    balanceDays = beginsaldo + (totalWorkDays - requiredDays);\n                }\n                const cappedActualDays = Math.min(totalWorkDays, 999.9);\n                const cappedBalanceDays = Math.min(Math.max(balanceDays, -999.9), 999.9);\n                console.log(\"\\uD83D\\uDCBE Updating record: actual=\".concat(cappedActualDays, \", balance=\").concat(cappedBalanceDays));\n                // Update the record\n                const { error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').update({\n                    actual_days: cappedActualDays,\n                    balance_days: cappedBalanceDays\n                }).eq('id', record.id);\n                if (updateError) {\n                    console.error(\"âŒ Error updating record \".concat(record.id, \":\"), updateError);\n                } else {\n                    console.log(\"âœ… Successfully updated record for \".concat(aflosser.first_name, \": \").concat(cappedActualDays, \" days (balance: \").concat(cappedBalanceDays, \")\"));\n                }\n            } catch (err) {\n                console.error(\"âŒ Error processing record \".concat(record.id, \":\"), err);\n            }\n        }\n        console.log('ðŸŽ‰ Force recalculation completed!');\n    } catch (err) {\n        console.error('âŒ Error in force recalculate:', err);\n    }\n}\n// Function to reset all vaste dienst records to 0\nasync function resetAllVasteDienstRecords() {\n    try {\n        console.log('ðŸ§¹ Resetting all vaste dienst records to 0...');\n        // Get all vaste dienst records\n        const { data: allRecords, error: fetchError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').select('*');\n        if (fetchError) {\n            console.error('Error fetching vaste dienst records for reset:', fetchError);\n            return;\n        }\n        if (!allRecords || allRecords.length === 0) {\n            console.log('No vaste dienst records found to reset');\n            return;\n        }\n        console.log(\"Found \".concat(allRecords.length, \" records to reset\"));\n        // Reset each record to 0\n        for (const record of allRecords){\n            try {\n                const { error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').update({\n                    actual_days: 0,\n                    balance_days: -15 // -15 because required_days is 15\n                }).eq('id', record.id);\n                if (updateError) {\n                    console.error(\"âŒ Error resetting record \".concat(record.id, \":\"), updateError);\n                } else {\n                    console.log(\"âœ… Reset record \".concat(record.id, \" to 0\"));\n                }\n            } catch (err) {\n                console.error(\"Error resetting record \".concat(record.id, \":\"), err);\n            }\n        }\n        console.log('ðŸŽ‰ Reset completed!');\n    } catch (err) {\n        console.error('Error in reset all records:', err);\n    }\n}\nfunction useSupabaseData() {\n    const [ships, setShips] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [crew, setCrew] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [sickLeave, setSickLeave] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [standBackRecords, setStandBackRecords] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loans, setLoans] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [trips, setTrips] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [vasteDienstRecords, setVasteDienstRecords] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [tasks, setTasks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [incidents, setIncidents] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [crewColorTags, setCrewColorTags] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    // Load all data from Supabase\n    const loadData = async ()=>{\n        try {\n            setLoading(true);\n            setError(null);\n            console.log('Loading data from Supabase...');\n            // Check if user is authenticated\n            const { data: { session } } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.auth.getSession();\n            console.log('Current session:', session ? 'User logged in' : 'No user session');\n            if (!session) {\n                console.warn('No active session - user needs to login');\n                setShips([]);\n                setCrew([]);\n                setSickLeave([]);\n                setStandBackRecords([]);\n                setLoans([]);\n                setTrips([]);\n                setVasteDienstRecords([]);\n                setTasks([]);\n                setIncidents([]);\n                setLoading(false);\n                return;\n            }\n            // Test Supabase connection\n            console.log('Testing Supabase connection...');\n            const { data: testData, error: testError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('sick_leave').select('id').limit(1);\n            if (testError) {\n                console.error('Supabase connection test failed:', testError);\n                console.error('Test error details:', JSON.stringify(testError, null, 2));\n            } else {\n                console.log('âœ… Supabase connection test successful');\n            }\n            // Load ships\n            console.log('Loading ships...');\n            const { data: shipsData, error: shipsError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('ships').select('*').order('name');\n            if (shipsError) {\n                console.error('Error loading ships:', shipsError);\n                console.error('Ships error details:', JSON.stringify(shipsError, null, 2));\n            } else {\n                console.log('Ships loaded:', (shipsData === null || shipsData === void 0 ? void 0 : shipsData.length) || 0);\n                setShips(shipsData || []);\n            }\n            // Load crew\n            console.log('Loading crew...');\n            const { data: crewData, error: crewError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').select('*').order('first_name');\n            if (crewError) {\n                console.error('Error loading crew:', crewError);\n                console.error('Crew error details:', JSON.stringify(crewError, null, 2));\n            } else {\n                console.log('Crew loaded:', (crewData === null || crewData === void 0 ? void 0 : crewData.length) || 0);\n                // Temporarily disable auto-activation and rotation to prevent infinite loops\n                // await autoActivateCrewMembers(crewData || [])\n                // await autoRotateCrewMembers(crewData || [])\n                // Set crew data directly without reloading\n                setCrew(crewData || []);\n            }\n            // Load sick leave\n            console.log('Loading sick leave...');\n            const { data: sickLeaveData, error: sickLeaveError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('sick_leave').select('*').order('start_date', {\n                ascending: false\n            });\n            if (sickLeaveError) {\n                console.error('Error loading sick leave:', sickLeaveError);\n            } else {\n                console.log('Sick leave loaded:', (sickLeaveData === null || sickLeaveData === void 0 ? void 0 : sickLeaveData.length) || 0);\n                setSickLeave(sickLeaveData || []);\n            }\n            // Load stand back records\n            console.log('Loading stand back records...');\n            const { data: standBackData, error: standBackError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('stand_back_records').select('*').order('created_at', {\n                ascending: false\n            });\n            if (standBackError) {\n                console.error('Error loading stand back records:', standBackError);\n                setStandBackRecords([]);\n            } else {\n                console.log('Stand back records loaded:', (standBackData === null || standBackData === void 0 ? void 0 : standBackData.length) || 0);\n                setStandBackRecords(standBackData || []);\n            }\n            // Load loans\n            console.log('Loading loans...');\n            const { data: loansData, error: loansError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('loans').select('*').order('created_at', {\n                ascending: false\n            });\n            if (loansError) {\n                console.error('Error loading loans:', loansError);\n                setLoans([]);\n            } else {\n                console.log('Loans loaded:', (loansData === null || loansData === void 0 ? void 0 : loansData.length) || 0);\n                setLoans(loansData || []);\n            }\n            // Load trips\n            console.log('Loading trips...');\n            const { data: tripsData, error: tripsError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('trips').select('*').order('created_at', {\n                ascending: false\n            });\n            if (tripsError) {\n                console.error('Error loading trips:', tripsError);\n                setTrips([]);\n            } else {\n                console.log('Trips loaded:', (tripsData === null || tripsData === void 0 ? void 0 : tripsData.length) || 0);\n                setTrips(tripsData || []);\n            }\n            // Load vaste dienst records\n            console.log('Loading vaste dienst records...');\n            const { data: vasteDienstData, error: vasteDienstError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').select('*').order('year', {\n                ascending: false\n            }).order('month', {\n                ascending: false\n            });\n            if (vasteDienstError) {\n                console.error('Error loading vaste dienst records:', vasteDienstError);\n                setVasteDienstRecords([]);\n            } else {\n                console.log('Vaste dienst records loaded:', (vasteDienstData === null || vasteDienstData === void 0 ? void 0 : vasteDienstData.length) || 0);\n                setVasteDienstRecords(vasteDienstData || []);\n                // Auto-manage vaste dienst records after loading all data\n                console.log('ðŸ”§ Auto-managing vaste dienst records...');\n                await autoManageVasteDienstRecords(crewData || [], vasteDienstData || [], tripsData || []);\n            }\n            // Load tasks\n            console.log('Loading tasks...');\n            const { data: tasksData, error: tasksError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('tasks').select('*').order('created_at', {\n                ascending: false\n            });\n            if (tasksError) {\n                console.error('Error loading tasks:', tasksError);\n                setTasks([]);\n            } else {\n                console.log('Tasks loaded:', (tasksData === null || tasksData === void 0 ? void 0 : tasksData.length) || 0);\n                setTasks(tasksData || []);\n            }\n            // Load incidents\n            console.log('Loading incidents...');\n            const { data: incidentsData, error: incidentsError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('incidents').select('*').order('created_at', {\n                ascending: false\n            });\n            if (incidentsError) {\n                console.error('Error loading incidents:', incidentsError);\n                setIncidents([]);\n            } else {\n                console.log('Incidents loaded:', (incidentsData === null || incidentsData === void 0 ? void 0 : incidentsData.length) || 0);\n                setIncidents(incidentsData || []);\n            }\n            console.log('Data loading completed!');\n            // Load crew color tags last, non-blocking for main data\n            try {\n                const { data: colorRows, error: colorErr } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew_color_tags').select('crew_id, color');\n                if (colorErr) {\n                    const msg = (colorErr === null || colorErr === void 0 ? void 0 : colorErr.message) || String(colorErr);\n                    console.warn('Skipping crew_color_tags (table missing or no access):', msg);\n                    setCrewColorTags({});\n                } else {\n                    const map = {};\n                    for (const row of colorRows || []){\n                        if (row.crew_id && row.color) map[row.crew_id] = row.color;\n                    }\n                    setCrewColorTags(map);\n                }\n            } catch (e) {\n                console.warn('Error loading crew_color_tags:', (e === null || e === void 0 ? void 0 : e.message) || e);\n                setCrewColorTags({});\n            }\n        } catch (err) {\n            console.error('Error in loadData:', err);\n            setError(err instanceof Error ? err.message : 'Unknown error');\n        } finally{\n            setLoading(false);\n        }\n    };\n    // Load data on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSupabaseData.useEffect\": ()=>{\n            loadData();\n        // Temporarily disable daily check to prevent infinite loops\n        // const dailyCheck = setInterval(() => {\n        //   console.log('Running daily auto-activation check...')\n        //   loadData() // Dit zal autoActivateCrewMembers aanroepen\n        // }, 24 * 60 * 60 * 1000) // 24 uur\n        // return () => clearInterval(dailyCheck)\n        }\n    }[\"useSupabaseData.useEffect\"], []);\n    // Subscribe to real-time changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSupabaseData.useEffect\": ()=>{\n            // Subscribe to ships changes\n            const shipsSubscription = _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.channel('ships-changes').on('postgres_changes', {\n                event: '*',\n                schema: 'public',\n                table: 'ships'\n            }, {\n                \"useSupabaseData.useEffect.shipsSubscription\": ()=>{\n                    loadData();\n                }\n            }[\"useSupabaseData.useEffect.shipsSubscription\"]).subscribe();\n            // Subscribe to crew changes\n            const crewSubscription = _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.channel('crew-changes').on('postgres_changes', {\n                event: '*',\n                schema: 'public',\n                table: 'crew'\n            }, {\n                \"useSupabaseData.useEffect.crewSubscription\": ()=>{\n                    loadData();\n                }\n            }[\"useSupabaseData.useEffect.crewSubscription\"]).subscribe();\n            // Subscribe to sick leave changes\n            const sickLeaveSubscription = _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.channel('sick-leave-changes').on('postgres_changes', {\n                event: '*',\n                schema: 'public',\n                table: 'sick_leave'\n            }, {\n                \"useSupabaseData.useEffect.sickLeaveSubscription\": ()=>{\n                    loadData();\n                }\n            }[\"useSupabaseData.useEffect.sickLeaveSubscription\"]).subscribe();\n            // Subscribe to stand back records changes\n            const standBackSubscription = _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.channel('stand-back-changes').on('postgres_changes', {\n                event: '*',\n                schema: 'public',\n                table: 'stand_back_records'\n            }, {\n                \"useSupabaseData.useEffect.standBackSubscription\": ()=>{\n                    loadData();\n                }\n            }[\"useSupabaseData.useEffect.standBackSubscription\"]).subscribe();\n            // Subscribe to loans changes\n            const loansSubscription = _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.channel('loans-changes').on('postgres_changes', {\n                event: '*',\n                schema: 'public',\n                table: 'loans'\n            }, {\n                \"useSupabaseData.useEffect.loansSubscription\": ()=>{\n                    loadData();\n                }\n            }[\"useSupabaseData.useEffect.loansSubscription\"]).subscribe();\n            // Subscribe to trips changes\n            const tripsSubscription = _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.channel('trips-changes').on('postgres_changes', {\n                event: '*',\n                schema: 'public',\n                table: 'trips'\n            }, {\n                \"useSupabaseData.useEffect.tripsSubscription\": ()=>{\n                    loadData();\n                }\n            }[\"useSupabaseData.useEffect.tripsSubscription\"]).subscribe();\n            // Subscribe to tasks changes\n            const tasksSubscription = _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.channel('tasks-changes').on('postgres_changes', {\n                event: '*',\n                schema: 'public',\n                table: 'tasks'\n            }, {\n                \"useSupabaseData.useEffect.tasksSubscription\": ()=>{\n                    loadData();\n                }\n            }[\"useSupabaseData.useEffect.tasksSubscription\"]).subscribe();\n            // Subscribe to incidents changes\n            const incidentsSubscription = _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.channel('incidents-changes').on('postgres_changes', {\n                event: '*',\n                schema: 'public',\n                table: 'incidents'\n            }, {\n                \"useSupabaseData.useEffect.incidentsSubscription\": ()=>{\n                    loadData();\n                }\n            }[\"useSupabaseData.useEffect.incidentsSubscription\"]).subscribe();\n            return ({\n                \"useSupabaseData.useEffect\": ()=>{\n                    shipsSubscription.unsubscribe();\n                    crewSubscription.unsubscribe();\n                    sickLeaveSubscription.unsubscribe();\n                    standBackSubscription.unsubscribe();\n                    loansSubscription.unsubscribe();\n                    tripsSubscription.unsubscribe();\n                    tasksSubscription.unsubscribe();\n                    incidentsSubscription.unsubscribe();\n                }\n            })[\"useSupabaseData.useEffect\"];\n        }\n    }[\"useSupabaseData.useEffect\"], []);\n    // Add crew member\n    const addCrew = async (crewData)=>{\n        try {\n            console.log('Adding crew member to Supabase:', crewData);\n            console.log('Crew data details:', JSON.stringify(crewData, null, 2));\n            // Validate required fields\n            const requiredFields = [\n                'id',\n                'first_name',\n                'last_name',\n                'nationality',\n                'position'\n            ];\n            const missingFields = requiredFields.filter((field)=>!crewData[field]);\n            if (missingFields.length > 0) {\n                const error = new Error(\"Missing required fields: \".concat(missingFields.join(', ')));\n                console.error('Validation error:', error);\n                throw error;\n            }\n            // Check for duplicate crew member\n            const { data: existingCrew, error: checkError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').select('id').eq('first_name', crewData.first_name).eq('last_name', crewData.last_name).eq('nationality', crewData.nationality).single();\n            if (existingCrew && !checkError) {\n                const error = new Error(\"Crew member with name \".concat(crewData.first_name, \" \").concat(crewData.last_name, \" already exists\"));\n                console.error('Duplicate crew member:', error);\n                throw error;\n            }\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').insert([\n                crewData\n            ]).select().single();\n            if (error) {\n                console.error('Supabase error adding crew:', error);\n                console.error('Error details:', JSON.stringify(error, null, 2));\n                console.error('Error code:', error.code);\n                console.error('Error message:', error.message);\n                console.error('Error hint:', error.hint);\n                throw error;\n            }\n            console.log('Crew member added successfully:', data);\n            await loadData();\n            return data;\n        } catch (err) {\n            console.error('Error adding crew:', err);\n            console.error('Error details:', JSON.stringify(err, null, 2));\n            throw err;\n        }\n    };\n    // Update crew member\n    const updateCrew = async (id, updates)=>{\n        try {\n            console.log('Updating crew member in Supabase:', id, updates);\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').update(updates).eq('id', id).select().single();\n            if (error) {\n                console.error('Supabase error updating crew:', error);\n                throw error;\n            }\n            console.log('Crew member updated successfully');\n            await loadData();\n            return data;\n        } catch (err) {\n            console.error('Error updating crew:', err);\n            throw err;\n        }\n    };\n    // Delete crew member\n    const deleteCrew = async (id)=>{\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').delete().eq('id', id);\n            if (error) throw error;\n            await loadData() // Reload all data\n            ;\n        } catch (err) {\n            console.error('Error deleting crew:', err);\n            throw err;\n        }\n    };\n    // Add ship\n    const addShip = async (shipData)=>{\n        try {\n            console.log('Adding ship to Supabase:', shipData);\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('ships').insert([\n                shipData\n            ]).select().single();\n            if (error) {\n                console.error('Supabase error adding ship:', error);\n                console.error('Error details:', JSON.stringify(error, null, 2));\n                throw error;\n            }\n            console.log('Ship added successfully:', data);\n            await loadData();\n            return data;\n        } catch (err) {\n            console.error('Error adding ship:', err);\n            throw err;\n        }\n    };\n    // Update ship\n    const updateShip = async (id, updates)=>{\n        try {\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('ships').update(updates).eq('id', id).select().single();\n            if (error) throw error;\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error updating ship:', err);\n            throw err;\n        }\n    };\n    // Delete ship\n    const deleteShip = async (id)=>{\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('ships').delete().eq('id', id);\n            if (error) throw error;\n            await loadData() // Reload all data\n            ;\n        } catch (err) {\n            console.error('Error deleting ship:', err);\n            throw err;\n        }\n    };\n    // Add sick leave\n    const addSickLeave = async (sickLeaveData)=>{\n        try {\n            console.log('Adding sick leave to Supabase:', sickLeaveData);\n            // Ensure notes is not null\n            if (sickLeaveData.notes === null || sickLeaveData.notes === undefined) {\n                sickLeaveData.notes = \"\";\n            }\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('sick_leave').insert([\n                sickLeaveData\n            ]).select().single();\n            if (error) {\n                console.error('Supabase error adding sick leave:', error);\n                console.error('Error details:', JSON.stringify(error, null, 2));\n                throw error;\n            }\n            console.log('Sick leave added successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error adding sick leave:', err);\n            throw err;\n        }\n    };\n    // Update sick leave\n    const updateSickLeave = async (id, updates)=>{\n        try {\n            console.log('Updating sick leave in Supabase:', id, updates);\n            // Ensure notes is not null\n            if (updates.notes === null || updates.notes === undefined) {\n                updates.notes = \"\";\n            }\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('sick_leave').update(updates).eq('id', id).select().single();\n            if (error) {\n                console.error('Supabase error updating sick leave:', error);\n                console.error('Error details:', JSON.stringify(error, null, 2));\n                throw error;\n            }\n            console.log('Sick leave updated successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error updating sick leave:', err);\n            console.error('Error details:', JSON.stringify(err, null, 2));\n            throw err;\n        }\n    };\n    const addStandBackRecord = async (recordData)=>{\n        try {\n            console.log('=== ADDING STAND BACK RECORD ===');\n            console.log('Original record data:', recordData);\n            // Generate a UUID for the id field\n            const uuid = crypto.randomUUID();\n            console.log('Generated UUID:', uuid);\n            // Remove id if it exists and add our generated UUID\n            const { id, ...dataWithoutId } = recordData;\n            // Create a safe data object with only known database columns\n            const dataToInsert = {\n                id: uuid,\n                crew_member_id: dataWithoutId.crew_member_id,\n                start_date: dataWithoutId.start_date,\n                end_date: dataWithoutId.end_date,\n                days_count: dataWithoutId.days_count,\n                description: dataWithoutId.description,\n                stand_back_days_required: dataWithoutId.stand_back_days_required,\n                stand_back_days_completed: dataWithoutId.stand_back_days_completed,\n                stand_back_days_remaining: dataWithoutId.stand_back_days_remaining,\n                stand_back_status: dataWithoutId.stand_back_status,\n                stand_back_history: dataWithoutId.stand_back_history || []\n            };\n            // Add optional fields if they exist (for backward compatibility)\n            if (dataWithoutId.reason) {\n                dataToInsert.reason = dataWithoutId.reason;\n            }\n            if (dataWithoutId.notes) {\n                dataToInsert.notes = dataWithoutId.notes;\n            }\n            console.log('Data to insert (with generated UUID):', dataToInsert);\n            console.log('Data to insert JSON:', JSON.stringify(dataToInsert, null, 2));\n            // Validate required fields\n            const requiredFields = [\n                'id',\n                'crew_member_id',\n                'start_date',\n                'end_date',\n                'days_count',\n                'stand_back_days_required',\n                'stand_back_days_completed',\n                'stand_back_days_remaining',\n                'stand_back_status'\n            ];\n            const missingFields = requiredFields.filter((field)=>!dataToInsert[field] && dataToInsert[field] !== 0);\n            if (missingFields.length > 0) {\n                console.error('Missing required fields:', missingFields);\n                throw new Error(\"Missing required fields: \".concat(missingFields.join(', ')));\n            }\n            console.log('All required fields present, inserting to database...');\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('stand_back_records').insert([\n                dataToInsert\n            ]).select();\n            if (error) {\n                console.error('âŒ Supabase error adding stand back record:', error);\n                console.error('âŒ Error details:', JSON.stringify(error, null, 2));\n                console.error('âŒ Error code:', error.code);\n                console.error('âŒ Error message:', error.message);\n                console.error('âŒ Error hint:', error.hint);\n                throw error;\n            }\n            console.log('âœ… Stand back record added successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('âŒ Error adding stand back record:', err);\n            console.error('âŒ Error details:', JSON.stringify(err, null, 2));\n            throw err;\n        }\n    };\n    const updateStandBackRecord = async (recordId, updates)=>{\n        try {\n            console.log('Updating stand back record in Supabase:', recordId, updates);\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('stand_back_records').update(updates).eq('id', recordId).select();\n            if (error) {\n                console.error('Supabase error updating stand back record:', error);\n                throw error;\n            }\n            console.log('Stand back record updated successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error updating stand back record:', err);\n            throw err;\n        }\n    };\n    const addLoan = async (loanData)=>{\n        try {\n            console.log('Adding loan to Supabase:', loanData);\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('loans').insert([\n                loanData\n            ]).select();\n            if (error) {\n                console.error('Supabase error adding loan:', error);\n                throw error;\n            }\n            console.log('Loan added successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error adding loan:', err);\n            throw err;\n        }\n    };\n    const completeLoan = async (loanId, notes)=>{\n        try {\n            console.log('Completing loan in Supabase:', loanId);\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('loans').update({\n                status: 'voltooid',\n                completed_at: new Date().toISOString(),\n                notes: notes || \"\"\n            }).eq('id', loanId).select();\n            if (error) {\n                console.error('Supabase error completing loan:', error);\n                throw error;\n            }\n            console.log('Loan completed successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error completing loan:', err);\n            throw err;\n        }\n    };\n    const makePayment = async (loanId, paymentAmount, note)=>{\n        try {\n            console.log('Making payment for loan:', loanId, paymentAmount);\n            // First, get the current loan\n            const { data: loan, error: fetchError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('loans').select('*').eq('id', loanId).single();\n            if (fetchError || !loan) {\n                throw new Error('Loan not found');\n            }\n            // Calculate new values\n            const newPaid = (loan.amount_paid || 0) + paymentAmount;\n            const newRemaining = loan.amount - newPaid;\n            const newStatus = newRemaining <= 0 ? 'voltooid' : 'open';\n            // Create payment history entry\n            const paymentEntry = {\n                date: new Date().toISOString(),\n                amount: paymentAmount,\n                note: note || 'Betaling afgetekend',\n                paidBy: 'User'\n            };\n            // Update loan\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('loans').update({\n                amount_paid: newPaid,\n                amount_remaining: newRemaining,\n                status: newStatus,\n                completed_at: newStatus === 'voltooid' ? new Date().toISOString() : null,\n                payment_history: [\n                    ...loan.payment_history || [],\n                    paymentEntry\n                ]\n            }).eq('id', loanId).select();\n            if (error) {\n                console.error('Supabase error making payment:', error);\n                throw error;\n            }\n            console.log('Payment made successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error making payment:', err);\n            throw err;\n        }\n    };\n    // Trip functions\n    const addTrip = async (tripData)=>{\n        try {\n            console.log('Adding trip:', tripData);\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('trips').insert([\n                tripData\n            ]).select();\n            if (error) {\n                console.error('Error adding trip:', error);\n                throw error;\n            }\n            console.log('Trip added successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error adding trip:', err);\n            throw err;\n        }\n    };\n    const updateTrip = async (tripId, updates)=>{\n        try {\n            console.log('Updating trip:', tripId, updates);\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('trips').update({\n                ...updates,\n                updated_at: new Date().toISOString()\n            }).eq('id', tripId).select().single();\n            if (error) {\n                console.error('Error updating trip:', error);\n                throw error;\n            }\n            console.log('Trip updated successfully:', data);\n            // If trip is completed, auto-update vaste dienst records\n            if (updates.status === 'voltooid' && data.aflosser_id) {\n                console.log('ðŸš€ Trip completed - auto-updating vaste dienst records');\n                await autoUpdateVasteDienstFromTrip(data);\n            }\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error updating trip:', err);\n            throw err;\n        }\n    };\n    // Vaste dienst functions\n    const addVasteDienstRecord = async (recordData)=>{\n        try {\n            console.log('Adding vaste dienst record:', recordData);\n            console.log('Record data details:', JSON.stringify(recordData, null, 2));\n            // Validate required fields\n            const requiredFields = [\n                'aflosser_id',\n                'year',\n                'month',\n                'required_days',\n                'actual_days',\n                'balance_days'\n            ];\n            const missingFields = requiredFields.filter((field)=>recordData[field] === undefined || recordData[field] === null);\n            if (missingFields.length > 0) {\n                const error = new Error(\"Missing required fields: \".concat(missingFields.join(', ')));\n                console.error('Validation error:', error);\n                throw error;\n            }\n            // Check if record already exists for this aflosser/year/month combination\n            const { data: existingRecord, error: checkError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').select('id').eq('aflosser_id', recordData.aflosser_id).eq('year', recordData.year).eq('month', recordData.month).single();\n            if (existingRecord) {\n                console.log('Record already exists for this aflosser/year/month combination, updating instead');\n                // Update existing record instead of creating new one\n                const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').update({\n                    required_days: recordData.required_days,\n                    actual_days: recordData.actual_days,\n                    balance_days: recordData.balance_days,\n                    updated_at: new Date().toISOString()\n                }).eq('id', existingRecord.id).select();\n                if (error) {\n                    console.error('Error updating existing vaste dienst record:', error);\n                    throw error;\n                }\n                console.log('Vaste dienst record updated successfully:', data);\n                await loadData() // Reload all data\n                ;\n                return data;\n            }\n            // If no existing record, create new one\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').insert([\n                recordData\n            ]).select();\n            if (error) {\n                console.error('Supabase error adding vaste dienst record:', error);\n                console.error('Error details:', JSON.stringify(error, null, 2));\n                console.error('Error code:', error.code);\n                console.error('Error message:', error.message);\n                console.error('Error hint:', error.hint);\n                throw error;\n            }\n            console.log('Vaste dienst record added successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error adding vaste dienst record:', err);\n            console.error('Error details:', JSON.stringify(err, null, 2));\n            throw err;\n        }\n    };\n    const updateVasteDienstRecord = async (recordId, updates)=>{\n        try {\n            console.log('Updating vaste dienst record:', recordId, updates);\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').update({\n                ...updates,\n                updated_at: new Date().toISOString()\n            }).eq('id', recordId).select().single();\n            if (error) {\n                console.error('Error updating vaste dienst record:', error);\n                throw error;\n            }\n            console.log('Vaste dienst record updated successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error updating vaste dienst record:', err);\n            throw err;\n        }\n    };\n    const deleteVasteDienstRecord = async (recordId)=>{\n        try {\n            console.log('Deleting vaste dienst record:', recordId);\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').delete().eq('id', recordId);\n            if (error) {\n                console.error('Error deleting vaste dienst record:', error);\n                throw error;\n            }\n            console.log('Vaste dienst record deleted successfully');\n            await loadData() // Reload all data\n            ;\n        } catch (err) {\n            console.error('Error deleting vaste dienst record:', err);\n            throw err;\n        }\n    };\n    // Delete trip permanently\n    const deleteTrip = async (tripId)=>{\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('trips').delete().eq('id', tripId);\n            if (error) {\n                console.error('Supabase error deleting trip:', error);\n                throw error;\n            }\n            console.log('Trip deleted successfully');\n            await loadData() // Reload all data\n            ;\n        } catch (err) {\n            console.error('Error deleting trip:', err);\n            throw err;\n        }\n    };\n    // Delete aflosser permanently\n    const deleteAflosser = async (aflosserId)=>{\n        try {\n            // First delete all related records\n            await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').delete().eq('aflosser_id', aflosserId);\n            await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('trips').delete().eq('aflosser_id', aflosserId);\n            // Then delete the aflosser\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').delete().eq('id', aflosserId);\n            if (error) {\n                console.error('Supabase error deleting aflosser:', error);\n                throw error;\n            }\n            console.log('Aflosser deleted successfully');\n            await loadData() // Reload all data\n            ;\n        } catch (err) {\n            console.error('Error deleting aflosser:', err);\n            throw err;\n        }\n    };\n    // Notes functions\n    const addNoteToCrew = async (crewId, note)=>{\n        try {\n            // Get current crew member data\n            const { data: crewData, error: fetchError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').select('active_notes').eq('id', crewId).single();\n            if (fetchError) throw fetchError;\n            // Parse existing notes or initialize empty array\n            const currentNotes = (crewData === null || crewData === void 0 ? void 0 : crewData.active_notes) || [];\n            // Add new note with timestamp\n            const newNote = {\n                id: Date.now().toString(),\n                content: note,\n                createdAt: new Date().toISOString(),\n                createdBy: 'user' // You could get this from auth context\n            };\n            const updatedNotes = [\n                ...currentNotes,\n                newNote\n            ];\n            // Update crew member with new notes\n            const { error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').update({\n                active_notes: updatedNotes\n            }).eq('id', crewId);\n            if (updateError) throw updateError;\n            console.log('Note added successfully');\n            await loadData(); // Reload data\n        } catch (error) {\n            console.error('Error adding note:', error);\n            throw error;\n        }\n    };\n    const removeNoteFromCrew = async (crewId, noteId)=>{\n        try {\n            // Get current crew member data\n            const { data: crewData, error: fetchError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').select('active_notes, archived_notes').eq('id', crewId).single();\n            if (fetchError) throw fetchError;\n            const currentActiveNotes = (crewData === null || crewData === void 0 ? void 0 : crewData.active_notes) || [];\n            const currentArchivedNotes = (crewData === null || crewData === void 0 ? void 0 : crewData.archived_notes) || [];\n            // Find the note to remove\n            const noteToArchive = currentActiveNotes.find((note)=>note.id === noteId);\n            if (!noteToArchive) {\n                throw new Error('Note not found');\n            }\n            // Remove from active notes\n            const updatedActiveNotes = currentActiveNotes.filter((note)=>note.id !== noteId);\n            // Add to archived notes with archive timestamp\n            const archivedNote = {\n                ...noteToArchive,\n                archivedAt: new Date().toISOString()\n            };\n            const updatedArchivedNotes = [\n                ...currentArchivedNotes,\n                archivedNote\n            ];\n            // Update crew member\n            const { error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').update({\n                active_notes: updatedActiveNotes,\n                archived_notes: updatedArchivedNotes\n            }).eq('id', crewId);\n            if (updateError) throw updateError;\n            console.log('Note archived successfully');\n            await loadData(); // Reload data\n        } catch (error) {\n            console.error('Error removing note:', error);\n            throw error;\n        }\n    };\n    // Add task\n    const addTask = async (taskData)=>{\n        try {\n            console.log('ðŸ“ Adding task with data:', JSON.stringify(taskData, null, 2));\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('tasks').insert([\n                taskData\n            ]).select().single();\n            if (error) {\n                console.error('âŒ Supabase error adding task:', error);\n                console.error('âŒ Error code:', error.code);\n                console.error('âŒ Error message:', error.message);\n                console.error('âŒ Error details:', error.details);\n                console.error('âŒ Error hint:', error.hint);\n                throw error;\n            }\n            await loadData();\n            return data;\n        } catch (err) {\n            console.error('Error adding task:', err);\n            console.error('Error details:', JSON.stringify(err, null, 2));\n            throw err;\n        }\n    };\n    // Update task\n    const updateTask = async (taskId, updates)=>{\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('tasks').update(updates).eq('id', taskId);\n            if (error) throw error;\n            await loadData();\n        } catch (err) {\n            console.error('Error updating task:', err);\n            throw err;\n        }\n    };\n    // Delete task\n    const deleteTask = async (taskId)=>{\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('tasks').delete().eq('id', taskId);\n            if (error) throw error;\n            await loadData();\n        } catch (err) {\n            console.error('Error deleting task:', err);\n            throw err;\n        }\n    };\n    // Complete task\n    const completeTask = async (taskId)=>{\n        try {\n            // Haal eerst de gerelateerde ship_visit op (als die bestaat)\n            const { data: taskData, error: fetchError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('tasks').select('id, related_ship_visit_id').eq('id', taskId).single();\n            if (fetchError) throw fetchError;\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('tasks').update({\n                completed: true,\n                completed_at: new Date().toISOString()\n            }).eq('id', taskId);\n            if (error) throw error;\n            // Als deze taak gekoppeld is aan een scheepsbezoek, zet daar de follow-up uit\n            if (taskData === null || taskData === void 0 ? void 0 : taskData.related_ship_visit_id) {\n                try {\n                    const { error: visitError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('ship_visits').update({\n                        follow_up_needed: false,\n                        follow_up_notes: null\n                    }).eq('id', taskData.related_ship_visit_id);\n                    if (visitError) {\n                        console.error('Error updating related ship_visit after completing task:', visitError);\n                    }\n                } catch (innerErr) {\n                    console.error('Unexpected error updating ship_visit for completed task:', innerErr);\n                }\n            }\n            await loadData();\n        } catch (err) {\n            console.error('Error completing task:', err);\n            throw err;\n        }\n    };\n    // Add incident\n    const addIncident = async (incidentData)=>{\n        try {\n            console.log('ðŸ“ Adding incident with data:', JSON.stringify(incidentData, null, 2));\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('incidents').insert([\n                incidentData\n            ]).select().single();\n            if (error) {\n                console.error('âŒ Supabase error adding incident:', error);\n                console.error('âŒ Error code:', error.code);\n                console.error('âŒ Error message:', error.message);\n                console.error('âŒ Error details:', error.details);\n                console.error('âŒ Error hint:', error.hint);\n                throw error;\n            }\n            await loadData();\n            return data;\n        } catch (err) {\n            console.error('Error adding incident:', err);\n            console.error('Error details:', JSON.stringify(err, null, 2));\n            throw err;\n        }\n    };\n    // Update incident\n    const updateIncident = async (incidentId, updates)=>{\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('incidents').update(updates).eq('id', incidentId);\n            if (error) throw error;\n            await loadData();\n        } catch (err) {\n            console.error('Error updating incident:', err);\n            throw err;\n        }\n    };\n    // Delete incident\n    const deleteIncident = async (incidentId)=>{\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('incidents').delete().eq('id', incidentId);\n            if (error) throw error;\n            await loadData();\n        } catch (err) {\n            console.error('Error deleting incident:', err);\n            throw err;\n        }\n    };\n    return {\n        ships,\n        crew,\n        sickLeave,\n        standBackRecords,\n        loans,\n        trips,\n        tasks,\n        incidents,\n        loading,\n        error,\n        loadData,\n        crewColorTags,\n        async setCrewColorTag (crewId, color) {\n            try {\n                if (!crewId) return;\n                if (color) {\n                    // upsert color\n                    const { error: upsertError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew_color_tags').upsert({\n                        crew_id: crewId,\n                        color\n                    }, {\n                        onConflict: 'crew_id'\n                    });\n                    if (upsertError) throw upsertError;\n                } else {\n                    // delete color\n                    const { error: delError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew_color_tags').delete().eq('crew_id', crewId);\n                    if (delError) throw delError;\n                }\n                // update local state\n                setCrewColorTags((prev)=>{\n                    const next = {\n                        ...prev\n                    };\n                    if (color) next[crewId] = color;\n                    else delete next[crewId];\n                    return next;\n                });\n            } catch (e) {\n                const err = e;\n                const msg = (err === null || err === void 0 ? void 0 : err.message) || (typeof err === 'string' ? err : JSON.stringify(err));\n                console.error('Error setting crew color tag:', msg);\n                // If table missing, surface a clear hint once\n                if ((msg === null || msg === void 0 ? void 0 : msg.includes('relation')) && (msg === null || msg === void 0 ? void 0 : msg.includes('crew_color_tags'))) {\n                    console.warn('Hint: create table crew_color_tags (crew_id uuid primary key references crew(id), color text not null)');\n                }\n                throw e;\n            }\n        },\n        addCrew,\n        updateCrew,\n        deleteCrew,\n        addShip,\n        updateShip,\n        deleteShip,\n        addSickLeave,\n        updateSickLeave,\n        addStandBackRecord,\n        updateStandBackRecord,\n        addLoan,\n        completeLoan,\n        makePayment,\n        addTrip,\n        updateTrip,\n        deleteTrip,\n        deleteAflosser,\n        vasteDienstRecords,\n        addVasteDienstRecord,\n        updateVasteDienstRecord,\n        deleteVasteDienstRecord,\n        addNoteToCrew,\n        removeNoteFromCrew,\n        addTask,\n        updateTask,\n        deleteTask,\n        completeTask,\n        addIncident,\n        updateIncident,\n        deleteIncident\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZS1zdXBhYmFzZS1kYXRhLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUEyQztBQUNGO0FBRXpDLDRFQUE0RTtBQUM1RSxtRUFBbUU7QUFDNUQsU0FBU0csNkJBQTZCQyxTQUFpQixFQUFFQyxTQUFpQixFQUFFQyxPQUFlLEVBQUVDLE9BQWU7SUFDakgsSUFBSSxDQUFDSCxhQUFhLENBQUNFLFdBQVcsQ0FBQ0QsYUFBYSxDQUFDRSxTQUFTLE9BQU87SUFFN0QsNkNBQTZDO0lBQzdDLE1BQU1DLFlBQVksQ0FBQ0M7UUFDakIsSUFBSSxDQUFDQSxXQUFXLE9BQU9BLFlBQVksVUFBVTtZQUMzQ0MsUUFBUUMsS0FBSyxDQUFDLHdCQUF3QkY7WUFDdEMsT0FBTyxJQUFJRyxPQUFPLGtDQUFrQzs7UUFDdEQ7UUFFQSw4RUFBOEU7UUFDOUUsSUFBSUgsUUFBUUksUUFBUSxDQUFDLFFBQVEscUJBQXFCQyxJQUFJLENBQUNMLFVBQVU7WUFDL0QsNENBQTRDO1lBQzVDLE1BQU1NLE9BQU8sSUFBSUgsS0FBS0g7WUFDdEIsSUFBSU8sTUFBTUQsS0FBS0UsT0FBTyxLQUFLO2dCQUN6QlAsUUFBUUMsS0FBSyxDQUFDLHFCQUFxQkY7Z0JBQ25DLE9BQU8sSUFBSUcsT0FBTyxrQ0FBa0M7O1lBQ3REO1lBQ0EsT0FBT0c7UUFDVDtRQUVBLHdDQUF3QztRQUN4QyxNQUFNRyxRQUFRVCxRQUFRVSxLQUFLLENBQUM7UUFDNUIsSUFBSUQsTUFBTUUsTUFBTSxLQUFLLEdBQUc7WUFDdEJWLFFBQVFDLEtBQUssQ0FBQyx3QkFBd0JGO1lBQ3RDLE9BQU8sSUFBSUcsT0FBTyxrQ0FBa0M7O1FBQ3REO1FBRUEsTUFBTVMsTUFBTUMsU0FBU0osS0FBSyxDQUFDLEVBQUUsRUFBRTtRQUMvQixNQUFNSyxRQUFRRCxTQUFTSixLQUFLLENBQUMsRUFBRSxFQUFFLE1BQU0sRUFBRSxnQ0FBZ0M7O1FBQ3pFLE1BQU1NLE9BQU9GLFNBQVNKLEtBQUssQ0FBQyxFQUFFLEVBQUU7UUFFaEMsTUFBTUgsT0FBTyxJQUFJSCxLQUFLWSxNQUFNRCxPQUFPRjtRQUNuQyxJQUFJTCxNQUFNRCxLQUFLRSxPQUFPLEtBQUs7WUFDekJQLFFBQVFDLEtBQUssQ0FBQyx3QkFBd0JGO1lBQ3RDLE9BQU8sSUFBSUcsT0FBTyxrQ0FBa0M7O1FBQ3REO1FBRUEsT0FBT0c7SUFDVDtJQUVBLCtDQUErQztJQUMvQyxNQUFNVSxZQUFZLENBQUNDO1FBQ2pCLElBQUksQ0FBQ0EsV0FBVyxPQUFPQSxZQUFZLFVBQVU7WUFDM0NoQixRQUFRQyxLQUFLLENBQUMsd0JBQXdCZTtZQUN0QyxPQUFPO1FBQ1Q7UUFFQSxNQUFNQyxZQUFZRCxRQUFRUCxLQUFLLENBQUM7UUFDaEMsSUFBSVEsVUFBVVAsTUFBTSxHQUFHLEdBQUc7WUFDeEJWLFFBQVFDLEtBQUssQ0FBQyx3QkFBd0JlO1lBQ3RDLE9BQU87UUFDVDtRQUVBLE1BQU1FLFFBQVFOLFNBQVNLLFNBQVMsQ0FBQyxFQUFFLEVBQUU7UUFDckMsTUFBTUUsVUFBVVAsU0FBU0ssU0FBUyxDQUFDLEVBQUUsRUFBRTtRQUV2QyxJQUFJWCxNQUFNWSxVQUFVWixNQUFNYSxVQUFVO1lBQ2xDbkIsUUFBUUMsS0FBSyxDQUFDLHdCQUF3QmU7WUFDdEMsT0FBTztRQUNUO1FBRUEsT0FBT0UsUUFBU0MsVUFBVTtJQUM1QjtJQUVBLE1BQU1DLFFBQVF0QixVQUFVSjtJQUN4QixNQUFNMkIsTUFBTXZCLFVBQVVGO0lBQ3RCLE1BQU0wQixpQkFBaUJQLFVBQVVwQjtJQUNqQyxNQUFNNEIsZUFBZVIsVUFBVWxCO0lBRS9CLElBQUl3QixNQUFNRCxPQUFPO1FBQ2ZwQixRQUFRQyxLQUFLLENBQUM7UUFDZCxPQUFPO0lBQ1Q7SUFFQSwrQkFBK0I7SUFDL0IsTUFBTXVCLGdCQUFnQixJQUFJdEIsS0FBS2tCO0lBQy9CSSxjQUFjQyxRQUFRLENBQUNDLEtBQUtDLEtBQUssQ0FBQ0wsaUJBQWlCLGlCQUFrQixJQUFLLElBQUksR0FBRztJQUVqRixNQUFNTSxjQUFjLElBQUkxQixLQUFLbUI7SUFDN0JPLFlBQVlILFFBQVEsQ0FBQ0MsS0FBS0MsS0FBSyxDQUFDSixlQUFlLGVBQWdCLElBQUssSUFBSSxHQUFHO0lBRTNFLDhCQUE4QjtJQUM5QixNQUFNTSxhQUFhRCxZQUFZckIsT0FBTyxLQUFLaUIsY0FBY2pCLE9BQU87SUFDaEUsTUFBTXVCLGFBQWFELGFBQWMsUUFBTyxLQUFLLEVBQUM7SUFFOUMsa0RBQWtEO0lBQ2xELDRDQUE0QztJQUM1QyxNQUFNRSxhQUFhTCxLQUFLTSxJQUFJLENBQUNGLGFBQWEsTUFBTTtJQUVoRCxPQUFPQztBQUNUO0FBRUEscUVBQXFFO0FBQ3JFLGVBQWVFLHdCQUF3QkMsUUFBZTtJQUNwRCxNQUFNQyxRQUFRLElBQUlqQztJQUNsQmlDLE1BQU1WLFFBQVEsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLDhCQUE4Qjs7SUFFekQsS0FBSyxNQUFNVyxVQUFVRixTQUFVO1FBQzdCLGdEQUFnRDtRQUNoRCx3RUFBd0U7UUFDeEUsSUFDRSxDQUFDRSxPQUFPQyxNQUFNLEtBQUssV0FBV0QsT0FBT0MsTUFBTSxLQUFLLGlCQUFnQixLQUNoRUQsT0FBT0UsbUJBQW1CLElBQzFCRixPQUFPRyxPQUFPLElBQ2RILE9BQU9JLE1BQU0sRUFDYjtZQUNBLE1BQU05QyxZQUFZLElBQUlRLEtBQUtrQyxPQUFPRSxtQkFBbUI7WUFDckQ1QyxVQUFVK0IsUUFBUSxDQUFDLEdBQUcsR0FBRyxHQUFHO1lBRTVCLDRCQUE0QjtZQUM1QixJQUFJVSxTQUFTekMsV0FBVztnQkFDdEJNLFFBQVF5QyxHQUFHLENBQUMsZ0NBQTJDTCxPQUFyQkEsT0FBT00sVUFBVSxFQUFDLEtBQW9CLE9BQWpCTixPQUFPTyxTQUFTLEVBQUM7Z0JBRXhFLElBQUk7b0JBQ0YsaUNBQWlDO29CQUNqQyxNQUFNLEVBQUUxQyxLQUFLLEVBQUUsR0FBRyxNQUFNVCxtREFBUUEsQ0FDN0JvRCxJQUFJLENBQUMsUUFDTEMsTUFBTSxDQUFDO3dCQUNOUixRQUFRO3dCQUNSUyxnQkFBZ0JWLE9BQU9FLG1CQUFtQjt3QkFDMUNTLGFBQWE7d0JBQ2JULHFCQUFxQjt3QkFDckJVLFlBQVksS0FBSyxtQkFBbUI7b0JBQ3RDLEdBQ0NDLEVBQUUsQ0FBQyxNQUFNYixPQUFPYyxFQUFFO29CQUVyQixJQUFJakQsT0FBTzt3QkFDVEQsUUFBUUMsS0FBSyxDQUFDLHNDQUFzQ0E7b0JBQ3RELE9BQU87d0JBQ0xELFFBQVF5QyxHQUFHLENBQUMsS0FBMEJMLE9BQXJCQSxPQUFPTSxVQUFVLEVBQUMsS0FBb0IsT0FBakJOLE9BQU9PLFNBQVMsRUFBQztvQkFDekQ7Z0JBQ0YsRUFBRSxPQUFPUSxLQUFLO29CQUNabkQsUUFBUUMsS0FBSyxDQUFDLDZCQUE2QmtEO2dCQUM3QztZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsZ0RBQWdEO0FBQ2hELGVBQWVDLHNCQUFzQmxCLFFBQWU7SUFDbEQsTUFBTUMsUUFBUSxJQUFJakM7SUFDbEJpQyxNQUFNVixRQUFRLENBQUMsR0FBRyxHQUFHLEdBQUc7SUFFeEIsS0FBSyxNQUFNVyxVQUFVRixTQUFVO1FBQzdCLDBDQUEwQztRQUMxQyxJQUFJLENBQUNFLE9BQU9JLE1BQU0sSUFBSUosT0FBT0MsTUFBTSxLQUFLLFVBQVVELE9BQU9JLE1BQU0sS0FBSyxVQUFVO1lBQzVFO1FBQ0Y7UUFFQSxNQUFNYSxjQUFjekMsU0FBU3dCLE9BQU9JLE1BQU0sQ0FBQy9CLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUN4RCxNQUFNNkMsYUFBYUQsY0FBYztRQUVqQyxnREFBZ0Q7UUFDaEQsSUFBSWpCLE9BQU9DLE1BQU0sS0FBSyxlQUFlRCxPQUFPVSxjQUFjLEVBQUU7WUFDMUQsTUFBTVMsY0FBYyxJQUFJckQsS0FBS2tDLE9BQU9VLGNBQWM7WUFDbERTLFlBQVk5QixRQUFRLENBQUMsR0FBRyxHQUFHLEdBQUc7WUFFOUIsTUFBTStCLG1CQUFtQjlCLEtBQUtDLEtBQUssQ0FBQyxDQUFDUSxNQUFNNUIsT0FBTyxLQUFLZ0QsWUFBWWhELE9BQU8sRUFBQyxJQUFNLFFBQU8sS0FBSyxLQUFLLEVBQUM7WUFFbkcsSUFBSWlELG9CQUFvQkYsWUFBWTtnQkFDbEMsTUFBTUcsYUFBYSxJQUFJdkQsS0FBS3FEO2dCQUM1QkUsV0FBV0MsT0FBTyxDQUFDRCxXQUFXRSxPQUFPLEtBQUtMO2dCQUUxQ3RELFFBQVF5QyxHQUFHLENBQUMsOEJBQXlDTCxPQUFyQkEsT0FBT00sVUFBVSxFQUFDLEtBQW9CLE9BQWpCTixPQUFPTyxTQUFTLEVBQUM7Z0JBRXRFLElBQUk7b0JBQ0YsTUFBTSxFQUFFMUMsS0FBSyxFQUFFLEdBQUcsTUFBTVQsbURBQVFBLENBQzdCb0QsSUFBSSxDQUFDLFFBQ0xDLE1BQU0sQ0FBQzt3QkFDTlIsUUFBUTt3QkFDUlUsYUFBYVUsV0FBV0csV0FBVyxHQUFHbkQsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO3dCQUNuRHFDLGdCQUFnQjtvQkFDbEIsR0FDQ0csRUFBRSxDQUFDLE1BQU1iLE9BQU9jLEVBQUU7b0JBRXJCLElBQUlqRCxPQUFPO3dCQUNURCxRQUFRQyxLQUFLLENBQUMsNEJBQTRCQTtvQkFDNUMsT0FBTzt3QkFDTEQsUUFBUXlDLEdBQUcsQ0FBQyxLQUF1QixPQUFsQkwsT0FBT00sVUFBVSxFQUFDO29CQUNyQztnQkFDRixFQUFFLE9BQU9TLEtBQUs7b0JBQ1puRCxRQUFRQyxLQUFLLENBQUMsc0JBQXNCa0Q7Z0JBQ3RDO1lBQ0Y7UUFDRjtRQUVBLGdEQUFnRDtRQUNoRCxJQUFJZixPQUFPQyxNQUFNLEtBQUssV0FBV0QsT0FBT1csV0FBVyxFQUFFO1lBQ25ELE1BQU1jLFlBQVksSUFBSTNELEtBQUtrQyxPQUFPVyxXQUFXO1lBQzdDYyxVQUFVcEMsUUFBUSxDQUFDLEdBQUcsR0FBRyxHQUFHO1lBRTVCLE1BQU1xQyxpQkFBaUJwQyxLQUFLQyxLQUFLLENBQUMsQ0FBQ1EsTUFBTTVCLE9BQU8sS0FBS3NELFVBQVV0RCxPQUFPLEVBQUMsSUFBTSxRQUFPLEtBQUssS0FBSyxFQUFDO1lBRS9GLElBQUl1RCxrQkFBa0JSLFlBQVk7Z0JBQ2hDLE1BQU1TLGVBQWUsSUFBSTdELEtBQUsyRDtnQkFDOUJFLGFBQWFMLE9BQU8sQ0FBQ0ssYUFBYUosT0FBTyxLQUFLTDtnQkFFOUN0RCxRQUFReUMsR0FBRyxDQUFDLDhCQUF5Q0wsT0FBckJBLE9BQU9NLFVBQVUsRUFBQyxLQUFvQixPQUFqQk4sT0FBT08sU0FBUyxFQUFDO2dCQUV0RSxJQUFJO29CQUNGLE1BQU0sRUFBRTFDLEtBQUssRUFBRSxHQUFHLE1BQU1ULG1EQUFRQSxDQUM3Qm9ELElBQUksQ0FBQyxRQUNMQyxNQUFNLENBQUM7d0JBQ05SLFFBQVE7d0JBQ1JTLGdCQUFnQmlCLGFBQWFILFdBQVcsR0FBR25ELEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTt3QkFDeERzQyxhQUFhO29CQUNmLEdBQ0NFLEVBQUUsQ0FBQyxNQUFNYixPQUFPYyxFQUFFO29CQUVyQixJQUFJakQsT0FBTzt3QkFDVEQsUUFBUUMsS0FBSyxDQUFDLGdDQUFnQ0E7b0JBQ2hELE9BQU87d0JBQ0xELFFBQVF5QyxHQUFHLENBQUMsS0FBdUIsT0FBbEJMLE9BQU9NLFVBQVUsRUFBQztvQkFDckM7Z0JBQ0YsRUFBRSxPQUFPUyxLQUFLO29CQUNabkQsUUFBUUMsS0FBSyxDQUFDLHNCQUFzQmtEO2dCQUN0QztZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBRUEseURBQXlEO0FBQ3pELGVBQWVhLDZCQUE2QjlCLFFBQWUsRUFBRStCLGtCQUF5QixFQUFFQyxTQUFnQjtJQUN0RyxNQUFNL0IsUUFBUSxJQUFJakM7SUFDbEIsTUFBTWlFLGNBQWNoQyxNQUFNaUMsV0FBVztJQUNyQyxNQUFNQyxlQUFlbEMsTUFBTW1DLFFBQVEsS0FBSyxFQUFFLGdDQUFnQzs7SUFFMUV0RSxRQUFReUMsR0FBRyxDQUFDLHVEQUE0RDRCLE9BQWZGLGFBQVksS0FBZ0IsT0FBYkU7SUFFeEUsb0NBQW9DO0lBQ3BDLE1BQU1FLHVCQUF1QnJDLFNBQVNzQyxNQUFNLENBQUNwQyxDQUFBQSxTQUFVQSxPQUFPcUMsWUFBWSxLQUFLO0lBRS9FLEtBQUssTUFBTUMsWUFBWUgscUJBQXNCO1FBQzNDdkUsUUFBUXlDLEdBQUcsQ0FBQyxrREFBK0RpQyxPQUF2QkEsU0FBU2hDLFVBQVUsRUFBQyxLQUFzQixPQUFuQmdDLFNBQVMvQixTQUFTO1FBRTdGLHVDQUF1QztRQUN2QyxNQUFNZ0MsaUJBQWlCVixtQkFBbUJXLElBQUksQ0FBQ0MsQ0FBQUEsU0FDN0NBLE9BQU9DLFdBQVcsS0FBS0osU0FBU3hCLEVBQUUsSUFDbEMyQixPQUFPL0QsSUFBSSxLQUFLcUQsZUFDaEJVLE9BQU9oRSxLQUFLLEtBQUt3RDtRQUduQixJQUFJLENBQUNNLGdCQUFnQjtZQUNuQiw0QkFBNEI7WUFDNUIzRSxRQUFReUMsR0FBRyxDQUFDLGdEQUE2RGlDLE9BQXZCQSxTQUFTaEMsVUFBVSxFQUFDLEtBQXNCLE9BQW5CZ0MsU0FBUy9CLFNBQVM7WUFFM0YsSUFBSTtnQkFDRixNQUFNb0MsWUFBWTtvQkFDaEJELGFBQWFKLFNBQVN4QixFQUFFO29CQUN4QnBDLE1BQU1xRDtvQkFDTnRELE9BQU93RDtvQkFDUFcsZUFBZTtvQkFDZkMsYUFBYTtvQkFDYkMsY0FBYztvQkFDZEMsT0FBTywrQkFBOENkLE9BQWZGLGFBQVksS0FBZ0IsT0FBYkU7Z0JBQ3ZEO2dCQUVBLE1BQU0sRUFBRWUsSUFBSSxFQUFFbkYsS0FBSyxFQUFFLEdBQUcsTUFBTVQsbURBQVFBLENBQ25Db0QsSUFBSSxDQUFDLHdCQUNMeUMsTUFBTSxDQUFDO29CQUFDTjtpQkFBVSxFQUNsQk8sTUFBTSxHQUNOQyxNQUFNO2dCQUVULElBQUl0RixPQUFPO29CQUNURCxRQUFRQyxLQUFLLENBQUMsdUNBQXVDQTtnQkFDdkQsT0FBTztvQkFDTEQsUUFBUXlDLEdBQUcsQ0FBQyxnQ0FBb0QsT0FBcEJpQyxTQUFTaEMsVUFBVTtnQkFDakU7WUFDRixFQUFFLE9BQU9TLEtBQUs7Z0JBQ1puRCxRQUFRQyxLQUFLLENBQUMsMENBQTBDa0Q7WUFDMUQ7UUFDRjtRQUVBLCtEQUErRDtRQUMvRCxNQUFNcUMsb0JBQW9CdEIsVUFBVU0sTUFBTSxDQUFDaUIsQ0FBQUEsT0FDekNBLEtBQUtYLFdBQVcsS0FBS0osU0FBU3hCLEVBQUUsSUFDaEN1QyxLQUFLcEQsTUFBTSxLQUFLLGNBQ2hCb0QsS0FBS0MsVUFBVSxJQUNmLElBQUl4RixLQUFLdUYsS0FBS0MsVUFBVSxFQUFFdEIsV0FBVyxPQUFPRCxlQUM1QyxJQUFJakUsS0FBS3VGLEtBQUtDLFVBQVUsRUFBRXBCLFFBQVEsS0FBSyxNQUFNRDtRQUcvQyxJQUFJc0IsZ0JBQWdCO1FBQ3BCLEtBQUssTUFBTUYsUUFBUUQsa0JBQW1CO1lBQ3BDLE1BQU1JLFdBQVdDLGtCQUFrQkosS0FBS0ssV0FBVyxFQUFFTCxLQUFLTSxVQUFVLEVBQUVOLEtBQUtDLFVBQVUsRUFBRUQsS0FBS08sU0FBUztZQUNyR0wsaUJBQWlCQztRQUNuQjtRQUVBLGlEQUFpRDtRQUNqRCxJQUFJakIsZ0JBQWdCO1lBQ2xCLE1BQU1zQixlQUFlO1lBRXJCLCtEQUErRDtZQUMvRCxtREFBbUQ7WUFDbkQsSUFBSUMsYUFBYXZCLGVBQWVPLFlBQVksSUFBSTtZQUVoRCxnRkFBZ0Y7WUFDaEYsSUFBSWdCLGVBQWUsS0FBSzdCLGlCQUFpQixHQUFHO29CQUVuQks7Z0JBRHZCLHdDQUF3QztnQkFDeEMsTUFBTXlCLGtCQUFpQnpCLGtCQUFBQSxTQUFTUyxLQUFLLGNBQWRULHNDQUFBQSxnQkFBZ0JFLElBQUksQ0FBQyxDQUFDd0IsT0FDM0NBLEtBQUtDLElBQUksSUFBS0QsQ0FBQUEsS0FBS0MsSUFBSSxDQUFDbEcsUUFBUSxDQUFDLGlCQUFpQmlHLEtBQUtDLElBQUksQ0FBQ2xHLFFBQVEsQ0FBQyxhQUFZO2dCQUVuRixJQUFJZ0csZ0JBQWdCO29CQUNsQixNQUFNRyxRQUFRSCxlQUFlRSxJQUFJLENBQUNDLEtBQUssQ0FBQztvQkFDeEMsSUFBSUEsT0FBTzt3QkFDVCxNQUFNQyxhQUFhQyxXQUFXRixLQUFLLENBQUMsRUFBRTt3QkFDdENKLGFBQWEsQ0FBQyxLQUFLSzt3QkFDbkJ2RyxRQUFReUMsR0FBRyxDQUFDLHlDQUF5RHlELE9BQTFCSyxZQUFXLGlCQUEwQixPQUFYTDtvQkFDdkU7Z0JBQ0Y7Z0JBQ0EsSUFBSUEsZUFBZSxHQUFHQSxhQUFhLENBQUMsR0FBRyxXQUFXOztZQUNwRDtZQUVBLDZEQUE2RDtZQUM3RCwrQ0FBK0M7WUFDL0MsSUFBSU87WUFDSixJQUFJcEMsaUJBQWlCLEtBQUs2QixlQUFlLENBQUMsSUFBSTtnQkFDNUMsK0NBQStDO2dCQUMvQ08sY0FBY1A7WUFDaEIsT0FBTztnQkFDTCxrREFBa0Q7Z0JBQ2xETyxjQUFjUCxhQUFjUCxDQUFBQSxnQkFBZ0JNLFlBQVc7WUFDekQ7WUFFQSxnREFBZ0Q7WUFDaEQsTUFBTVMsbUJBQW1CaEYsS0FBS2lGLEdBQUcsQ0FBQ2hCLGVBQWU7WUFDakQsTUFBTWlCLG9CQUFvQmxGLEtBQUtpRixHQUFHLENBQUNqRixLQUFLbUYsR0FBRyxDQUFDSixhQUFhLENBQUMsUUFBUTtZQUVsRSxJQUFJOUIsZUFBZU0sV0FBVyxLQUFLeUIsb0JBQW9CL0IsZUFBZU8sWUFBWSxLQUFLMEIsbUJBQW1CO2dCQUN4RzVHLFFBQVF5QyxHQUFHLENBQUMsb0NBQWtEaUUsT0FBeEJoQyxTQUFTaEMsVUFBVSxFQUFDLE1BQXVDa0UsT0FBbkNGLGtCQUFpQixvQkFBb0MsT0FBbEJFLG1CQUFrQjtnQkFFbkgsSUFBSTtvQkFDSixNQUFNLEVBQUUzRyxLQUFLLEVBQUUsR0FBRyxNQUFNVCxtREFBUUEsQ0FDN0JvRCxJQUFJLENBQUMsd0JBQ0xDLE1BQU0sQ0FBQzt3QkFDTm9DLGFBQWF5Qjt3QkFDYnhCLGNBQWMwQjtvQkFDaEIsR0FDQzNELEVBQUUsQ0FBQyxNQUFNMEIsZUFBZXpCLEVBQUU7b0JBRTNCLElBQUlqRCxPQUFPO3dCQUNURCxRQUFRQyxLQUFLLENBQUMseUNBQXlDQTt3QkFDdkRELFFBQVFDLEtBQUssQ0FBQyxvQkFBb0I2RyxLQUFLQyxTQUFTLENBQUM5RyxPQUFPLE1BQU07d0JBQzlERCxRQUFRQyxLQUFLLENBQUMsa0JBQWtCOzRCQUFFaUQsSUFBSXlCLGVBQWV6QixFQUFFOzRCQUFFK0IsYUFBYVU7NEJBQWVULGNBQWN1Qjt3QkFBWTtvQkFDakgsT0FBTzt3QkFDTHpHLFFBQVF5QyxHQUFHLENBQUMsd0JBQTRDLE9BQXBCaUMsU0FBU2hDLFVBQVU7b0JBQ3pEO2dCQUNGLEVBQUUsT0FBT1MsS0FBSztvQkFDWm5ELFFBQVFDLEtBQUssQ0FBQyx1Q0FBdUNrRDtnQkFDdkQ7WUFDRjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLHdEQUF3RDtBQUNqRCxTQUFTMEMsa0JBQWtCbkcsU0FBaUIsRUFBRUMsU0FBaUIsRUFBRUMsT0FBZSxFQUFFQyxPQUFlO0lBQ3RHLElBQUksQ0FBQ0gsYUFBYSxDQUFDRSxTQUFTLE9BQU87SUFFbkMsNkNBQTZDO0lBQzdDLE1BQU1FLFlBQVksQ0FBQ0M7UUFDakIsSUFBSSxDQUFDQSxXQUFXLE9BQU9BLFlBQVksVUFBVTtZQUMzQ0MsUUFBUUMsS0FBSyxDQUFDLHdCQUF3QkY7WUFDdEMsT0FBTyxJQUFJRyxPQUFPLGtDQUFrQzs7UUFDdEQ7UUFFQSw4RUFBOEU7UUFDOUUsSUFBSUgsUUFBUUksUUFBUSxDQUFDLFFBQVEscUJBQXFCQyxJQUFJLENBQUNMLFVBQVU7WUFDL0QsNENBQTRDO1lBQzVDLE1BQU1NLE9BQU8sSUFBSUgsS0FBS0g7WUFDdEIsSUFBSU8sTUFBTUQsS0FBS0UsT0FBTyxLQUFLO2dCQUN6QlAsUUFBUUMsS0FBSyxDQUFDLHFCQUFxQkY7Z0JBQ25DLE9BQU8sSUFBSUcsT0FBTyxrQ0FBa0M7O1lBQ3REO1lBQ0EsT0FBT0c7UUFDVDtRQUVBLHdDQUF3QztRQUN4QyxNQUFNRyxRQUFRVCxRQUFRVSxLQUFLLENBQUM7UUFDNUIsSUFBSUQsTUFBTUUsTUFBTSxLQUFLLEdBQUc7WUFDdEJWLFFBQVFDLEtBQUssQ0FBQyx3QkFBd0JGO1lBQ3RDLE9BQU8sSUFBSUcsT0FBTyxrQ0FBa0M7O1FBQ3REO1FBRUEsTUFBTSxDQUFDUyxLQUFLRSxPQUFPQyxLQUFLLEdBQUdOO1FBQzNCLE1BQU13RyxVQUFVLEdBQVduRyxPQUFSQyxNQUFLLEtBQTZCSCxPQUExQkUsTUFBTW9HLFFBQVEsQ0FBQyxHQUFHLE1BQUssS0FBd0IsT0FBckJ0RyxJQUFJc0csUUFBUSxDQUFDLEdBQUc7UUFDckUsTUFBTTVHLE9BQU8sSUFBSUgsS0FBSzhHO1FBRXRCLElBQUkxRyxNQUFNRCxLQUFLRSxPQUFPLEtBQUs7WUFDekJQLFFBQVFDLEtBQUssQ0FBQywrQkFBK0IrRyxTQUFTLFNBQVNqSDtZQUMvRCxPQUFPLElBQUlHLE9BQU8sa0NBQWtDOztRQUN0RDtRQUVBLE9BQU9HO0lBQ1Q7SUFFQSxNQUFNZSxRQUFRdEIsVUFBVUo7SUFDeEIsTUFBTTJCLE1BQU12QixVQUFVRjtJQUV0QiwwREFBMEQ7SUFDMUQsSUFBSXlCLE1BQU1ELE9BQU87UUFDZnBCLFFBQVFDLEtBQUssQ0FBQztRQUNkLE9BQU87SUFDVDtJQUVBLDBFQUEwRTtJQUMxRSxNQUFNaUgsV0FBVzdGLElBQUlkLE9BQU8sS0FBS2EsTUFBTWIsT0FBTztJQUM5QyxNQUFNNEcsV0FBV3pGLEtBQUtNLElBQUksQ0FBQ2tGLFdBQVksUUFBTyxLQUFLLEtBQUssRUFBQyxLQUFNLEVBQUUsNENBQTRDOztJQUc3RyxPQUFPQztBQUNUO0FBRUEsd0VBQXdFO0FBQ3hFLGVBQWVDLDhCQUE4QkMsYUFBa0I7SUFDN0QsSUFBSTtZQW1KcUIzQztRQWxKdkIxRSxRQUFReUMsR0FBRyxDQUFDLCtEQUFzRSxPQUFqQjRFLGNBQWNuRSxFQUFFO1FBQ2pGbEQsUUFBUXlDLEdBQUcsQ0FBRSwyQkFBZ0I0RTtRQUU3QixtQkFBbUI7UUFDbkIsTUFBTSxFQUFFakMsTUFBTVYsUUFBUSxFQUFFekUsT0FBT3FILGFBQWEsRUFBRSxHQUFHLE1BQU05SCxtREFBUUEsQ0FDNURvRCxJQUFJLENBQUMsUUFDTDBDLE1BQU0sQ0FBQyxLQUNQckMsRUFBRSxDQUFDLE1BQU1vRSxjQUFjdkMsV0FBVyxFQUNsQ1MsTUFBTTtRQUVULElBQUkrQixpQkFBaUIsQ0FBQzVDLFVBQVU7WUFDOUIxRSxRQUFRQyxLQUFLLENBQUMsNEJBQTRCcUg7WUFDMUM7UUFDRjtRQUVBLHVDQUF1QztRQUN2QyxJQUFJLENBQUM1QyxTQUFTRCxZQUFZLEVBQUU7WUFDMUJ6RSxRQUFReUMsR0FBRyxDQUFDO1lBQ1o7UUFDRjtRQUVBLDRDQUE0QztRQUM1QyxtREFBbUQ7UUFDbkQsTUFBTTNDLFlBQVksQ0FBQ0M7WUFDakIsSUFBSSxDQUFDQSxXQUFXLE9BQU9BLFlBQVksVUFBVTtnQkFDM0NDLFFBQVFDLEtBQUssQ0FBQyx3QkFBd0JGO2dCQUN0QyxPQUFPLElBQUlHO1lBQ2I7WUFFQSw4RUFBOEU7WUFDOUUsSUFBSUgsUUFBUUksUUFBUSxDQUFDLFFBQVEscUJBQXFCQyxJQUFJLENBQUNMLFVBQVU7Z0JBQy9ELDRDQUE0QztnQkFDNUMsTUFBTU0sT0FBTyxJQUFJSCxLQUFLSDtnQkFDdEIsSUFBSU8sTUFBTUQsS0FBS0UsT0FBTyxLQUFLO29CQUN6QlAsUUFBUUMsS0FBSyxDQUFDLHFCQUFxQkY7b0JBQ25DLE9BQU8sSUFBSUc7Z0JBQ2I7Z0JBQ0EsT0FBT0c7WUFDVDtZQUVBLHdDQUF3QztZQUN4QyxNQUFNRyxRQUFRVCxRQUFRVSxLQUFLLENBQUM7WUFDNUIsSUFBSUQsTUFBTUUsTUFBTSxLQUFLLEdBQUc7Z0JBQ3RCVixRQUFRQyxLQUFLLENBQUMsd0JBQXdCRjtnQkFDdEMsT0FBTyxJQUFJRztZQUNiO1lBRUEsTUFBTSxDQUFDUyxLQUFLRSxPQUFPQyxLQUFLLEdBQUdOO1lBQzNCLE1BQU13RyxVQUFVLEdBQVduRyxPQUFSQyxNQUFLLEtBQTZCSCxPQUExQkUsTUFBTW9HLFFBQVEsQ0FBQyxHQUFHLE1BQUssS0FBd0IsT0FBckJ0RyxJQUFJc0csUUFBUSxDQUFDLEdBQUc7WUFDckUsTUFBTTVHLE9BQU8sSUFBSUgsS0FBSzhHO1lBRXRCLElBQUkxRyxNQUFNRCxLQUFLRSxPQUFPLEtBQUs7Z0JBQ3pCUCxRQUFRQyxLQUFLLENBQUMsK0JBQStCK0csU0FBUyxTQUFTakg7Z0JBQy9ELE9BQU8sSUFBSUc7WUFDYjtZQUVBLE9BQU9HO1FBQ1Q7UUFFQSxNQUFNVCxVQUFVRSxVQUFVdUgsY0FBYzNCLFVBQVU7UUFDbEQsTUFBTTVFLE9BQU9sQixRQUFRd0UsV0FBVztRQUNoQyxNQUFNdkQsUUFBUWpCLFFBQVEwRSxRQUFRLEtBQUs7UUFFbkMsaUNBQWlDO1FBQ2pDLE1BQU0sRUFBRWMsTUFBTVQsY0FBYyxFQUFFMUUsT0FBT3NILFdBQVcsRUFBRSxHQUFHLE1BQU0vSCxtREFBUUEsQ0FDaEVvRCxJQUFJLENBQUMsd0JBQ0wwQyxNQUFNLENBQUMsS0FDUHJDLEVBQUUsQ0FBQyxlQUFlb0UsY0FBY3ZDLFdBQVcsRUFDM0M3QixFQUFFLENBQUMsUUFBUW5DLE1BQ1htQyxFQUFFLENBQUMsU0FBU3BDLE9BQ1owRSxNQUFNO1FBRVQsSUFBSWdDLGVBQWVBLFlBQVlDLElBQUksS0FBSyxZQUFZO1lBQ2xEeEgsUUFBUUMsS0FBSyxDQUFDLHVDQUF1Q3NIO1lBQ3JEO1FBQ0Y7UUFFQSxJQUFJRSxXQUFXOUMsMkJBQUFBLHFDQUFBQSxlQUFnQnpCLEVBQUU7UUFFakMsb0NBQW9DO1FBQ3BDLElBQUksQ0FBQ3lCLGdCQUFnQjtZQUNuQjNFLFFBQVF5QyxHQUFHLENBQUMsZ0RBQTZEaUMsT0FBdkJBLFNBQVNoQyxVQUFVLEVBQUMsS0FBc0IsT0FBbkJnQyxTQUFTL0IsU0FBUztZQUUzRixNQUFNb0MsWUFBWTtnQkFDaEJELGFBQWF1QyxjQUFjdkMsV0FBVztnQkFDdENoRSxNQUFNQTtnQkFDTkQsT0FBT0E7Z0JBQ1BtRSxlQUFlO2dCQUNmQyxhQUFhO2dCQUNiQyxjQUFjO2dCQUNkQyxPQUFPLCtCQUF1Q3RFLE9BQVJDLE1BQUssS0FBUyxPQUFORDtZQUNoRDtZQUVBLE1BQU0sRUFBRXVFLE1BQU1zQyxhQUFhLEVBQUV6SCxPQUFPMEgsV0FBVyxFQUFFLEdBQUcsTUFBTW5JLG1EQUFRQSxDQUMvRG9ELElBQUksQ0FBQyx3QkFDTHlDLE1BQU0sQ0FBQztnQkFBQ047YUFBVSxFQUNsQk8sTUFBTSxHQUNOQyxNQUFNO1lBRVQsSUFBSW9DLGFBQWE7Z0JBQ2YzSCxRQUFRQyxLQUFLLENBQUMsdUNBQXVDMEg7Z0JBQ3JEO1lBQ0Y7WUFFQUYsV0FBV0MsY0FBY3hFLEVBQUU7UUFDN0I7UUFFQSxvQ0FBb0M7UUFDcEMsTUFBTTBDLFdBQVdDLGtCQUNmd0IsY0FBY3ZCLFdBQVcsRUFDekJ1QixjQUFjdEIsVUFBVSxFQUN4QnNCLGNBQWMzQixVQUFVLEVBQ3hCMkIsY0FBY3JCLFNBQVM7UUFHekIsNERBQTREO1FBQzVELE1BQU0sRUFBRVosTUFBTXdDLFFBQVEsRUFBRTNILE9BQU80SCxVQUFVLEVBQUUsR0FBRyxNQUFNckksbURBQVFBLENBQ3pEb0QsSUFBSSxDQUFDLFNBQ0wwQyxNQUFNLENBQUMsS0FDUHJDLEVBQUUsQ0FBQyxlQUFlb0UsY0FBY3ZDLFdBQVcsRUFDM0M3QixFQUFFLENBQUMsVUFBVSxZQUNiNkUsR0FBRyxDQUFDLGNBQWMsTUFBTTtRQUUzQixJQUFJRCxZQUFZO1lBQ2Q3SCxRQUFRQyxLQUFLLENBQUMseUJBQXlCNEg7WUFDdkM7UUFDRjtRQUVBLDBDQUEwQztRQUMxQyxJQUFJbEMsZ0JBQWdCO1FBQ3BCLEtBQUssTUFBTUYsUUFBUW1DLFlBQVksRUFBRSxDQUFFO1lBQ2pDLE1BQU1HLGNBQWNqSSxVQUFVMkYsS0FBS0MsVUFBVTtZQUM3QyxJQUFJcUMsWUFBWTNELFdBQVcsT0FBT3RELFFBQVFpSCxZQUFZekQsUUFBUSxLQUFLLE1BQU16RCxPQUFPO2dCQUM5RSxNQUFNbUgsZUFBZW5DLGtCQUFrQkosS0FBS0ssV0FBVyxFQUFFTCxLQUFLTSxVQUFVLEVBQUVOLEtBQUtDLFVBQVUsRUFBRUQsS0FBS08sU0FBUztnQkFDekdMLGlCQUFpQnFDO1lBQ25CO1FBQ0Y7UUFFQSxvQkFBb0I7UUFDcEIsTUFBTS9CLGVBQWU7UUFFckIsK0RBQStEO1FBQy9ELG1EQUFtRDtRQUNuRCxJQUFJQyxhQUFhO1FBRWpCLDhEQUE4RDtRQUM5RCxNQUFNQyxrQkFBaUJ6QixrQkFBQUEsU0FBU1MsS0FBSyxjQUFkVCxzQ0FBQUEsZ0JBQWdCRSxJQUFJLENBQUMsQ0FBQ3dCLE9BQzNDQSxLQUFLQyxJQUFJLElBQUtELENBQUFBLEtBQUtDLElBQUksQ0FBQ2xHLFFBQVEsQ0FBQyxpQkFBaUJpRyxLQUFLQyxJQUFJLENBQUNsRyxRQUFRLENBQUMsYUFBWTtRQUVuRixJQUFJZ0csZ0JBQWdCO1lBQ2xCLE1BQU1HLFFBQVFILGVBQWVFLElBQUksQ0FBQ0MsS0FBSyxDQUFDO1lBQ3hDLElBQUlBLE9BQU87Z0JBQ1QsTUFBTUMsYUFBYUMsV0FBV0YsS0FBSyxDQUFDLEVBQUU7Z0JBQ3RDSixhQUFhLENBQUMsS0FBS0s7Z0JBQ25CdkcsUUFBUXlDLEdBQUcsQ0FBQyw0Q0FBNER5RCxPQUExQkssWUFBVyxpQkFBMEIsT0FBWEw7WUFDMUU7UUFDRjtRQUNBLElBQUlBLGVBQWUsR0FBR0EsYUFBYSxDQUFDLEdBQUcsV0FBVzs7UUFFbEQsNkRBQTZEO1FBQzdELCtDQUErQztRQUMvQyxJQUFJTztRQUNKLElBQUk1RixVQUFVLEtBQUtxRixlQUFlLENBQUMsSUFBSTtZQUNyQywrQ0FBK0M7WUFDL0NPLGNBQWNQO1FBQ2hCLE9BQU87WUFDTCxrREFBa0Q7WUFDbERPLGNBQWNQLGFBQWNQLENBQUFBLGdCQUFnQk0sWUFBVztRQUN6RDtRQUVBLGdEQUFnRDtRQUNoRCxNQUFNUyxtQkFBbUJoRixLQUFLaUYsR0FBRyxDQUFDaEIsZUFBZTtRQUNqRCxNQUFNaUIsb0JBQW9CbEYsS0FBS2lGLEdBQUcsQ0FBQ2pGLEtBQUttRixHQUFHLENBQUNKLGFBQWEsQ0FBQyxRQUFRO1FBRWxFLE1BQU0sRUFBRXhHLE9BQU9nSSxXQUFXLEVBQUUsR0FBRyxNQUFNekksbURBQVFBLENBQzFDb0QsSUFBSSxDQUFDLHdCQUNMQyxNQUFNLENBQUM7WUFDTm9DLGFBQWF5QjtZQUNieEIsY0FBYzBCO1FBQ2hCLEdBQ0MzRCxFQUFFLENBQUMsTUFBTXdFO1FBRVosSUFBSVEsYUFBYTtZQUNmakksUUFBUUMsS0FBSyxDQUFDLHlDQUF5Q2dJO1lBQ3ZEakksUUFBUUMsS0FBSyxDQUFDLG9CQUFvQjZHLEtBQUtDLFNBQVMsQ0FBQ2tCLGFBQWEsTUFBTTtZQUNwRWpJLFFBQVFDLEtBQUssQ0FBQyxrQkFBa0I7Z0JBQUVpRCxJQUFJdUU7Z0JBQVV4QyxhQUFhVTtnQkFBZVQsY0FBY3VCO1lBQVk7UUFDeEcsT0FBTztZQUNMekcsUUFBUXlDLEdBQUcsQ0FBQyxxQ0FBNkRrRCxPQUF4QmpCLFNBQVNoQyxVQUFVLEVBQUMsTUFBb0MrRCxPQUFoQ2QsZUFBYyxvQkFBOEIsT0FBWmMsYUFBWTtRQUN2SDtJQUVGLEVBQUUsT0FBT3RELEtBQUs7UUFDWm5ELFFBQVFDLEtBQUssQ0FBQyxzQ0FBc0NrRDtJQUN0RDtBQUNGO0FBRUEsd0VBQXdFO0FBQ3hFLGVBQWUrRSxzQ0FBc0NoRyxRQUFlLEVBQUVnQyxTQUFnQjtJQUNwRixJQUFJO1FBQ0ZsRSxRQUFReUMsR0FBRyxDQUFDO1FBQ1p6QyxRQUFReUMsR0FBRyxDQUFDLDJCQUFpQyxPQUFoQlAsU0FBU3hCLE1BQU0sRUFBQztRQUM3Q1YsUUFBUXlDLEdBQUcsQ0FBQyw0QkFBbUMsT0FBakJ5QixVQUFVeEQsTUFBTSxFQUFDO1FBRS9DLCtCQUErQjtRQUMvQixNQUFNLEVBQUUwRSxNQUFNK0MsVUFBVSxFQUFFbEksT0FBT21JLFVBQVUsRUFBRSxHQUFHLE1BQU01SSxtREFBUUEsQ0FDM0RvRCxJQUFJLENBQUMsd0JBQ0wwQyxNQUFNLENBQUM7UUFFVixJQUFJOEMsWUFBWTtZQUNkcEksUUFBUUMsS0FBSyxDQUFDLDBDQUEwQ21JO1lBQ3hEO1FBQ0Y7UUFFQSxJQUFJLENBQUNELGNBQWNBLFdBQVd6SCxNQUFNLEtBQUssR0FBRztZQUMxQ1YsUUFBUXlDLEdBQUcsQ0FBQztZQUNaO1FBQ0Y7UUFFQXpDLFFBQVF5QyxHQUFHLENBQUMsc0JBQThCLE9BQWxCMEYsV0FBV3pILE1BQU0sRUFBQztRQUUxQyxzQkFBc0I7UUFDdEIsS0FBSyxNQUFNbUUsVUFBVXNELFdBQVk7WUFDL0IsSUFBSTtnQkFDRm5JLFFBQVF5QyxHQUFHLENBQUMsb0NBQW9Eb0MsT0FBMUJBLE9BQU8zQixFQUFFLEVBQUMsa0JBQW1DLE9BQW5CMkIsT0FBT0MsV0FBVztnQkFFbEYsb0JBQW9CO2dCQUNwQixNQUFNSixXQUFXeEMsU0FBUzBDLElBQUksQ0FBQ3lELENBQUFBLE9BQVFBLEtBQUtuRixFQUFFLEtBQUsyQixPQUFPQyxXQUFXO2dCQUNyRSxJQUFJLENBQUNKLFVBQVU7b0JBQ2IxRSxRQUFReUMsR0FBRyxDQUFDLG9DQUE4QyxPQUFWb0MsT0FBTzNCLEVBQUU7b0JBQ3pEO2dCQUNGO2dCQUVBbEQsUUFBUXlDLEdBQUcsQ0FBQyxnQ0FBNkNpQyxPQUF2QkEsU0FBU2hDLFVBQVUsRUFBQyxLQUFzQixPQUFuQmdDLFNBQVMvQixTQUFTO2dCQUUzRSw0Q0FBNEM7Z0JBQzVDLE1BQU1pRixXQUFXMUQsVUFBVU0sTUFBTSxDQUFDLENBQUNpQixPQUNqQ0EsS0FBS1gsV0FBVyxLQUFLRCxPQUFPQyxXQUFXLElBQ3ZDVyxLQUFLcEQsTUFBTSxLQUFLLGNBQ2hCb0QsS0FBS0ssV0FBVyxJQUFJTCxLQUFLQyxVQUFVLElBQUlELEtBQUtNLFVBQVUsSUFBSU4sS0FBS08sU0FBUztnQkFHMUVoRyxRQUFReUMsR0FBRyxDQUFDLHNCQUE0QixPQUFoQm1GLFNBQVNsSCxNQUFNLEVBQUM7Z0JBRXhDLDJDQUEyQztnQkFDM0MsSUFBSWlGLGdCQUFnQjtnQkFDcEIsS0FBSyxNQUFNRixRQUFRbUMsU0FBVTtvQkFDM0IsTUFBTWhDLFdBQVdDLGtCQUFrQkosS0FBS0ssV0FBVyxFQUFFTCxLQUFLTSxVQUFVLEVBQUVOLEtBQUtDLFVBQVUsRUFBRUQsS0FBS08sU0FBUztvQkFDckdoRyxRQUFReUMsR0FBRyxDQUFDLHVCQUF5QmdELE9BQVpBLEtBQUt2QyxFQUFFLEVBQUMsTUFBMkJ1QyxPQUF2QkEsS0FBS0ssV0FBVyxFQUFDLFFBQTJCRixPQUFyQkgsS0FBS0MsVUFBVSxFQUFDLE9BQWMsT0FBVEUsVUFBUztvQkFDMUZELGlCQUFpQkM7Z0JBQ25CO2dCQUVBNUYsUUFBUXlDLEdBQUcsQ0FBQyw0Q0FBZ0QsT0FBZGtEO2dCQUU5QyxvQ0FBb0M7Z0JBQ3BDLE1BQU1NLGVBQWU7Z0JBRXJCLCtEQUErRDtnQkFDL0QsbURBQW1EO2dCQUNuRCxJQUFJQyxhQUFhckIsT0FBT0ssWUFBWSxJQUFJO2dCQUV4QyxnRkFBZ0Y7Z0JBQ2hGLElBQUlnQixlQUFlLEtBQUtyQixPQUFPaEUsS0FBSyxLQUFLLEdBQUc7d0JBRW5CNkQ7b0JBRHZCLHdDQUF3QztvQkFDeEMsTUFBTXlCLGtCQUFpQnpCLGtCQUFBQSxTQUFTUyxLQUFLLGNBQWRULHNDQUFBQSxnQkFBZ0JFLElBQUksQ0FBQyxDQUFDd0IsT0FDM0NBLEtBQUtDLElBQUksSUFBS0QsQ0FBQUEsS0FBS0MsSUFBSSxDQUFDbEcsUUFBUSxDQUFDLGlCQUFpQmlHLEtBQUtDLElBQUksQ0FBQ2xHLFFBQVEsQ0FBQyxhQUFZO29CQUVuRixJQUFJZ0csZ0JBQWdCO3dCQUNsQixNQUFNRyxRQUFRSCxlQUFlRSxJQUFJLENBQUNDLEtBQUssQ0FBQzt3QkFDeEMsSUFBSUEsT0FBTzs0QkFDVCxNQUFNQyxhQUFhQyxXQUFXRixLQUFLLENBQUMsRUFBRTs0QkFDdENKLGFBQWEsQ0FBQyxLQUFLSzs0QkFDbkJ2RyxRQUFReUMsR0FBRyxDQUFDLHVEQUF1RXlELE9BQTFCSyxZQUFXLGlCQUEwQixPQUFYTDt3QkFDckY7b0JBQ0Y7b0JBQ0EsSUFBSUEsZUFBZSxHQUFHQSxhQUFhLENBQUMsR0FBRyxXQUFXOztnQkFDcEQ7Z0JBRUEsNkRBQTZEO2dCQUM3RCwrQ0FBK0M7Z0JBQy9DLElBQUlPO2dCQUNKLElBQUk1QixPQUFPaEUsS0FBSyxLQUFLLEtBQUtxRixlQUFlLENBQUMsSUFBSTtvQkFDNUMsK0NBQStDO29CQUMvQ08sY0FBY1A7Z0JBQ2hCLE9BQU87b0JBQ0wsa0RBQWtEO29CQUNsRE8sY0FBY1AsYUFBY1AsQ0FBQUEsZ0JBQWdCTSxZQUFXO2dCQUN6RDtnQkFDQSxNQUFNUyxtQkFBbUJoRixLQUFLaUYsR0FBRyxDQUFDaEIsZUFBZTtnQkFDakQsTUFBTWlCLG9CQUFvQmxGLEtBQUtpRixHQUFHLENBQUNqRixLQUFLbUYsR0FBRyxDQUFDSixhQUFhLENBQUMsUUFBUTtnQkFFbEV6RyxRQUFReUMsR0FBRyxDQUFDLHdDQUEyRG1FLE9BQTdCRixrQkFBaUIsY0FBOEIsT0FBbEJFO2dCQUV2RSxvQkFBb0I7Z0JBQ3BCLE1BQU0sRUFBRTNHLE9BQU9nSSxXQUFXLEVBQUUsR0FBRyxNQUFNekksbURBQVFBLENBQzFDb0QsSUFBSSxDQUFDLHdCQUNMQyxNQUFNLENBQUM7b0JBQ05vQyxhQUFheUI7b0JBQ2J4QixjQUFjMEI7Z0JBQ2hCLEdBQ0MzRCxFQUFFLENBQUMsTUFBTTRCLE9BQU8zQixFQUFFO2dCQUVyQixJQUFJK0UsYUFBYTtvQkFDZmpJLFFBQVFDLEtBQUssQ0FBQywyQkFBcUMsT0FBVjRFLE9BQU8zQixFQUFFLEVBQUMsTUFBSStFO2dCQUN6RCxPQUFPO29CQUNMakksUUFBUXlDLEdBQUcsQ0FBQyxxQ0FBNkRpRSxPQUF4QmhDLFNBQVNoQyxVQUFVLEVBQUMsTUFBdUNrRSxPQUFuQ0Ysa0JBQWlCLG9CQUFvQyxPQUFsQkUsbUJBQWtCO2dCQUNoSTtZQUVGLEVBQUUsT0FBT3pELEtBQUs7Z0JBQ1puRCxRQUFRQyxLQUFLLENBQUMsNkJBQXVDLE9BQVY0RSxPQUFPM0IsRUFBRSxFQUFDLE1BQUlDO1lBQzNEO1FBQ0Y7UUFFQW5ELFFBQVF5QyxHQUFHLENBQUM7SUFFZCxFQUFFLE9BQU9VLEtBQUs7UUFDWm5ELFFBQVFDLEtBQUssQ0FBQyxpQ0FBaUNrRDtJQUNqRDtBQUNGO0FBRUEsa0RBQWtEO0FBQ2xELGVBQWVtRjtJQUNiLElBQUk7UUFDRnRJLFFBQVF5QyxHQUFHLENBQUM7UUFFWiwrQkFBK0I7UUFDL0IsTUFBTSxFQUFFMkMsTUFBTStDLFVBQVUsRUFBRWxJLE9BQU9tSSxVQUFVLEVBQUUsR0FBRyxNQUFNNUksbURBQVFBLENBQzNEb0QsSUFBSSxDQUFDLHdCQUNMMEMsTUFBTSxDQUFDO1FBRVYsSUFBSThDLFlBQVk7WUFDZHBJLFFBQVFDLEtBQUssQ0FBQyxrREFBa0RtSTtZQUNoRTtRQUNGO1FBRUEsSUFBSSxDQUFDRCxjQUFjQSxXQUFXekgsTUFBTSxLQUFLLEdBQUc7WUFDMUNWLFFBQVF5QyxHQUFHLENBQUM7WUFDWjtRQUNGO1FBRUF6QyxRQUFReUMsR0FBRyxDQUFDLFNBQTJCLE9BQWxCMEYsV0FBV3pILE1BQU0sRUFBQztRQUV2Qyx5QkFBeUI7UUFDekIsS0FBSyxNQUFNbUUsVUFBVXNELFdBQVk7WUFDL0IsSUFBSTtnQkFDRixNQUFNLEVBQUVsSSxPQUFPZ0ksV0FBVyxFQUFFLEdBQUcsTUFBTXpJLG1EQUFRQSxDQUMxQ29ELElBQUksQ0FBQyx3QkFDTEMsTUFBTSxDQUFDO29CQUNOb0MsYUFBYTtvQkFDYkMsY0FBYyxDQUFDLEdBQUcsa0NBQWtDO2dCQUN0RCxHQUNDakMsRUFBRSxDQUFDLE1BQU00QixPQUFPM0IsRUFBRTtnQkFFckIsSUFBSStFLGFBQWE7b0JBQ2ZqSSxRQUFRQyxLQUFLLENBQUMsNEJBQXNDLE9BQVY0RSxPQUFPM0IsRUFBRSxFQUFDLE1BQUkrRTtnQkFDMUQsT0FBTztvQkFDTGpJLFFBQVF5QyxHQUFHLENBQUMsa0JBQTRCLE9BQVZvQyxPQUFPM0IsRUFBRSxFQUFDO2dCQUMxQztZQUVGLEVBQUUsT0FBT0MsS0FBSztnQkFDWm5ELFFBQVFDLEtBQUssQ0FBQywwQkFBb0MsT0FBVjRFLE9BQU8zQixFQUFFLEVBQUMsTUFBSUM7WUFDeEQ7UUFDRjtRQUVBbkQsUUFBUXlDLEdBQUcsQ0FBQztJQUVkLEVBQUUsT0FBT1UsS0FBSztRQUNabkQsUUFBUUMsS0FBSyxDQUFDLCtCQUErQmtEO0lBQy9DO0FBQ0Y7QUFFTyxTQUFTb0Y7SUFDZCxNQUFNLENBQUNDLE9BQU9DLFNBQVMsR0FBR25KLCtDQUFRQSxDQUFRLEVBQUU7SUFDNUMsTUFBTSxDQUFDK0ksTUFBTUssUUFBUSxHQUFHcEosK0NBQVFBLENBQVEsRUFBRTtJQUMxQyxNQUFNLENBQUNxSixXQUFXQyxhQUFhLEdBQUd0SiwrQ0FBUUEsQ0FBUSxFQUFFO0lBQ3BELE1BQU0sQ0FBQ3VKLGtCQUFrQkMsb0JBQW9CLEdBQUd4SiwrQ0FBUUEsQ0FBUSxFQUFFO0lBQ2xFLE1BQU0sQ0FBQ3lKLE9BQU9DLFNBQVMsR0FBRzFKLCtDQUFRQSxDQUFRLEVBQUU7SUFDNUMsTUFBTSxDQUFDMkosT0FBT0MsU0FBUyxHQUFHNUosK0NBQVFBLENBQVEsRUFBRTtJQUM1QyxNQUFNLENBQUMyRSxvQkFBb0JrRixzQkFBc0IsR0FBRzdKLCtDQUFRQSxDQUFRLEVBQUU7SUFDdEUsTUFBTSxDQUFDOEosT0FBT0MsU0FBUyxHQUFHL0osK0NBQVFBLENBQVEsRUFBRTtJQUM1QyxNQUFNLENBQUNnSyxXQUFXQyxhQUFhLEdBQUdqSywrQ0FBUUEsQ0FBUSxFQUFFO0lBQ3BELE1BQU0sQ0FBQ2tLLFNBQVNDLFdBQVcsR0FBR25LLCtDQUFRQSxDQUFDO0lBQ3ZDLE1BQU0sQ0FBQ1csT0FBT3lKLFNBQVMsR0FBR3BLLCtDQUFRQSxDQUFnQjtJQUNsRCxNQUFNLENBQUNxSyxlQUFlQyxpQkFBaUIsR0FBR3RLLCtDQUFRQSxDQUF5QixDQUFDO0lBRTVFLDhCQUE4QjtJQUM5QixNQUFNdUssV0FBVztRQUNmLElBQUk7WUFDRkosV0FBVztZQUNYQyxTQUFTO1lBQ1QxSixRQUFReUMsR0FBRyxDQUFDO1lBRVosaUNBQWlDO1lBQ2pDLE1BQU0sRUFBRTJDLE1BQU0sRUFBRTBFLE9BQU8sRUFBRSxFQUFFLEdBQUcsTUFBTXRLLG1EQUFRQSxDQUFDdUssSUFBSSxDQUFDQyxVQUFVO1lBQzVEaEssUUFBUXlDLEdBQUcsQ0FBQyxvQkFBb0JxSCxVQUFVLG1CQUFtQjtZQUU3RCxJQUFJLENBQUNBLFNBQVM7Z0JBQ1o5SixRQUFRaUssSUFBSSxDQUFDO2dCQUNieEIsU0FBUyxFQUFFO2dCQUNYQyxRQUFRLEVBQUU7Z0JBQ1ZFLGFBQWEsRUFBRTtnQkFDZkUsb0JBQW9CLEVBQUU7Z0JBQ3RCRSxTQUFTLEVBQUU7Z0JBQ1hFLFNBQVMsRUFBRTtnQkFDWEMsc0JBQXNCLEVBQUU7Z0JBQ3hCRSxTQUFTLEVBQUU7Z0JBQ1hFLGFBQWEsRUFBRTtnQkFDZkUsV0FBVztnQkFDWDtZQUNGO1lBRUEsMkJBQTJCO1lBQzNCekosUUFBUXlDLEdBQUcsQ0FBQztZQUNaLE1BQU0sRUFBRTJDLE1BQU04RSxRQUFRLEVBQUVqSyxPQUFPa0ssU0FBUyxFQUFFLEdBQUcsTUFBTTNLLG1EQUFRQSxDQUN4RG9ELElBQUksQ0FBQyxjQUNMMEMsTUFBTSxDQUFDLE1BQ1A4RSxLQUFLLENBQUM7WUFFVCxJQUFJRCxXQUFXO2dCQUNibkssUUFBUUMsS0FBSyxDQUFDLG9DQUFvQ2tLO2dCQUNsRG5LLFFBQVFDLEtBQUssQ0FBQyx1QkFBdUI2RyxLQUFLQyxTQUFTLENBQUNvRCxXQUFXLE1BQU07WUFDdkUsT0FBTztnQkFDTG5LLFFBQVF5QyxHQUFHLENBQUM7WUFDZDtZQUVBLGFBQWE7WUFDYnpDLFFBQVF5QyxHQUFHLENBQUM7WUFDWixNQUFNLEVBQUUyQyxNQUFNaUYsU0FBUyxFQUFFcEssT0FBT3FLLFVBQVUsRUFBRSxHQUFHLE1BQU05SyxtREFBUUEsQ0FDMURvRCxJQUFJLENBQUMsU0FDTDBDLE1BQU0sQ0FBQyxLQUNQaUYsS0FBSyxDQUFDO1lBRVQsSUFBSUQsWUFBWTtnQkFDZHRLLFFBQVFDLEtBQUssQ0FBQyx3QkFBd0JxSztnQkFDdEN0SyxRQUFRQyxLQUFLLENBQUMsd0JBQXdCNkcsS0FBS0MsU0FBUyxDQUFDdUQsWUFBWSxNQUFNO1lBQ3pFLE9BQU87Z0JBQ0x0SyxRQUFReUMsR0FBRyxDQUFDLGlCQUFpQjRILENBQUFBLHNCQUFBQSxnQ0FBQUEsVUFBVzNKLE1BQU0sS0FBSTtnQkFDbEQrSCxTQUFTNEIsYUFBYSxFQUFFO1lBQzFCO1lBRUEsWUFBWTtZQUNackssUUFBUXlDLEdBQUcsQ0FBQztZQUNaLE1BQU0sRUFBRTJDLE1BQU1sRCxRQUFRLEVBQUVqQyxPQUFPdUssU0FBUyxFQUFFLEdBQUcsTUFBTWhMLG1EQUFRQSxDQUN4RG9ELElBQUksQ0FBQyxRQUNMMEMsTUFBTSxDQUFDLEtBQ1BpRixLQUFLLENBQUM7WUFFVCxJQUFJQyxXQUFXO2dCQUNieEssUUFBUUMsS0FBSyxDQUFDLHVCQUF1QnVLO2dCQUNyQ3hLLFFBQVFDLEtBQUssQ0FBQyx1QkFBdUI2RyxLQUFLQyxTQUFTLENBQUN5RCxXQUFXLE1BQU07WUFDdkUsT0FBTztnQkFDTHhLLFFBQVF5QyxHQUFHLENBQUMsZ0JBQWdCUCxDQUFBQSxxQkFBQUEsK0JBQUFBLFNBQVV4QixNQUFNLEtBQUk7Z0JBRWhELDZFQUE2RTtnQkFDN0UsZ0RBQWdEO2dCQUNoRCw4Q0FBOEM7Z0JBRTlDLDJDQUEyQztnQkFDM0NnSSxRQUFReEcsWUFBWSxFQUFFO1lBQ3hCO1lBRUEsa0JBQWtCO1lBQ2xCbEMsUUFBUXlDLEdBQUcsQ0FBQztZQUNaLE1BQU0sRUFBRTJDLE1BQU1xRixhQUFhLEVBQUV4SyxPQUFPeUssY0FBYyxFQUFFLEdBQUcsTUFBTWxMLG1EQUFRQSxDQUNsRW9ELElBQUksQ0FBQyxjQUNMMEMsTUFBTSxDQUFDLEtBQ1BpRixLQUFLLENBQUMsY0FBYztnQkFBRUksV0FBVztZQUFNO1lBRTFDLElBQUlELGdCQUFnQjtnQkFDbEIxSyxRQUFRQyxLQUFLLENBQUMsNkJBQTZCeUs7WUFDN0MsT0FBTztnQkFDTDFLLFFBQVF5QyxHQUFHLENBQUMsc0JBQXNCZ0ksQ0FBQUEsMEJBQUFBLG9DQUFBQSxjQUFlL0osTUFBTSxLQUFJO2dCQUMzRGtJLGFBQWE2QixpQkFBaUIsRUFBRTtZQUNsQztZQUVBLDBCQUEwQjtZQUMxQnpLLFFBQVF5QyxHQUFHLENBQUM7WUFDWixNQUFNLEVBQUUyQyxNQUFNd0YsYUFBYSxFQUFFM0ssT0FBTzRLLGNBQWMsRUFBRSxHQUFHLE1BQU1yTCxtREFBUUEsQ0FDbEVvRCxJQUFJLENBQUMsc0JBQ0wwQyxNQUFNLENBQUMsS0FDUGlGLEtBQUssQ0FBQyxjQUFjO2dCQUFFSSxXQUFXO1lBQU07WUFFMUMsSUFBSUUsZ0JBQWdCO2dCQUNsQjdLLFFBQVFDLEtBQUssQ0FBQyxxQ0FBcUM0SztnQkFDbkQvQixvQkFBb0IsRUFBRTtZQUN4QixPQUFPO2dCQUNMOUksUUFBUXlDLEdBQUcsQ0FBQyw4QkFBOEJtSSxDQUFBQSwwQkFBQUEsb0NBQUFBLGNBQWVsSyxNQUFNLEtBQUk7Z0JBQ25Fb0ksb0JBQW9COEIsaUJBQWlCLEVBQUU7WUFDekM7WUFFQSxhQUFhO1lBQ2I1SyxRQUFReUMsR0FBRyxDQUFDO1lBQ1osTUFBTSxFQUFFMkMsTUFBTTBGLFNBQVMsRUFBRTdLLE9BQU84SyxVQUFVLEVBQUUsR0FBRyxNQUFNdkwsbURBQVFBLENBQzFEb0QsSUFBSSxDQUFDLFNBQ0wwQyxNQUFNLENBQUMsS0FDUGlGLEtBQUssQ0FBQyxjQUFjO2dCQUFFSSxXQUFXO1lBQU07WUFFMUMsSUFBSUksWUFBWTtnQkFDZC9LLFFBQVFDLEtBQUssQ0FBQyx3QkFBd0I4SztnQkFDdEMvQixTQUFTLEVBQUU7WUFDYixPQUFPO2dCQUNMaEosUUFBUXlDLEdBQUcsQ0FBQyxpQkFBaUJxSSxDQUFBQSxzQkFBQUEsZ0NBQUFBLFVBQVdwSyxNQUFNLEtBQUk7Z0JBQ2xEc0ksU0FBUzhCLGFBQWEsRUFBRTtZQUMxQjtZQUVNLGFBQWE7WUFDYjlLLFFBQVF5QyxHQUFHLENBQUM7WUFDWixNQUFNLEVBQUUyQyxNQUFNbEIsU0FBUyxFQUFFakUsT0FBTzRILFVBQVUsRUFBRSxHQUFHLE1BQU1ySSxtREFBUUEsQ0FDMURvRCxJQUFJLENBQUMsU0FDTDBDLE1BQU0sQ0FBQyxLQUNQaUYsS0FBSyxDQUFDLGNBQWM7Z0JBQUVJLFdBQVc7WUFBTTtZQUUxQyxJQUFJOUMsWUFBWTtnQkFDZDdILFFBQVFDLEtBQUssQ0FBQyx3QkFBd0I0SDtnQkFDdENxQixTQUFTLEVBQUU7WUFDYixPQUFPO2dCQUNMbEosUUFBUXlDLEdBQUcsQ0FBQyxpQkFBaUJ5QixDQUFBQSxzQkFBQUEsZ0NBQUFBLFVBQVd4RCxNQUFNLEtBQUk7Z0JBQ2xEd0ksU0FBU2hGLGFBQWEsRUFBRTtZQUMxQjtZQUVBLDRCQUE0QjtZQUM1QmxFLFFBQVF5QyxHQUFHLENBQUM7WUFDWixNQUFNLEVBQUUyQyxNQUFNNEYsZUFBZSxFQUFFL0ssT0FBT2dMLGdCQUFnQixFQUFFLEdBQUcsTUFBTXpMLG1EQUFRQSxDQUN0RW9ELElBQUksQ0FBQyx3QkFDTDBDLE1BQU0sQ0FBQyxLQUNQaUYsS0FBSyxDQUFDLFFBQVE7Z0JBQUVJLFdBQVc7WUFBTSxHQUNqQ0osS0FBSyxDQUFDLFNBQVM7Z0JBQUVJLFdBQVc7WUFBTTtZQUVyQyxJQUFJTSxrQkFBa0I7Z0JBQ3BCakwsUUFBUUMsS0FBSyxDQUFDLHVDQUF1Q2dMO2dCQUNyRDlCLHNCQUFzQixFQUFFO1lBQzFCLE9BQU87Z0JBQ0xuSixRQUFReUMsR0FBRyxDQUFDLGdDQUFnQ3VJLENBQUFBLDRCQUFBQSxzQ0FBQUEsZ0JBQWlCdEssTUFBTSxLQUFJO2dCQUN2RXlJLHNCQUFzQjZCLG1CQUFtQixFQUFFO2dCQUUzQywwREFBMEQ7Z0JBQzFEaEwsUUFBUXlDLEdBQUcsQ0FBQztnQkFDWixNQUFNdUIsNkJBQTZCOUIsWUFBWSxFQUFFLEVBQUU4SSxtQkFBbUIsRUFBRSxFQUFFOUcsYUFBYSxFQUFFO1lBQzNGO1lBRU4sYUFBYTtZQUNibEUsUUFBUXlDLEdBQUcsQ0FBQztZQUNaLE1BQU0sRUFBRTJDLE1BQU04RixTQUFTLEVBQUVqTCxPQUFPa0wsVUFBVSxFQUFFLEdBQUcsTUFBTTNMLG1EQUFRQSxDQUMxRG9ELElBQUksQ0FBQyxTQUNMMEMsTUFBTSxDQUFDLEtBQ1BpRixLQUFLLENBQUMsY0FBYztnQkFBRUksV0FBVztZQUFNO1lBRTFDLElBQUlRLFlBQVk7Z0JBQ2RuTCxRQUFRQyxLQUFLLENBQUMsd0JBQXdCa0w7Z0JBQ3RDOUIsU0FBUyxFQUFFO1lBQ2IsT0FBTztnQkFDTHJKLFFBQVF5QyxHQUFHLENBQUMsaUJBQWlCeUksQ0FBQUEsc0JBQUFBLGdDQUFBQSxVQUFXeEssTUFBTSxLQUFJO2dCQUNsRDJJLFNBQVM2QixhQUFhLEVBQUU7WUFDMUI7WUFFQSxpQkFBaUI7WUFDakJsTCxRQUFReUMsR0FBRyxDQUFDO1lBQ1osTUFBTSxFQUFFMkMsTUFBTWdHLGFBQWEsRUFBRW5MLE9BQU9vTCxjQUFjLEVBQUUsR0FBRyxNQUFNN0wsbURBQVFBLENBQ2xFb0QsSUFBSSxDQUFDLGFBQ0wwQyxNQUFNLENBQUMsS0FDUGlGLEtBQUssQ0FBQyxjQUFjO2dCQUFFSSxXQUFXO1lBQU07WUFFMUMsSUFBSVUsZ0JBQWdCO2dCQUNsQnJMLFFBQVFDLEtBQUssQ0FBQyw0QkFBNEJvTDtnQkFDMUM5QixhQUFhLEVBQUU7WUFDakIsT0FBTztnQkFDTHZKLFFBQVF5QyxHQUFHLENBQUMscUJBQXFCMkksQ0FBQUEsMEJBQUFBLG9DQUFBQSxjQUFlMUssTUFBTSxLQUFJO2dCQUMxRDZJLGFBQWE2QixpQkFBaUIsRUFBRTtZQUNsQztZQUVBcEwsUUFBUXlDLEdBQUcsQ0FBQztZQUVaLHdEQUF3RDtZQUN4RCxJQUFJO2dCQUNGLE1BQU0sRUFBRTJDLE1BQU1rRyxTQUFTLEVBQUVyTCxPQUFPc0wsUUFBUSxFQUFFLEdBQUcsTUFBTS9MLG1EQUFRQSxDQUN4RG9ELElBQUksQ0FBQyxtQkFDTDBDLE1BQU0sQ0FBQztnQkFDVixJQUFJaUcsVUFBVTtvQkFDWixNQUFNQyxNQUFNLENBQUNELHFCQUFBQSwrQkFBRCxTQUFtQkUsT0FBTyxLQUFJQyxPQUFPSDtvQkFDakR2TCxRQUFRaUssSUFBSSxDQUFDLDBEQUEwRHVCO29CQUN2RTVCLGlCQUFpQixDQUFDO2dCQUNwQixPQUFPO29CQUNMLE1BQU0rQixNQUE4QixDQUFDO29CQUNyQyxLQUFLLE1BQU1DLE9BQU9OLGFBQWEsRUFBRSxDQUFFO3dCQUNqQyxJQUFJTSxJQUFJQyxPQUFPLElBQUlELElBQUlFLEtBQUssRUFBRUgsR0FBRyxDQUFDQyxJQUFJQyxPQUFPLENBQUMsR0FBR0QsSUFBSUUsS0FBSztvQkFDNUQ7b0JBQ0FsQyxpQkFBaUIrQjtnQkFDbkI7WUFDRixFQUFFLE9BQU9JLEdBQUc7Z0JBQ1YvTCxRQUFRaUssSUFBSSxDQUFDLGtDQUFrQyxDQUFDOEIsY0FBQUEsd0JBQUQsRUFBWU4sT0FBTyxLQUFJTTtnQkFDdEVuQyxpQkFBaUIsQ0FBQztZQUNwQjtRQUVGLEVBQUUsT0FBT3pHLEtBQUs7WUFDWm5ELFFBQVFDLEtBQUssQ0FBQyxzQkFBc0JrRDtZQUNwQ3VHLFNBQVN2RyxlQUFlNkksUUFBUTdJLElBQUlzSSxPQUFPLEdBQUc7UUFDaEQsU0FBVTtZQUNSaEMsV0FBVztRQUNiO0lBQ0Y7SUFFQSxxQkFBcUI7SUFDckJsSyxnREFBU0E7cUNBQUM7WUFDUnNLO1FBRUEsNERBQTREO1FBQzVELHlDQUF5QztRQUN6QywwREFBMEQ7UUFDMUQsNERBQTREO1FBQzVELG9DQUFvQztRQUVwQyx5Q0FBeUM7UUFDM0M7b0NBQUcsRUFBRTtJQUVMLGlDQUFpQztJQUNqQ3RLLGdEQUFTQTtxQ0FBQztZQUNSLDZCQUE2QjtZQUM3QixNQUFNME0sb0JBQW9Cek0sbURBQVFBLENBQy9CME0sT0FBTyxDQUFDLGlCQUNSQyxFQUFFLENBQUMsb0JBQW9CO2dCQUFFQyxPQUFPO2dCQUFLQyxRQUFRO2dCQUFVQyxPQUFPO1lBQVE7K0RBQUc7b0JBQ3hFekM7Z0JBQ0Y7OERBQ0MwQyxTQUFTO1lBRVosNEJBQTRCO1lBQzVCLE1BQU1DLG1CQUFtQmhOLG1EQUFRQSxDQUM5QjBNLE9BQU8sQ0FBQyxnQkFDUkMsRUFBRSxDQUFDLG9CQUFvQjtnQkFBRUMsT0FBTztnQkFBS0MsUUFBUTtnQkFBVUMsT0FBTztZQUFPOzhEQUFHO29CQUN2RXpDO2dCQUNGOzZEQUNDMEMsU0FBUztZQUVaLGtDQUFrQztZQUNsQyxNQUFNRSx3QkFBd0JqTixtREFBUUEsQ0FDbkMwTSxPQUFPLENBQUMsc0JBQ1JDLEVBQUUsQ0FBQyxvQkFBb0I7Z0JBQUVDLE9BQU87Z0JBQUtDLFFBQVE7Z0JBQVVDLE9BQU87WUFBYTttRUFBRztvQkFDN0V6QztnQkFDRjtrRUFDQzBDLFNBQVM7WUFFWiwwQ0FBMEM7WUFDMUMsTUFBTUcsd0JBQXdCbE4sbURBQVFBLENBQ25DME0sT0FBTyxDQUFDLHNCQUNSQyxFQUFFLENBQUMsb0JBQW9CO2dCQUFFQyxPQUFPO2dCQUFLQyxRQUFRO2dCQUFVQyxPQUFPO1lBQXFCO21FQUFHO29CQUNyRnpDO2dCQUNGO2tFQUNDMEMsU0FBUztZQUVaLDZCQUE2QjtZQUM3QixNQUFNSSxvQkFBb0JuTixtREFBUUEsQ0FDL0IwTSxPQUFPLENBQUMsaUJBQ1JDLEVBQUUsQ0FBQyxvQkFBb0I7Z0JBQUVDLE9BQU87Z0JBQUtDLFFBQVE7Z0JBQVVDLE9BQU87WUFBUTsrREFBRztvQkFDeEV6QztnQkFDRjs4REFDQzBDLFNBQVM7WUFFWiw2QkFBNkI7WUFDN0IsTUFBTUssb0JBQW9CcE4sbURBQVFBLENBQy9CME0sT0FBTyxDQUFDLGlCQUNSQyxFQUFFLENBQUMsb0JBQW9CO2dCQUFFQyxPQUFPO2dCQUFLQyxRQUFRO2dCQUFVQyxPQUFPO1lBQVE7K0RBQUc7b0JBQ3hFekM7Z0JBQ0Y7OERBQ0MwQyxTQUFTO1lBRVosNkJBQTZCO1lBQzdCLE1BQU1NLG9CQUFvQnJOLG1EQUFRQSxDQUMvQjBNLE9BQU8sQ0FBQyxpQkFDUkMsRUFBRSxDQUFDLG9CQUFvQjtnQkFBRUMsT0FBTztnQkFBS0MsUUFBUTtnQkFBVUMsT0FBTztZQUFROytEQUFHO29CQUN4RXpDO2dCQUNGOzhEQUNDMEMsU0FBUztZQUVaLGlDQUFpQztZQUNqQyxNQUFNTyx3QkFBd0J0TixtREFBUUEsQ0FDbkMwTSxPQUFPLENBQUMscUJBQ1JDLEVBQUUsQ0FBQyxvQkFBb0I7Z0JBQUVDLE9BQU87Z0JBQUtDLFFBQVE7Z0JBQVVDLE9BQU87WUFBWTttRUFBRztvQkFDNUV6QztnQkFDRjtrRUFDQzBDLFNBQVM7WUFFWjs2Q0FBTztvQkFDTE4sa0JBQWtCYyxXQUFXO29CQUM3QlAsaUJBQWlCTyxXQUFXO29CQUM1Qk4sc0JBQXNCTSxXQUFXO29CQUNqQ0wsc0JBQXNCSyxXQUFXO29CQUNqQ0osa0JBQWtCSSxXQUFXO29CQUM3Qkgsa0JBQWtCRyxXQUFXO29CQUM3QkYsa0JBQWtCRSxXQUFXO29CQUM3QkQsc0JBQXNCQyxXQUFXO2dCQUNuQzs7UUFDRjtvQ0FBRyxFQUFFO0lBRUwsa0JBQWtCO0lBQ2xCLE1BQU1DLFVBQVUsT0FBTzlLO1FBQ3JCLElBQUk7WUFDRmxDLFFBQVF5QyxHQUFHLENBQUMsbUNBQW1DUDtZQUMvQ2xDLFFBQVF5QyxHQUFHLENBQUMsc0JBQXNCcUUsS0FBS0MsU0FBUyxDQUFDN0UsVUFBVSxNQUFNO1lBRWpFLDJCQUEyQjtZQUMzQixNQUFNK0ssaUJBQWlCO2dCQUFDO2dCQUFNO2dCQUFjO2dCQUFhO2dCQUFlO2FBQVc7WUFDbkYsTUFBTUMsZ0JBQWdCRCxlQUFlekksTUFBTSxDQUFDMkksQ0FBQUEsUUFBUyxDQUFDakwsUUFBUSxDQUFDaUwsTUFBTTtZQUVyRSxJQUFJRCxjQUFjeE0sTUFBTSxHQUFHLEdBQUc7Z0JBQzVCLE1BQU1ULFFBQVEsSUFBSStMLE1BQU0sNEJBQXFELE9BQXpCa0IsY0FBY0UsSUFBSSxDQUFDO2dCQUN2RXBOLFFBQVFDLEtBQUssQ0FBQyxxQkFBcUJBO2dCQUNuQyxNQUFNQTtZQUNSO1lBRUEsa0NBQWtDO1lBQ2xDLE1BQU0sRUFBRW1GLE1BQU1pSSxZQUFZLEVBQUVwTixPQUFPcU4sVUFBVSxFQUFFLEdBQUcsTUFBTTlOLG1EQUFRQSxDQUM3RG9ELElBQUksQ0FBQyxRQUNMMEMsTUFBTSxDQUFDLE1BQ1ByQyxFQUFFLENBQUMsY0FBY2YsU0FBU1EsVUFBVSxFQUNwQ08sRUFBRSxDQUFDLGFBQWFmLFNBQVNTLFNBQVMsRUFDbENNLEVBQUUsQ0FBQyxlQUFlZixTQUFTcUwsV0FBVyxFQUN0Q2hJLE1BQU07WUFFVCxJQUFJOEgsZ0JBQWdCLENBQUNDLFlBQVk7Z0JBQy9CLE1BQU1yTixRQUFRLElBQUkrTCxNQUFNLHlCQUFnRDlKLE9BQXZCQSxTQUFTUSxVQUFVLEVBQUMsS0FBc0IsT0FBbkJSLFNBQVNTLFNBQVMsRUFBQztnQkFDM0YzQyxRQUFRQyxLQUFLLENBQUMsMEJBQTBCQTtnQkFDeEMsTUFBTUE7WUFDUjtZQUVBLE1BQU0sRUFBRW1GLElBQUksRUFBRW5GLEtBQUssRUFBRSxHQUFHLE1BQU1ULG1EQUFRQSxDQUNuQ29ELElBQUksQ0FBQyxRQUNMeUMsTUFBTSxDQUFDO2dCQUFDbkQ7YUFBUyxFQUNqQm9ELE1BQU0sR0FDTkMsTUFBTTtZQUVULElBQUl0RixPQUFPO2dCQUNURCxRQUFRQyxLQUFLLENBQUMsK0JBQStCQTtnQkFDN0NELFFBQVFDLEtBQUssQ0FBQyxrQkFBa0I2RyxLQUFLQyxTQUFTLENBQUM5RyxPQUFPLE1BQU07Z0JBQzVERCxRQUFRQyxLQUFLLENBQUMsZUFBZUEsTUFBTXVILElBQUk7Z0JBQ3ZDeEgsUUFBUUMsS0FBSyxDQUFDLGtCQUFrQkEsTUFBTXdMLE9BQU87Z0JBQzdDekwsUUFBUUMsS0FBSyxDQUFDLGVBQWVBLE1BQU11TixJQUFJO2dCQUN2QyxNQUFNdk47WUFDUjtZQUVBRCxRQUFReUMsR0FBRyxDQUFDLG1DQUFtQzJDO1lBQy9DLE1BQU15RTtZQUNOLE9BQU96RTtRQUNULEVBQUUsT0FBT2pDLEtBQUs7WUFDWm5ELFFBQVFDLEtBQUssQ0FBQyxzQkFBc0JrRDtZQUNwQ25ELFFBQVFDLEtBQUssQ0FBQyxrQkFBa0I2RyxLQUFLQyxTQUFTLENBQUM1RCxLQUFLLE1BQU07WUFDMUQsTUFBTUE7UUFDUjtJQUNGO0lBRUEscUJBQXFCO0lBQ3JCLE1BQU1zSyxhQUFhLE9BQU92SyxJQUFZd0s7UUFDcEMsSUFBSTtZQUNGMU4sUUFBUXlDLEdBQUcsQ0FBQyxxQ0FBcUNTLElBQUl3SztZQUVyRCxNQUFNLEVBQUV0SSxJQUFJLEVBQUVuRixLQUFLLEVBQUUsR0FBRyxNQUFNVCxtREFBUUEsQ0FDbkNvRCxJQUFJLENBQUMsUUFDTEMsTUFBTSxDQUFDNkssU0FDUHpLLEVBQUUsQ0FBQyxNQUFNQyxJQUNUb0MsTUFBTSxHQUNOQyxNQUFNO1lBRVQsSUFBSXRGLE9BQU87Z0JBQ1RELFFBQVFDLEtBQUssQ0FBQyxpQ0FBaUNBO2dCQUMvQyxNQUFNQTtZQUNSO1lBRUFELFFBQVF5QyxHQUFHLENBQUM7WUFDWixNQUFNb0g7WUFDTixPQUFPekU7UUFDVCxFQUFFLE9BQU9qQyxLQUFLO1lBQ1puRCxRQUFRQyxLQUFLLENBQUMsd0JBQXdCa0Q7WUFDdEMsTUFBTUE7UUFDUjtJQUNGO0lBRUEscUJBQXFCO0lBQ3JCLE1BQU13SyxhQUFhLE9BQU96SztRQUN4QixJQUFJO1lBQ0YsTUFBTSxFQUFFakQsS0FBSyxFQUFFLEdBQUcsTUFBTVQsbURBQVFBLENBQzdCb0QsSUFBSSxDQUFDLFFBQ0xnTCxNQUFNLEdBQ04zSyxFQUFFLENBQUMsTUFBTUM7WUFFWixJQUFJakQsT0FBTyxNQUFNQTtZQUVqQixNQUFNNEosV0FBVyxrQkFBa0I7O1FBQ3JDLEVBQUUsT0FBTzFHLEtBQUs7WUFDWm5ELFFBQVFDLEtBQUssQ0FBQyx3QkFBd0JrRDtZQUN0QyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxXQUFXO0lBQ1gsTUFBTTBLLFVBQVUsT0FBT0M7UUFDckIsSUFBSTtZQUNGOU4sUUFBUXlDLEdBQUcsQ0FBQyw0QkFBNEJxTDtZQUV4QyxNQUFNLEVBQUUxSSxJQUFJLEVBQUVuRixLQUFLLEVBQUUsR0FBRyxNQUFNVCxtREFBUUEsQ0FDbkNvRCxJQUFJLENBQUMsU0FDTHlDLE1BQU0sQ0FBQztnQkFBQ3lJO2FBQVMsRUFDakJ4SSxNQUFNLEdBQ05DLE1BQU07WUFFVCxJQUFJdEYsT0FBTztnQkFDVEQsUUFBUUMsS0FBSyxDQUFDLCtCQUErQkE7Z0JBQzdDRCxRQUFRQyxLQUFLLENBQUMsa0JBQWtCNkcsS0FBS0MsU0FBUyxDQUFDOUcsT0FBTyxNQUFNO2dCQUM1RCxNQUFNQTtZQUNSO1lBRUFELFFBQVF5QyxHQUFHLENBQUMsNEJBQTRCMkM7WUFDeEMsTUFBTXlFO1lBQ04sT0FBT3pFO1FBQ1QsRUFBRSxPQUFPakMsS0FBSztZQUNabkQsUUFBUUMsS0FBSyxDQUFDLHNCQUFzQmtEO1lBQ3BDLE1BQU1BO1FBQ1I7SUFDRjtJQUVBLGNBQWM7SUFDZCxNQUFNNEssYUFBYSxPQUFPN0ssSUFBWXdLO1FBQ3BDLElBQUk7WUFDRixNQUFNLEVBQUV0SSxJQUFJLEVBQUVuRixLQUFLLEVBQUUsR0FBRyxNQUFNVCxtREFBUUEsQ0FDbkNvRCxJQUFJLENBQUMsU0FDTEMsTUFBTSxDQUFDNkssU0FDUHpLLEVBQUUsQ0FBQyxNQUFNQyxJQUNUb0MsTUFBTSxHQUNOQyxNQUFNO1lBRVQsSUFBSXRGLE9BQU8sTUFBTUE7WUFFakIsTUFBTTRKLFdBQVcsa0JBQWtCOztZQUNuQyxPQUFPekU7UUFDVCxFQUFFLE9BQU9qQyxLQUFLO1lBQ1puRCxRQUFRQyxLQUFLLENBQUMsd0JBQXdCa0Q7WUFDdEMsTUFBTUE7UUFDUjtJQUNGO0lBRUEsY0FBYztJQUNkLE1BQU02SyxhQUFhLE9BQU85SztRQUN4QixJQUFJO1lBQ0YsTUFBTSxFQUFFakQsS0FBSyxFQUFFLEdBQUcsTUFBTVQsbURBQVFBLENBQzdCb0QsSUFBSSxDQUFDLFNBQ0xnTCxNQUFNLEdBQ04zSyxFQUFFLENBQUMsTUFBTUM7WUFFWixJQUFJakQsT0FBTyxNQUFNQTtZQUVqQixNQUFNNEosV0FBVyxrQkFBa0I7O1FBQ3JDLEVBQUUsT0FBTzFHLEtBQUs7WUFDWm5ELFFBQVFDLEtBQUssQ0FBQyx3QkFBd0JrRDtZQUN0QyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxpQkFBaUI7SUFDakIsTUFBTThLLGVBQWUsT0FBT3hEO1FBQzFCLElBQUk7WUFDRnpLLFFBQVF5QyxHQUFHLENBQUMsa0NBQWtDZ0k7WUFFOUMsMkJBQTJCO1lBQzNCLElBQUlBLGNBQWN0RixLQUFLLEtBQUssUUFBUXNGLGNBQWN0RixLQUFLLEtBQUsrSSxXQUFXO2dCQUNyRXpELGNBQWN0RixLQUFLLEdBQUc7WUFDeEI7WUFFQSxNQUFNLEVBQUVDLElBQUksRUFBRW5GLEtBQUssRUFBRSxHQUFHLE1BQU1ULG1EQUFRQSxDQUNuQ29ELElBQUksQ0FBQyxjQUNMeUMsTUFBTSxDQUFDO2dCQUFDb0Y7YUFBYyxFQUN0Qm5GLE1BQU0sR0FDTkMsTUFBTTtZQUVULElBQUl0RixPQUFPO2dCQUNURCxRQUFRQyxLQUFLLENBQUMscUNBQXFDQTtnQkFDbkRELFFBQVFDLEtBQUssQ0FBQyxrQkFBa0I2RyxLQUFLQyxTQUFTLENBQUM5RyxPQUFPLE1BQU07Z0JBQzVELE1BQU1BO1lBQ1I7WUFFQUQsUUFBUXlDLEdBQUcsQ0FBQyxrQ0FBa0MyQztZQUM5QyxNQUFNeUUsV0FBVyxrQkFBa0I7O1lBQ25DLE9BQU96RTtRQUNULEVBQUUsT0FBT2pDLEtBQUs7WUFDWm5ELFFBQVFDLEtBQUssQ0FBQyw0QkFBNEJrRDtZQUMxQyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxvQkFBb0I7SUFDcEIsTUFBTWdMLGtCQUFrQixPQUFPakwsSUFBWXdLO1FBQ3pDLElBQUk7WUFDRjFOLFFBQVF5QyxHQUFHLENBQUMsb0NBQW9DUyxJQUFJd0s7WUFFcEQsMkJBQTJCO1lBQzNCLElBQUlBLFFBQVF2SSxLQUFLLEtBQUssUUFBUXVJLFFBQVF2SSxLQUFLLEtBQUsrSSxXQUFXO2dCQUN6RFIsUUFBUXZJLEtBQUssR0FBRztZQUNsQjtZQUVBLE1BQU0sRUFBRUMsSUFBSSxFQUFFbkYsS0FBSyxFQUFFLEdBQUcsTUFBTVQsbURBQVFBLENBQ25Db0QsSUFBSSxDQUFDLGNBQ0xDLE1BQU0sQ0FBQzZLLFNBQ1B6SyxFQUFFLENBQUMsTUFBTUMsSUFDVG9DLE1BQU0sR0FDTkMsTUFBTTtZQUVULElBQUl0RixPQUFPO2dCQUNURCxRQUFRQyxLQUFLLENBQUMsdUNBQXVDQTtnQkFDckRELFFBQVFDLEtBQUssQ0FBQyxrQkFBa0I2RyxLQUFLQyxTQUFTLENBQUM5RyxPQUFPLE1BQU07Z0JBQzVELE1BQU1BO1lBQ1I7WUFFQUQsUUFBUXlDLEdBQUcsQ0FBQyxvQ0FBb0MyQztZQUNoRCxNQUFNeUUsV0FBVyxrQkFBa0I7O1lBQ25DLE9BQU96RTtRQUNULEVBQUUsT0FBT2pDLEtBQUs7WUFDWm5ELFFBQVFDLEtBQUssQ0FBQyw4QkFBOEJrRDtZQUM1Q25ELFFBQVFDLEtBQUssQ0FBQyxrQkFBa0I2RyxLQUFLQyxTQUFTLENBQUM1RCxLQUFLLE1BQU07WUFDMUQsTUFBTUE7UUFDUjtJQUNGO0lBRUEsTUFBTWlMLHFCQUFxQixPQUFPQztRQUNoQyxJQUFJO1lBQ0ZyTyxRQUFReUMsR0FBRyxDQUFDO1lBQ1p6QyxRQUFReUMsR0FBRyxDQUFDLHlCQUF5QjRMO1lBRXJDLG1DQUFtQztZQUNuQyxNQUFNQyxPQUFPQyxPQUFPQyxVQUFVO1lBQzlCeE8sUUFBUXlDLEdBQUcsQ0FBQyxtQkFBbUI2TDtZQUUvQixvREFBb0Q7WUFDcEQsTUFBTSxFQUFFcEwsRUFBRSxFQUFFLEdBQUd1TCxlQUFlLEdBQUdKO1lBRWpDLDZEQUE2RDtZQUM3RCxNQUFNSyxlQUFlO2dCQUNuQnhMLElBQUlvTDtnQkFDSkssZ0JBQWdCRixjQUFjRSxjQUFjO2dCQUM1Q0MsWUFBWUgsY0FBY0csVUFBVTtnQkFDcENDLFVBQVVKLGNBQWNJLFFBQVE7Z0JBQ2hDQyxZQUFZTCxjQUFjSyxVQUFVO2dCQUNwQ0MsYUFBYU4sY0FBY00sV0FBVztnQkFDdENDLDBCQUEwQlAsY0FBY08sd0JBQXdCO2dCQUNoRUMsMkJBQTJCUixjQUFjUSx5QkFBeUI7Z0JBQ2xFQywyQkFBMkJULGNBQWNTLHlCQUF5QjtnQkFDbEVDLG1CQUFtQlYsY0FBY1UsaUJBQWlCO2dCQUNsREMsb0JBQW9CWCxjQUFjVyxrQkFBa0IsSUFBSSxFQUFFO1lBQzVEO1lBRUEsaUVBQWlFO1lBQ2pFLElBQUlYLGNBQWNZLE1BQU0sRUFBRTtnQkFDdkJYLGFBQXFCVyxNQUFNLEdBQUdaLGNBQWNZLE1BQU07WUFDckQ7WUFDQSxJQUFJWixjQUFjdEosS0FBSyxFQUFFO2dCQUN0QnVKLGFBQXFCdkosS0FBSyxHQUFHc0osY0FBY3RKLEtBQUs7WUFDbkQ7WUFFQW5GLFFBQVF5QyxHQUFHLENBQUMseUNBQXlDaU07WUFDckQxTyxRQUFReUMsR0FBRyxDQUFDLHdCQUF3QnFFLEtBQUtDLFNBQVMsQ0FBQzJILGNBQWMsTUFBTTtZQUV2RSwyQkFBMkI7WUFDM0IsTUFBTXpCLGlCQUFpQjtnQkFBQztnQkFBTTtnQkFBa0I7Z0JBQWM7Z0JBQVk7Z0JBQWM7Z0JBQTRCO2dCQUE2QjtnQkFBNkI7YUFBb0I7WUFDbE0sTUFBTUMsZ0JBQWdCRCxlQUFlekksTUFBTSxDQUFDMkksQ0FBQUEsUUFBUyxDQUFDLFlBQXFCLENBQUNBLE1BQU0sSUFBSSxZQUFxQixDQUFDQSxNQUFNLEtBQUs7WUFFdkgsSUFBSUQsY0FBY3hNLE1BQU0sR0FBRyxHQUFHO2dCQUM1QlYsUUFBUUMsS0FBSyxDQUFDLDRCQUE0QmlOO2dCQUMxQyxNQUFNLElBQUlsQixNQUFNLDRCQUFxRCxPQUF6QmtCLGNBQWNFLElBQUksQ0FBQztZQUNqRTtZQUVBcE4sUUFBUXlDLEdBQUcsQ0FBQztZQUVaLE1BQU0sRUFBRTJDLElBQUksRUFBRW5GLEtBQUssRUFBRSxHQUFHLE1BQU1ULG1EQUFRQSxDQUNuQ29ELElBQUksQ0FBQyxzQkFDTHlDLE1BQU0sQ0FBQztnQkFBQ3FKO2FBQWEsRUFDckJwSixNQUFNO1lBRVQsSUFBSXJGLE9BQU87Z0JBQ1RELFFBQVFDLEtBQUssQ0FBQyw4Q0FBOENBO2dCQUM1REQsUUFBUUMsS0FBSyxDQUFDLG9CQUFvQjZHLEtBQUtDLFNBQVMsQ0FBQzlHLE9BQU8sTUFBTTtnQkFDOURELFFBQVFDLEtBQUssQ0FBQyxpQkFBaUJBLE1BQU11SCxJQUFJO2dCQUN6Q3hILFFBQVFDLEtBQUssQ0FBQyxvQkFBb0JBLE1BQU13TCxPQUFPO2dCQUMvQ3pMLFFBQVFDLEtBQUssQ0FBQyxpQkFBaUJBLE1BQU11TixJQUFJO2dCQUN6QyxNQUFNdk47WUFDUjtZQUVBRCxRQUFReUMsR0FBRyxDQUFDLDJDQUEyQzJDO1lBQ3ZELE1BQU15RSxXQUFXLGtCQUFrQjs7WUFDbkMsT0FBT3pFO1FBQ1QsRUFBRSxPQUFPakMsS0FBSztZQUNabkQsUUFBUUMsS0FBSyxDQUFDLHFDQUFxQ2tEO1lBQ25EbkQsUUFBUUMsS0FBSyxDQUFDLG9CQUFvQjZHLEtBQUtDLFNBQVMsQ0FBQzVELEtBQUssTUFBTTtZQUM1RCxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxNQUFNbU0sd0JBQXdCLE9BQU83SCxVQUFrQmlHO1FBQ3JELElBQUk7WUFDRjFOLFFBQVF5QyxHQUFHLENBQUMsMkNBQTJDZ0YsVUFBVWlHO1lBQ2pFLE1BQU0sRUFBRXRJLElBQUksRUFBRW5GLEtBQUssRUFBRSxHQUFHLE1BQU1ULG1EQUFRQSxDQUNuQ29ELElBQUksQ0FBQyxzQkFDTEMsTUFBTSxDQUFDNkssU0FDUHpLLEVBQUUsQ0FBQyxNQUFNd0UsVUFDVG5DLE1BQU07WUFFVCxJQUFJckYsT0FBTztnQkFDVEQsUUFBUUMsS0FBSyxDQUFDLDhDQUE4Q0E7Z0JBQzVELE1BQU1BO1lBQ1I7WUFFQUQsUUFBUXlDLEdBQUcsQ0FBQywyQ0FBMkMyQztZQUN2RCxNQUFNeUUsV0FBVyxrQkFBa0I7O1lBQ25DLE9BQU96RTtRQUNULEVBQUUsT0FBT2pDLEtBQUs7WUFDWm5ELFFBQVFDLEtBQUssQ0FBQyxxQ0FBcUNrRDtZQUNuRCxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxNQUFNb00sVUFBVSxPQUFPQztRQUNyQixJQUFJO1lBQ0Z4UCxRQUFReUMsR0FBRyxDQUFDLDRCQUE0QitNO1lBQ3hDLE1BQU0sRUFBRXBLLElBQUksRUFBRW5GLEtBQUssRUFBRSxHQUFHLE1BQU1ULG1EQUFRQSxDQUNuQ29ELElBQUksQ0FBQyxTQUNMeUMsTUFBTSxDQUFDO2dCQUFDbUs7YUFBUyxFQUNqQmxLLE1BQU07WUFFVCxJQUFJckYsT0FBTztnQkFDVEQsUUFBUUMsS0FBSyxDQUFDLCtCQUErQkE7Z0JBQzdDLE1BQU1BO1lBQ1I7WUFFQUQsUUFBUXlDLEdBQUcsQ0FBQyw0QkFBNEIyQztZQUN4QyxNQUFNeUUsV0FBVyxrQkFBa0I7O1lBQ25DLE9BQU96RTtRQUNULEVBQUUsT0FBT2pDLEtBQUs7WUFDWm5ELFFBQVFDLEtBQUssQ0FBQyxzQkFBc0JrRDtZQUNwQyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxNQUFNc00sZUFBZSxPQUFPQyxRQUFnQnZLO1FBQzFDLElBQUk7WUFDRm5GLFFBQVF5QyxHQUFHLENBQUMsZ0NBQWdDaU47WUFDNUMsTUFBTSxFQUFFdEssSUFBSSxFQUFFbkYsS0FBSyxFQUFFLEdBQUcsTUFBTVQsbURBQVFBLENBQ25Db0QsSUFBSSxDQUFDLFNBQ0xDLE1BQU0sQ0FBQztnQkFDTlIsUUFBUTtnQkFDUnNOLGNBQWMsSUFBSXpQLE9BQU8wRCxXQUFXO2dCQUNwQ3VCLE9BQU9BLFNBQVM7WUFDbEIsR0FDQ2xDLEVBQUUsQ0FBQyxNQUFNeU0sUUFDVHBLLE1BQU07WUFFVCxJQUFJckYsT0FBTztnQkFDVEQsUUFBUUMsS0FBSyxDQUFDLG1DQUFtQ0E7Z0JBQ2pELE1BQU1BO1lBQ1I7WUFFQUQsUUFBUXlDLEdBQUcsQ0FBQyxnQ0FBZ0MyQztZQUM1QyxNQUFNeUUsV0FBVyxrQkFBa0I7O1lBQ25DLE9BQU96RTtRQUNULEVBQUUsT0FBT2pDLEtBQUs7WUFDWm5ELFFBQVFDLEtBQUssQ0FBQywwQkFBMEJrRDtZQUN4QyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxNQUFNeU0sY0FBYyxPQUFPRixRQUFnQkcsZUFBdUJ6SjtRQUNoRSxJQUFJO1lBQ0ZwRyxRQUFReUMsR0FBRyxDQUFDLDRCQUE0QmlOLFFBQVFHO1lBRWhELDhCQUE4QjtZQUM5QixNQUFNLEVBQUV6SyxNQUFNMEssSUFBSSxFQUFFN1AsT0FBT21JLFVBQVUsRUFBRSxHQUFHLE1BQU01SSxtREFBUUEsQ0FDckRvRCxJQUFJLENBQUMsU0FDTDBDLE1BQU0sQ0FBQyxLQUNQckMsRUFBRSxDQUFDLE1BQU15TSxRQUNUbkssTUFBTTtZQUVULElBQUk2QyxjQUFjLENBQUMwSCxNQUFNO2dCQUN2QixNQUFNLElBQUk5RCxNQUFNO1lBQ2xCO1lBRUEsdUJBQXVCO1lBQ3ZCLE1BQU0rRCxVQUFVLENBQUNELEtBQUtFLFdBQVcsSUFBSSxLQUFLSDtZQUMxQyxNQUFNSSxlQUFlSCxLQUFLSSxNQUFNLEdBQUdIO1lBQ25DLE1BQU1JLFlBQVlGLGdCQUFnQixJQUFJLGFBQWE7WUFFbkQsK0JBQStCO1lBQy9CLE1BQU1HLGVBQWU7Z0JBQ25CL1AsTUFBTSxJQUFJSCxPQUFPMEQsV0FBVztnQkFDNUJzTSxRQUFRTDtnQkFDUnpKLE1BQU1BLFFBQVE7Z0JBQ2RpSyxRQUFRO1lBQ1Y7WUFFQSxjQUFjO1lBQ2QsTUFBTSxFQUFFakwsSUFBSSxFQUFFbkYsS0FBSyxFQUFFLEdBQUcsTUFBTVQsbURBQVFBLENBQ25Db0QsSUFBSSxDQUFDLFNBQ0xDLE1BQU0sQ0FBQztnQkFDTm1OLGFBQWFEO2dCQUNiTyxrQkFBa0JMO2dCQUNsQjVOLFFBQVE4TjtnQkFDUlIsY0FBY1EsY0FBYyxhQUFhLElBQUlqUSxPQUFPMEQsV0FBVyxLQUFLO2dCQUNwRTJNLGlCQUFpQjt1QkFBS1QsS0FBS1MsZUFBZSxJQUFJLEVBQUU7b0JBQUdIO2lCQUFhO1lBQ2xFLEdBQ0NuTixFQUFFLENBQUMsTUFBTXlNLFFBQ1RwSyxNQUFNO1lBRVQsSUFBSXJGLE9BQU87Z0JBQ1RELFFBQVFDLEtBQUssQ0FBQyxrQ0FBa0NBO2dCQUNoRCxNQUFNQTtZQUNSO1lBRUFELFFBQVF5QyxHQUFHLENBQUMsOEJBQThCMkM7WUFDMUMsTUFBTXlFLFdBQVcsa0JBQWtCOztZQUNuQyxPQUFPekU7UUFDVCxFQUFFLE9BQU9qQyxLQUFLO1lBQ1puRCxRQUFRQyxLQUFLLENBQUMseUJBQXlCa0Q7WUFDdkMsTUFBTUE7UUFDUjtJQUNGO0lBRUEsaUJBQWlCO0lBQ2pCLE1BQU1xTixVQUFVLE9BQU9DO1FBQ3JCLElBQUk7WUFDRnpRLFFBQVF5QyxHQUFHLENBQUMsZ0JBQWdCZ087WUFFNUIsTUFBTSxFQUFFckwsSUFBSSxFQUFFbkYsS0FBSyxFQUFFLEdBQUcsTUFBTVQsbURBQVFBLENBQ25Db0QsSUFBSSxDQUFDLFNBQ0x5QyxNQUFNLENBQUM7Z0JBQUNvTDthQUFTLEVBQ2pCbkwsTUFBTTtZQUVULElBQUlyRixPQUFPO2dCQUNURCxRQUFRQyxLQUFLLENBQUMsc0JBQXNCQTtnQkFDcEMsTUFBTUE7WUFDUjtZQUVBRCxRQUFReUMsR0FBRyxDQUFDLDRCQUE0QjJDO1lBQ3hDLE1BQU15RSxXQUFXLGtCQUFrQjs7WUFDbkMsT0FBT3pFO1FBQ1QsRUFBRSxPQUFPakMsS0FBSztZQUNabkQsUUFBUUMsS0FBSyxDQUFDLHNCQUFzQmtEO1lBQ3BDLE1BQU1BO1FBQ1I7SUFDRjtJQUVBLE1BQU11TixhQUFhLE9BQU9DLFFBQWdCakQ7UUFDeEMsSUFBSTtZQUNGMU4sUUFBUXlDLEdBQUcsQ0FBQyxrQkFBa0JrTyxRQUFRakQ7WUFFdEMsTUFBTSxFQUFFdEksSUFBSSxFQUFFbkYsS0FBSyxFQUFFLEdBQUcsTUFBTVQsbURBQVFBLENBQ25Db0QsSUFBSSxDQUFDLFNBQ0xDLE1BQU0sQ0FBQztnQkFBRSxHQUFHNkssT0FBTztnQkFBRWtELFlBQVksSUFBSTFRLE9BQU8wRCxXQUFXO1lBQUcsR0FDMURYLEVBQUUsQ0FBQyxNQUFNME4sUUFDVHJMLE1BQU0sR0FDTkMsTUFBTTtZQUVULElBQUl0RixPQUFPO2dCQUNURCxRQUFRQyxLQUFLLENBQUMsd0JBQXdCQTtnQkFDdEMsTUFBTUE7WUFDUjtZQUVBRCxRQUFReUMsR0FBRyxDQUFDLDhCQUE4QjJDO1lBRTFDLHlEQUF5RDtZQUN6RCxJQUFJc0ksUUFBUXJMLE1BQU0sS0FBSyxjQUFjK0MsS0FBS04sV0FBVyxFQUFFO2dCQUNyRDlFLFFBQVF5QyxHQUFHLENBQUM7Z0JBQ1osTUFBTTJFLDhCQUE4QmhDO1lBQ3RDO1lBRUEsTUFBTXlFLFdBQVcsa0JBQWtCOztZQUNuQyxPQUFPekU7UUFDVCxFQUFFLE9BQU9qQyxLQUFLO1lBQ1puRCxRQUFRQyxLQUFLLENBQUMsd0JBQXdCa0Q7WUFDdEMsTUFBTUE7UUFDUjtJQUNGO0lBR0EseUJBQXlCO0lBQ3pCLE1BQU0wTix1QkFBdUIsT0FBT3hDO1FBQ2xDLElBQUk7WUFDRnJPLFFBQVF5QyxHQUFHLENBQUMsK0JBQStCNEw7WUFDM0NyTyxRQUFReUMsR0FBRyxDQUFDLHdCQUF3QnFFLEtBQUtDLFNBQVMsQ0FBQ3NILFlBQVksTUFBTTtZQUVyRSwyQkFBMkI7WUFDM0IsTUFBTXBCLGlCQUFpQjtnQkFBQztnQkFBZTtnQkFBUTtnQkFBUztnQkFBaUI7Z0JBQWU7YUFBZTtZQUN2RyxNQUFNQyxnQkFBZ0JELGVBQWV6SSxNQUFNLENBQUMySSxDQUFBQSxRQUFTa0IsVUFBVSxDQUFDbEIsTUFBTSxLQUFLZSxhQUFhRyxVQUFVLENBQUNsQixNQUFNLEtBQUs7WUFFOUcsSUFBSUQsY0FBY3hNLE1BQU0sR0FBRyxHQUFHO2dCQUM1QixNQUFNVCxRQUFRLElBQUkrTCxNQUFNLDRCQUFxRCxPQUF6QmtCLGNBQWNFLElBQUksQ0FBQztnQkFDdkVwTixRQUFRQyxLQUFLLENBQUMscUJBQXFCQTtnQkFDbkMsTUFBTUE7WUFDUjtZQUVBLDBFQUEwRTtZQUMxRSxNQUFNLEVBQUVtRixNQUFNVCxjQUFjLEVBQUUxRSxPQUFPcU4sVUFBVSxFQUFFLEdBQUcsTUFBTTlOLG1EQUFRQSxDQUMvRG9ELElBQUksQ0FBQyx3QkFDTDBDLE1BQU0sQ0FBQyxNQUNQckMsRUFBRSxDQUFDLGVBQWVvTCxXQUFXdkosV0FBVyxFQUN4QzdCLEVBQUUsQ0FBQyxRQUFRb0wsV0FBV3ZOLElBQUksRUFDMUJtQyxFQUFFLENBQUMsU0FBU29MLFdBQVd4TixLQUFLLEVBQzVCMEUsTUFBTTtZQUVULElBQUlaLGdCQUFnQjtnQkFDbEIzRSxRQUFReUMsR0FBRyxDQUFDO2dCQUNaLHFEQUFxRDtnQkFDckQsTUFBTSxFQUFFMkMsSUFBSSxFQUFFbkYsS0FBSyxFQUFFLEdBQUcsTUFBTVQsbURBQVFBLENBQ25Db0QsSUFBSSxDQUFDLHdCQUNMQyxNQUFNLENBQUM7b0JBQ05tQyxlQUFlcUosV0FBV3JKLGFBQWE7b0JBQ3ZDQyxhQUFhb0osV0FBV3BKLFdBQVc7b0JBQ25DQyxjQUFjbUosV0FBV25KLFlBQVk7b0JBQ3JDMEwsWUFBWSxJQUFJMVEsT0FBTzBELFdBQVc7Z0JBQ3BDLEdBQ0NYLEVBQUUsQ0FBQyxNQUFNMEIsZUFBZXpCLEVBQUUsRUFDMUJvQyxNQUFNO2dCQUVULElBQUlyRixPQUFPO29CQUNURCxRQUFRQyxLQUFLLENBQUMsZ0RBQWdEQTtvQkFDOUQsTUFBTUE7Z0JBQ1I7Z0JBRUFELFFBQVF5QyxHQUFHLENBQUMsNkNBQTZDMkM7Z0JBQ3pELE1BQU15RSxXQUFXLGtCQUFrQjs7Z0JBQ25DLE9BQU96RTtZQUNUO1lBRUEsd0NBQXdDO1lBQ3hDLE1BQU0sRUFBRUEsSUFBSSxFQUFFbkYsS0FBSyxFQUFFLEdBQUcsTUFBTVQsbURBQVFBLENBQ25Db0QsSUFBSSxDQUFDLHdCQUNMeUMsTUFBTSxDQUFDO2dCQUFDZ0o7YUFBVyxFQUNuQi9JLE1BQU07WUFFVCxJQUFJckYsT0FBTztnQkFDVEQsUUFBUUMsS0FBSyxDQUFDLDhDQUE4Q0E7Z0JBQzVERCxRQUFRQyxLQUFLLENBQUMsa0JBQWtCNkcsS0FBS0MsU0FBUyxDQUFDOUcsT0FBTyxNQUFNO2dCQUM1REQsUUFBUUMsS0FBSyxDQUFDLGVBQWVBLE1BQU11SCxJQUFJO2dCQUN2Q3hILFFBQVFDLEtBQUssQ0FBQyxrQkFBa0JBLE1BQU13TCxPQUFPO2dCQUM3Q3pMLFFBQVFDLEtBQUssQ0FBQyxlQUFlQSxNQUFNdU4sSUFBSTtnQkFDdkMsTUFBTXZOO1lBQ1I7WUFFQUQsUUFBUXlDLEdBQUcsQ0FBQywyQ0FBMkMyQztZQUN2RCxNQUFNeUUsV0FBVyxrQkFBa0I7O1lBQ25DLE9BQU96RTtRQUNULEVBQUUsT0FBT2pDLEtBQUs7WUFDWm5ELFFBQVFDLEtBQUssQ0FBQyxxQ0FBcUNrRDtZQUNuRG5ELFFBQVFDLEtBQUssQ0FBQyxrQkFBa0I2RyxLQUFLQyxTQUFTLENBQUM1RCxLQUFLLE1BQU07WUFDMUQsTUFBTUE7UUFDUjtJQUNGO0lBRUEsTUFBTTJOLDBCQUEwQixPQUFPckosVUFBa0JpRztRQUN2RCxJQUFJO1lBQ0YxTixRQUFReUMsR0FBRyxDQUFDLGlDQUFpQ2dGLFVBQVVpRztZQUV2RCxNQUFNLEVBQUV0SSxJQUFJLEVBQUVuRixLQUFLLEVBQUUsR0FBRyxNQUFNVCxtREFBUUEsQ0FDbkNvRCxJQUFJLENBQUMsd0JBQ0xDLE1BQU0sQ0FBQztnQkFBRSxHQUFHNkssT0FBTztnQkFBRWtELFlBQVksSUFBSTFRLE9BQU8wRCxXQUFXO1lBQUcsR0FDMURYLEVBQUUsQ0FBQyxNQUFNd0UsVUFDVG5DLE1BQU0sR0FDTkMsTUFBTTtZQUVULElBQUl0RixPQUFPO2dCQUNURCxRQUFRQyxLQUFLLENBQUMsdUNBQXVDQTtnQkFDckQsTUFBTUE7WUFDUjtZQUVBRCxRQUFReUMsR0FBRyxDQUFDLDZDQUE2QzJDO1lBQ3pELE1BQU15RSxXQUFXLGtCQUFrQjs7WUFDbkMsT0FBT3pFO1FBQ1QsRUFBRSxPQUFPakMsS0FBSztZQUNabkQsUUFBUUMsS0FBSyxDQUFDLHVDQUF1Q2tEO1lBQ3JELE1BQU1BO1FBQ1I7SUFDRjtJQUVBLE1BQU00TiwwQkFBMEIsT0FBT3RKO1FBQ3JDLElBQUk7WUFDRnpILFFBQVF5QyxHQUFHLENBQUMsaUNBQWlDZ0Y7WUFFN0MsTUFBTSxFQUFFeEgsS0FBSyxFQUFFLEdBQUcsTUFBTVQsbURBQVFBLENBQzdCb0QsSUFBSSxDQUFDLHdCQUNMZ0wsTUFBTSxHQUNOM0ssRUFBRSxDQUFDLE1BQU13RTtZQUVaLElBQUl4SCxPQUFPO2dCQUNURCxRQUFRQyxLQUFLLENBQUMsdUNBQXVDQTtnQkFDckQsTUFBTUE7WUFDUjtZQUVBRCxRQUFReUMsR0FBRyxDQUFDO1lBQ1osTUFBTW9ILFdBQVcsa0JBQWtCOztRQUNyQyxFQUFFLE9BQU8xRyxLQUFLO1lBQ1puRCxRQUFRQyxLQUFLLENBQUMsdUNBQXVDa0Q7WUFDckQsTUFBTUE7UUFDUjtJQUNGO0lBRUEsMEJBQTBCO0lBQzFCLE1BQU02TixhQUFhLE9BQU9MO1FBQ3hCLElBQUk7WUFDRixNQUFNLEVBQUUxUSxLQUFLLEVBQUUsR0FBRyxNQUFNVCxtREFBUUEsQ0FDN0JvRCxJQUFJLENBQUMsU0FDTGdMLE1BQU0sR0FDTjNLLEVBQUUsQ0FBQyxNQUFNME47WUFFWixJQUFJMVEsT0FBTztnQkFDVEQsUUFBUUMsS0FBSyxDQUFDLGlDQUFpQ0E7Z0JBQy9DLE1BQU1BO1lBQ1I7WUFFQUQsUUFBUXlDLEdBQUcsQ0FBQztZQUNaLE1BQU1vSCxXQUFXLGtCQUFrQjs7UUFDckMsRUFBRSxPQUFPMUcsS0FBSztZQUNabkQsUUFBUUMsS0FBSyxDQUFDLHdCQUF3QmtEO1lBQ3RDLE1BQU1BO1FBQ1I7SUFDRjtJQUVBLDhCQUE4QjtJQUM5QixNQUFNOE4saUJBQWlCLE9BQU9DO1FBQzVCLElBQUk7WUFDRixtQ0FBbUM7WUFDbkMsTUFBTTFSLG1EQUFRQSxDQUFDb0QsSUFBSSxDQUFDLHdCQUF3QmdMLE1BQU0sR0FBRzNLLEVBQUUsQ0FBQyxlQUFlaU87WUFDdkUsTUFBTTFSLG1EQUFRQSxDQUFDb0QsSUFBSSxDQUFDLFNBQVNnTCxNQUFNLEdBQUczSyxFQUFFLENBQUMsZUFBZWlPO1lBRXhELDJCQUEyQjtZQUMzQixNQUFNLEVBQUVqUixLQUFLLEVBQUUsR0FBRyxNQUFNVCxtREFBUUEsQ0FDN0JvRCxJQUFJLENBQUMsUUFDTGdMLE1BQU0sR0FDTjNLLEVBQUUsQ0FBQyxNQUFNaU87WUFFWixJQUFJalIsT0FBTztnQkFDVEQsUUFBUUMsS0FBSyxDQUFDLHFDQUFxQ0E7Z0JBQ25ELE1BQU1BO1lBQ1I7WUFFQUQsUUFBUXlDLEdBQUcsQ0FBQztZQUNaLE1BQU1vSCxXQUFXLGtCQUFrQjs7UUFDckMsRUFBRSxPQUFPMUcsS0FBSztZQUNabkQsUUFBUUMsS0FBSyxDQUFDLDRCQUE0QmtEO1lBQzFDLE1BQU1BO1FBQ1I7SUFDRjtJQUVBLGtCQUFrQjtJQUNsQixNQUFNZ08sZ0JBQWdCLE9BQU9DLFFBQWdCaEw7UUFDM0MsSUFBSTtZQUNGLCtCQUErQjtZQUMvQixNQUFNLEVBQUVoQixNQUFNbEQsUUFBUSxFQUFFakMsT0FBT21JLFVBQVUsRUFBRSxHQUFHLE1BQU01SSxtREFBUUEsQ0FDekRvRCxJQUFJLENBQUMsUUFDTDBDLE1BQU0sQ0FBQyxnQkFDUHJDLEVBQUUsQ0FBQyxNQUFNbU8sUUFDVDdMLE1BQU07WUFFVCxJQUFJNkMsWUFBWSxNQUFNQTtZQUV0QixpREFBaUQ7WUFDakQsTUFBTWlKLGVBQWVuUCxDQUFBQSxxQkFBQUEsK0JBQUFBLFNBQVVvUCxZQUFZLEtBQUksRUFBRTtZQUVqRCw4QkFBOEI7WUFDOUIsTUFBTUMsVUFBVTtnQkFDZHJPLElBQUloRCxLQUFLc1IsR0FBRyxHQUFHQyxRQUFRO2dCQUN2QkMsU0FBU3RMO2dCQUNUdUwsV0FBVyxJQUFJelIsT0FBTzBELFdBQVc7Z0JBQ2pDZ08sV0FBVyxPQUFPLHVDQUF1QztZQUMzRDtZQUVBLE1BQU1DLGVBQWU7bUJBQUlSO2dCQUFjRTthQUFRO1lBRS9DLG9DQUFvQztZQUNwQyxNQUFNLEVBQUV0UixPQUFPZ0ksV0FBVyxFQUFFLEdBQUcsTUFBTXpJLG1EQUFRQSxDQUMxQ29ELElBQUksQ0FBQyxRQUNMQyxNQUFNLENBQUM7Z0JBQUV5TyxjQUFjTztZQUFhLEdBQ3BDNU8sRUFBRSxDQUFDLE1BQU1tTztZQUVaLElBQUluSixhQUFhLE1BQU1BO1lBRXZCakksUUFBUXlDLEdBQUcsQ0FBQztZQUNaLE1BQU1vSCxZQUFZLGNBQWM7UUFDbEMsRUFBRSxPQUFPNUosT0FBTztZQUNkRCxRQUFRQyxLQUFLLENBQUMsc0JBQXNCQTtZQUNwQyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxNQUFNNlIscUJBQXFCLE9BQU9WLFFBQWdCVztRQUNoRCxJQUFJO1lBQ0YsK0JBQStCO1lBQy9CLE1BQU0sRUFBRTNNLE1BQU1sRCxRQUFRLEVBQUVqQyxPQUFPbUksVUFBVSxFQUFFLEdBQUcsTUFBTTVJLG1EQUFRQSxDQUN6RG9ELElBQUksQ0FBQyxRQUNMMEMsTUFBTSxDQUFDLGdDQUNQckMsRUFBRSxDQUFDLE1BQU1tTyxRQUNUN0wsTUFBTTtZQUVULElBQUk2QyxZQUFZLE1BQU1BO1lBRXRCLE1BQU00SixxQkFBcUI5UCxDQUFBQSxxQkFBQUEsK0JBQUFBLFNBQVVvUCxZQUFZLEtBQUksRUFBRTtZQUN2RCxNQUFNVyx1QkFBdUIvUCxDQUFBQSxxQkFBQUEsK0JBQUFBLFNBQVVnUSxjQUFjLEtBQUksRUFBRTtZQUUzRCwwQkFBMEI7WUFDMUIsTUFBTUMsZ0JBQWdCSCxtQkFBbUJwTixJQUFJLENBQUMsQ0FBQ3dCLE9BQWNBLEtBQUtsRCxFQUFFLEtBQUs2TztZQUN6RSxJQUFJLENBQUNJLGVBQWU7Z0JBQ2xCLE1BQU0sSUFBSW5HLE1BQU07WUFDbEI7WUFFQSwyQkFBMkI7WUFDM0IsTUFBTW9HLHFCQUFxQkosbUJBQW1CeE4sTUFBTSxDQUFDLENBQUM0QixPQUFjQSxLQUFLbEQsRUFBRSxLQUFLNk87WUFFaEYsK0NBQStDO1lBQy9DLE1BQU1NLGVBQWU7Z0JBQ25CLEdBQUdGLGFBQWE7Z0JBQ2hCRyxZQUFZLElBQUlwUyxPQUFPMEQsV0FBVztZQUNwQztZQUNBLE1BQU0yTyx1QkFBdUI7bUJBQUlOO2dCQUFzQkk7YUFBYTtZQUVwRSxxQkFBcUI7WUFDckIsTUFBTSxFQUFFcFMsT0FBT2dJLFdBQVcsRUFBRSxHQUFHLE1BQU16SSxtREFBUUEsQ0FDMUNvRCxJQUFJLENBQUMsUUFDTEMsTUFBTSxDQUFDO2dCQUNOeU8sY0FBY2M7Z0JBQ2RGLGdCQUFnQks7WUFDbEIsR0FDQ3RQLEVBQUUsQ0FBQyxNQUFNbU87WUFFWixJQUFJbkosYUFBYSxNQUFNQTtZQUV2QmpJLFFBQVF5QyxHQUFHLENBQUM7WUFDWixNQUFNb0gsWUFBWSxjQUFjO1FBQ2xDLEVBQUUsT0FBTzVKLE9BQU87WUFDZEQsUUFBUUMsS0FBSyxDQUFDLHdCQUF3QkE7WUFDdEMsTUFBTUE7UUFDUjtJQUNGO0lBRUEsV0FBVztJQUNYLE1BQU11UyxVQUFVLE9BQU9DO1FBQ3JCLElBQUk7WUFDRnpTLFFBQVF5QyxHQUFHLENBQUMsNkJBQTZCcUUsS0FBS0MsU0FBUyxDQUFDMEwsVUFBVSxNQUFNO1lBQ3hFLE1BQU0sRUFBRXJOLElBQUksRUFBRW5GLEtBQUssRUFBRSxHQUFHLE1BQU1ULG1EQUFRQSxDQUNuQ29ELElBQUksQ0FBQyxTQUNMeUMsTUFBTSxDQUFDO2dCQUFDb047YUFBUyxFQUNqQm5OLE1BQU0sR0FDTkMsTUFBTTtZQUVULElBQUl0RixPQUFPO2dCQUNURCxRQUFRQyxLQUFLLENBQUMsaUNBQWlDQTtnQkFDL0NELFFBQVFDLEtBQUssQ0FBQyxpQkFBaUJBLE1BQU11SCxJQUFJO2dCQUN6Q3hILFFBQVFDLEtBQUssQ0FBQyxvQkFBb0JBLE1BQU13TCxPQUFPO2dCQUMvQ3pMLFFBQVFDLEtBQUssQ0FBQyxvQkFBb0JBLE1BQU15UyxPQUFPO2dCQUMvQzFTLFFBQVFDLEtBQUssQ0FBQyxpQkFBaUJBLE1BQU11TixJQUFJO2dCQUN6QyxNQUFNdk47WUFDUjtZQUNBLE1BQU00SjtZQUNOLE9BQU96RTtRQUNULEVBQUUsT0FBT2pDLEtBQVU7WUFDakJuRCxRQUFRQyxLQUFLLENBQUMsc0JBQXNCa0Q7WUFDcENuRCxRQUFRQyxLQUFLLENBQUMsa0JBQWtCNkcsS0FBS0MsU0FBUyxDQUFDNUQsS0FBSyxNQUFNO1lBQzFELE1BQU1BO1FBQ1I7SUFDRjtJQUVBLGNBQWM7SUFDZCxNQUFNd1AsYUFBYSxPQUFPQyxRQUFnQmxGO1FBQ3hDLElBQUk7WUFDRixNQUFNLEVBQUV6TixLQUFLLEVBQUUsR0FBRyxNQUFNVCxtREFBUUEsQ0FDN0JvRCxJQUFJLENBQUMsU0FDTEMsTUFBTSxDQUFDNkssU0FDUHpLLEVBQUUsQ0FBQyxNQUFNMlA7WUFFWixJQUFJM1MsT0FBTyxNQUFNQTtZQUNqQixNQUFNNEo7UUFDUixFQUFFLE9BQU8xRyxLQUFLO1lBQ1puRCxRQUFRQyxLQUFLLENBQUMsd0JBQXdCa0Q7WUFDdEMsTUFBTUE7UUFDUjtJQUNGO0lBRUEsY0FBYztJQUNkLE1BQU0wUCxhQUFhLE9BQU9EO1FBQ3hCLElBQUk7WUFDRixNQUFNLEVBQUUzUyxLQUFLLEVBQUUsR0FBRyxNQUFNVCxtREFBUUEsQ0FDN0JvRCxJQUFJLENBQUMsU0FDTGdMLE1BQU0sR0FDTjNLLEVBQUUsQ0FBQyxNQUFNMlA7WUFFWixJQUFJM1MsT0FBTyxNQUFNQTtZQUNqQixNQUFNNEo7UUFDUixFQUFFLE9BQU8xRyxLQUFLO1lBQ1puRCxRQUFRQyxLQUFLLENBQUMsd0JBQXdCa0Q7WUFDdEMsTUFBTUE7UUFDUjtJQUNGO0lBRUEsZ0JBQWdCO0lBQ2hCLE1BQU0yUCxlQUFlLE9BQU9GO1FBQzFCLElBQUk7WUFDRiw2REFBNkQ7WUFDN0QsTUFBTSxFQUFFeE4sTUFBTXFOLFFBQVEsRUFBRXhTLE9BQU9tSSxVQUFVLEVBQUUsR0FBRyxNQUFNNUksbURBQVFBLENBQ3pEb0QsSUFBSSxDQUFDLFNBQ0wwQyxNQUFNLENBQUMsNkJBQ1ByQyxFQUFFLENBQUMsTUFBTTJQLFFBQ1RyTixNQUFNO1lBRVQsSUFBSTZDLFlBQVksTUFBTUE7WUFFdEIsTUFBTSxFQUFFbkksS0FBSyxFQUFFLEdBQUcsTUFBTVQsbURBQVFBLENBQzdCb0QsSUFBSSxDQUFDLFNBQ0xDLE1BQU0sQ0FBQztnQkFDTmtRLFdBQVc7Z0JBQ1hwRCxjQUFjLElBQUl6UCxPQUFPMEQsV0FBVztZQUN0QyxHQUNDWCxFQUFFLENBQUMsTUFBTTJQO1lBRVosSUFBSTNTLE9BQU8sTUFBTUE7WUFFakIsOEVBQThFO1lBQzlFLElBQUl3UyxxQkFBQUEsK0JBQUFBLFNBQVVPLHFCQUFxQixFQUFFO2dCQUNuQyxJQUFJO29CQUNGLE1BQU0sRUFBRS9TLE9BQU9nVCxVQUFVLEVBQUUsR0FBRyxNQUFNelQsbURBQVFBLENBQ3pDb0QsSUFBSSxDQUFDLGVBQ0xDLE1BQU0sQ0FBQzt3QkFDTnFRLGtCQUFrQjt3QkFDbEJDLGlCQUFpQjtvQkFDbkIsR0FDQ2xRLEVBQUUsQ0FBQyxNQUFNd1AsU0FBU08scUJBQXFCO29CQUUxQyxJQUFJQyxZQUFZO3dCQUNkalQsUUFBUUMsS0FBSyxDQUFDLDREQUE0RGdUO29CQUM1RTtnQkFDRixFQUFFLE9BQU9HLFVBQVU7b0JBQ2pCcFQsUUFBUUMsS0FBSyxDQUFDLDREQUE0RG1UO2dCQUM1RTtZQUNGO1lBRUEsTUFBTXZKO1FBQ1IsRUFBRSxPQUFPMUcsS0FBSztZQUNabkQsUUFBUUMsS0FBSyxDQUFDLDBCQUEwQmtEO1lBQ3hDLE1BQU1BO1FBQ1I7SUFDRjtJQUVBLGVBQWU7SUFDZixNQUFNa1EsY0FBYyxPQUFPQztRQUN6QixJQUFJO1lBQ0Z0VCxRQUFReUMsR0FBRyxDQUFDLGlDQUFpQ3FFLEtBQUtDLFNBQVMsQ0FBQ3VNLGNBQWMsTUFBTTtZQUNoRixNQUFNLEVBQUVsTyxJQUFJLEVBQUVuRixLQUFLLEVBQUUsR0FBRyxNQUFNVCxtREFBUUEsQ0FDbkNvRCxJQUFJLENBQUMsYUFDTHlDLE1BQU0sQ0FBQztnQkFBQ2lPO2FBQWEsRUFDckJoTyxNQUFNLEdBQ05DLE1BQU07WUFFVCxJQUFJdEYsT0FBTztnQkFDVEQsUUFBUUMsS0FBSyxDQUFDLHFDQUFxQ0E7Z0JBQ25ERCxRQUFRQyxLQUFLLENBQUMsaUJBQWlCQSxNQUFNdUgsSUFBSTtnQkFDekN4SCxRQUFRQyxLQUFLLENBQUMsb0JBQW9CQSxNQUFNd0wsT0FBTztnQkFDL0N6TCxRQUFRQyxLQUFLLENBQUMsb0JBQW9CQSxNQUFNeVMsT0FBTztnQkFDL0MxUyxRQUFRQyxLQUFLLENBQUMsaUJBQWlCQSxNQUFNdU4sSUFBSTtnQkFDekMsTUFBTXZOO1lBQ1I7WUFDQSxNQUFNNEo7WUFDTixPQUFPekU7UUFDVCxFQUFFLE9BQU9qQyxLQUFVO1lBQ2pCbkQsUUFBUUMsS0FBSyxDQUFDLDBCQUEwQmtEO1lBQ3hDbkQsUUFBUUMsS0FBSyxDQUFDLGtCQUFrQjZHLEtBQUtDLFNBQVMsQ0FBQzVELEtBQUssTUFBTTtZQUMxRCxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxrQkFBa0I7SUFDbEIsTUFBTW9RLGlCQUFpQixPQUFPQyxZQUFvQjlGO1FBQ2hELElBQUk7WUFDRixNQUFNLEVBQUV6TixLQUFLLEVBQUUsR0FBRyxNQUFNVCxtREFBUUEsQ0FDN0JvRCxJQUFJLENBQUMsYUFDTEMsTUFBTSxDQUFDNkssU0FDUHpLLEVBQUUsQ0FBQyxNQUFNdVE7WUFFWixJQUFJdlQsT0FBTyxNQUFNQTtZQUNqQixNQUFNNEo7UUFDUixFQUFFLE9BQU8xRyxLQUFLO1lBQ1puRCxRQUFRQyxLQUFLLENBQUMsNEJBQTRCa0Q7WUFDMUMsTUFBTUE7UUFDUjtJQUNGO0lBRUEsa0JBQWtCO0lBQ2xCLE1BQU1zUSxpQkFBaUIsT0FBT0Q7UUFDNUIsSUFBSTtZQUNGLE1BQU0sRUFBRXZULEtBQUssRUFBRSxHQUFHLE1BQU1ULG1EQUFRQSxDQUM3Qm9ELElBQUksQ0FBQyxhQUNMZ0wsTUFBTSxHQUNOM0ssRUFBRSxDQUFDLE1BQU11UTtZQUVaLElBQUl2VCxPQUFPLE1BQU1BO1lBQ2pCLE1BQU00SjtRQUNSLEVBQUUsT0FBTzFHLEtBQUs7WUFDWm5ELFFBQVFDLEtBQUssQ0FBQyw0QkFBNEJrRDtZQUMxQyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxPQUFPO1FBQ0xxRjtRQUNBSDtRQUNBTTtRQUNBRTtRQUNBRTtRQUNBRTtRQUNBRztRQUNBRTtRQUNBRTtRQUNBdko7UUFDQTRKO1FBQ0FGO1FBQ0EsTUFBTStKLGlCQUFnQnRDLE1BQWMsRUFBRXRGLEtBQW9CO1lBQ3hELElBQUk7Z0JBQ0YsSUFBSSxDQUFDc0YsUUFBUTtnQkFDYixJQUFJdEYsT0FBTztvQkFDVCxlQUFlO29CQUNmLE1BQU0sRUFBRTdMLE9BQU8wVCxXQUFXLEVBQUUsR0FBRyxNQUFNblUsbURBQVFBLENBQzFDb0QsSUFBSSxDQUFDLG1CQUNMZ1IsTUFBTSxDQUFDO3dCQUFFL0gsU0FBU3VGO3dCQUFRdEY7b0JBQU0sR0FBRzt3QkFBRStILFlBQVk7b0JBQVU7b0JBQzlELElBQUlGLGFBQWEsTUFBTUE7Z0JBQ3pCLE9BQU87b0JBQ0wsZUFBZTtvQkFDZixNQUFNLEVBQUUxVCxPQUFPNlQsUUFBUSxFQUFFLEdBQUcsTUFBTXRVLG1EQUFRQSxDQUN2Q29ELElBQUksQ0FBQyxtQkFDTGdMLE1BQU0sR0FDTjNLLEVBQUUsQ0FBQyxXQUFXbU87b0JBQ2pCLElBQUkwQyxVQUFVLE1BQU1BO2dCQUN0QjtnQkFDQSxxQkFBcUI7Z0JBQ3JCbEssaUJBQWlCLENBQUNtSztvQkFDaEIsTUFBTUMsT0FBTzt3QkFBRSxHQUFHRCxJQUFJO29CQUFDO29CQUN2QixJQUFJakksT0FBT2tJLElBQUksQ0FBQzVDLE9BQU8sR0FBR3RGO3lCQUNyQixPQUFPa0ksSUFBSSxDQUFDNUMsT0FBTztvQkFDeEIsT0FBTzRDO2dCQUNUO1lBQ0YsRUFBRSxPQUFPakksR0FBRztnQkFDVixNQUFNNUksTUFBVzRJO2dCQUNqQixNQUFNUCxNQUFNckksQ0FBQUEsZ0JBQUFBLDBCQUFBQSxJQUFLc0ksT0FBTyxLQUFLLFFBQU90SSxRQUFRLFdBQVdBLE1BQU0yRCxLQUFLQyxTQUFTLENBQUM1RCxJQUFHO2dCQUMvRW5ELFFBQVFDLEtBQUssQ0FBQyxpQ0FBaUN1TDtnQkFDL0MsOENBQThDO2dCQUM5QyxJQUFJQSxDQUFBQSxnQkFBQUEsMEJBQUFBLElBQUtyTCxRQUFRLENBQUMsaUJBQWVxTCxnQkFBQUEsMEJBQUFBLElBQUtyTCxRQUFRLENBQUMscUJBQW9CO29CQUNqRUgsUUFBUWlLLElBQUksQ0FBQztnQkFDZjtnQkFDQSxNQUFNOEI7WUFDUjtRQUNGO1FBQ0FpQjtRQUNBUztRQUNBRTtRQUNBRTtRQUNBRTtRQUNBQztRQUNBQztRQUNBRTtRQUNBQztRQUNBa0I7UUFDQUM7UUFDQUU7UUFDQUc7UUFDQVk7UUFDQUU7UUFDQU07UUFDQUM7UUFDQWhOO1FBQ0E0TTtRQUNBQztRQUNBQztRQUNBSTtRQUNBVztRQUNBVTtRQUNBRztRQUNBRTtRQUNBQztRQUNBTztRQUNBRTtRQUNBRTtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxEZXZcXGJhbWFsaXRlLWhyLXN5c3RlbSBCZW1hbm5pbmdzbGlqc3RcXGhvb2tzXFx1c2Utc3VwYWJhc2UtZGF0YS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBzdXBhYmFzZSB9IGZyb20gJ0AvbGliL3N1cGFiYXNlJ1xuXG4vLyBGdW5jdGlvbiB0byBjYWxjdWxhdGUgd29yayBkYXlzIGZvciB2YXN0ZSBkaWVuc3QgYWZsb3NzZXJzIGJhc2VkIG9uIGhvdXJzXG4vLyBVc2VzIDEyLWhvdXIgaW5jcmVtZW50czogMC0xMmggPSAwLjUgZGF5LCAxMi0yNGggPSAxLjAgZGF5LCBldGMuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlV29ya0RheXNWYXN0ZURpZW5zdChzdGFydERhdGU6IHN0cmluZywgc3RhcnRUaW1lOiBzdHJpbmcsIGVuZERhdGU6IHN0cmluZywgZW5kVGltZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgaWYgKCFzdGFydERhdGUgfHwgIWVuZERhdGUgfHwgIXN0YXJ0VGltZSB8fCAhZW5kVGltZSkgcmV0dXJuIDBcblxuICAvLyBQYXJzZSBib3RoIERELU1NLVlZWVkgYW5kIElTTyBmb3JtYXQgZGF0ZXNcbiAgY29uc3QgcGFyc2VEYXRlID0gKGRhdGVTdHI6IHN0cmluZyk6IERhdGUgPT4ge1xuICAgIGlmICghZGF0ZVN0ciB8fCB0eXBlb2YgZGF0ZVN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgZGF0ZSBzdHJpbmc6JywgZGF0ZVN0cilcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpIC8vIFJldHVybiBjdXJyZW50IGRhdGUgYXMgZmFsbGJhY2tcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgaXQncyBhbHJlYWR5IGFuIElTTyBkYXRlIChjb250YWlucyBUIG9yIGhhcyA0LWRpZ2l0IHllYXIgYXQgc3RhcnQpXG4gICAgaWYgKGRhdGVTdHIuaW5jbHVkZXMoJ1QnKSB8fCAvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9Ly50ZXN0KGRhdGVTdHIpKSB7XG4gICAgICAvLyBJdCdzIGFscmVhZHkgYW4gSVNPIGRhdGUsIHVzZSBpdCBkaXJlY3RseVxuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGRhdGVTdHIpXG4gICAgICBpZiAoaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgSVNPIGRhdGU6JywgZGF0ZVN0cilcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkgLy8gUmV0dXJuIGN1cnJlbnQgZGF0ZSBhcyBmYWxsYmFja1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGVcbiAgICB9XG4gICAgXG4gICAgLy8gT3RoZXJ3aXNlLCBwYXJzZSBhcyBERC1NTS1ZWVlZIGZvcm1hdFxuICAgIGNvbnN0IHBhcnRzID0gZGF0ZVN0ci5zcGxpdCgnLScpXG4gICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBkYXRlIGZvcm1hdDonLCBkYXRlU3RyKVxuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkgLy8gUmV0dXJuIGN1cnJlbnQgZGF0ZSBhcyBmYWxsYmFja1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBkYXkgPSBwYXJzZUludChwYXJ0c1swXSwgMTApXG4gICAgY29uc3QgbW9udGggPSBwYXJzZUludChwYXJ0c1sxXSwgMTApIC0gMSAvLyBKYXZhU2NyaXB0IG1vbnRocyBhcmUgMC1iYXNlZFxuICAgIGNvbnN0IHllYXIgPSBwYXJzZUludChwYXJ0c1syXSwgMTApXG4gICAgXG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXkpXG4gICAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBwYXJzZWQgZGF0ZTonLCBkYXRlU3RyKVxuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkgLy8gUmV0dXJuIGN1cnJlbnQgZGF0ZSBhcyBmYWxsYmFja1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZGF0ZVxuICB9XG5cbiAgLy8gUGFyc2UgdGltZSBzdHJpbmcgKEhIOk1NOlNTIG9yIEhIOk1NIGZvcm1hdClcbiAgY29uc3QgcGFyc2VUaW1lID0gKHRpbWVTdHI6IHN0cmluZyk6IG51bWJlciA9PiB7XG4gICAgaWYgKCF0aW1lU3RyIHx8IHR5cGVvZiB0aW1lU3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCB0aW1lIHN0cmluZzonLCB0aW1lU3RyKVxuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gICAgXG4gICAgY29uc3QgdGltZVBhcnRzID0gdGltZVN0ci5zcGxpdCgnOicpXG4gICAgaWYgKHRpbWVQYXJ0cy5sZW5ndGggPCAyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIHRpbWUgZm9ybWF0OicsIHRpbWVTdHIpXG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgICBcbiAgICBjb25zdCBob3VycyA9IHBhcnNlSW50KHRpbWVQYXJ0c1swXSwgMTApXG4gICAgY29uc3QgbWludXRlcyA9IHBhcnNlSW50KHRpbWVQYXJ0c1sxXSwgMTApXG4gICAgXG4gICAgaWYgKGlzTmFOKGhvdXJzKSB8fCBpc05hTihtaW51dGVzKSkge1xuICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCB0aW1lIHZhbHVlczonLCB0aW1lU3RyKVxuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGhvdXJzICsgKG1pbnV0ZXMgLyA2MClcbiAgfVxuXG4gIGNvbnN0IHN0YXJ0ID0gcGFyc2VEYXRlKHN0YXJ0RGF0ZSlcbiAgY29uc3QgZW5kID0gcGFyc2VEYXRlKGVuZERhdGUpXG4gIGNvbnN0IHN0YXJ0VGltZUhvdXJzID0gcGFyc2VUaW1lKHN0YXJ0VGltZSlcbiAgY29uc3QgZW5kVGltZUhvdXJzID0gcGFyc2VUaW1lKGVuZFRpbWUpXG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3I6IGVuZCBkYXRlIGlzIGJlZm9yZSBzdGFydCBkYXRlJylcbiAgICByZXR1cm4gMFxuICB9XG5cbiAgLy8gQ3JlYXRlIGZ1bGwgZGF0ZXRpbWUgb2JqZWN0c1xuICBjb25zdCBzdGFydERhdGVUaW1lID0gbmV3IERhdGUoc3RhcnQpXG4gIHN0YXJ0RGF0ZVRpbWUuc2V0SG91cnMoTWF0aC5mbG9vcihzdGFydFRpbWVIb3VycyksIChzdGFydFRpbWVIb3VycyAlIDEpICogNjAsIDAsIDApXG5cbiAgY29uc3QgZW5kRGF0ZVRpbWUgPSBuZXcgRGF0ZShlbmQpXG4gIGVuZERhdGVUaW1lLnNldEhvdXJzKE1hdGguZmxvb3IoZW5kVGltZUhvdXJzKSwgKGVuZFRpbWVIb3VycyAlIDEpICogNjAsIDAsIDApXG5cbiAgLy8gQ2FsY3VsYXRlIGR1cmF0aW9uIGluIGhvdXJzXG4gIGNvbnN0IHRpbWVEaWZmTXMgPSBlbmREYXRlVGltZS5nZXRUaW1lKCkgLSBzdGFydERhdGVUaW1lLmdldFRpbWUoKVxuICBjb25zdCB0b3RhbEhvdXJzID0gdGltZURpZmZNcyAvICgxMDAwICogNjAgKiA2MClcblxuICAvLyBDb252ZXJ0IHRvIGRheSBjcmVkaXRzIHVzaW5nIDEyLWhvdXIgaW5jcmVtZW50c1xuICAvLyBGb3JtdWxhOiBjcmVkaXRzID0gY2VpbChob3VycyAvIDEyKSAqIDAuNVxuICBjb25zdCBkYXlDcmVkaXRzID0gTWF0aC5jZWlsKHRvdGFsSG91cnMgLyAxMikgKiAwLjVcblxuICByZXR1cm4gZGF5Q3JlZGl0c1xufVxuXG4vLyBGdW5jdGllIG9tIGF1dG9tYXRpc2NoIGNyZXcgbWVtYmVycyB0ZSBhY3RpdmVyZW4gb3AgaHVuIHN0YXJ0ZGF0dW1cbmFzeW5jIGZ1bmN0aW9uIGF1dG9BY3RpdmF0ZUNyZXdNZW1iZXJzKGNyZXdEYXRhOiBhbnlbXSkge1xuICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKClcbiAgdG9kYXkuc2V0SG91cnMoMCwgMCwgMCwgMCkgLy8gUmVzZXQgbmFhciBzdGFydCB2YW4gZGUgZGFnXG4gIFxuICBmb3IgKGNvbnN0IG1lbWJlciBvZiBjcmV3RGF0YSkge1xuICAgIC8vIENoZWNrIG9mIGRlemUgcGVyc29vbiBtb2V0IHdvcmRlbiBnZWFjdGl2ZWVyZFxuICAgIC8vIFN0YXR1cyBrYW4gXCJ0aHVpc1wiIHppam4gKHdhY2h0ZW5kIG9wIHN0YXJ0ZGF0dW0pIG9mIFwibm9nLWluLXRlLWRlbGVuXCJcbiAgICBpZiAoXG4gICAgICAobWVtYmVyLnN0YXR1cyA9PT0gJ3RodWlzJyB8fCBtZW1iZXIuc3RhdHVzID09PSAnbm9nLWluLXRlLWRlbGVuJykgJiZcbiAgICAgIG1lbWJlci5leHBlY3RlZF9zdGFydF9kYXRlICYmXG4gICAgICBtZW1iZXIuc2hpcF9pZCAmJlxuICAgICAgbWVtYmVyLnJlZ2ltZVxuICAgICkge1xuICAgICAgY29uc3Qgc3RhcnREYXRlID0gbmV3IERhdGUobWVtYmVyLmV4cGVjdGVkX3N0YXJ0X2RhdGUpXG4gICAgICBzdGFydERhdGUuc2V0SG91cnMoMCwgMCwgMCwgMClcbiAgICAgIFxuICAgICAgLy8gSXMgdmFuZGFhZyA+PSBzdGFydGRhdHVtP1xuICAgICAgaWYgKHRvZGF5ID49IHN0YXJ0RGF0ZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+agCBBdXRvLWFjdGl2YXRpbmcgJHttZW1iZXIuZmlyc3RfbmFtZX0gJHttZW1iZXIubGFzdF9uYW1lfSAtIFN0YXJ0IGRhdGUgcmVhY2hlZCFgKVxuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBVcGRhdGUgbmFhciBcImFhbi1ib29yZFwiIHN0YXR1c1xuICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAuZnJvbSgnY3JldycpXG4gICAgICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICAgICAgc3RhdHVzOiAnYWFuLWJvb3JkJyxcbiAgICAgICAgICAgICAgb25fYm9hcmRfc2luY2U6IG1lbWJlci5leHBlY3RlZF9zdGFydF9kYXRlLFxuICAgICAgICAgICAgICB0aHVpc19zaW5kczogbnVsbCwgLy8gQ2xlYXIgdGh1aXNfc2luZHMgKHdhcyB0aHVpcywgbnUgYWFuIGJvb3JkKVxuICAgICAgICAgICAgICBleHBlY3RlZF9zdGFydF9kYXRlOiBudWxsLCAvLyBDbGVhciBleHBlY3RlZF9zdGFydF9kYXRlXG4gICAgICAgICAgICAgIHN1Yl9zdGF0dXM6IG51bGwgLy8gQ2xlYXIgc3ViX3N0YXR1c1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5lcSgnaWQnLCBtZW1iZXIuaWQpXG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhdXRvLWFjdGl2YXRpbmcgY3JldyBtZW1iZXI6JywgZXJyb3IpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgJHttZW1iZXIuZmlyc3RfbmFtZX0gJHttZW1iZXIubGFzdF9uYW1lfSBpcyBub3cgYWN0aXZlIWApXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBhdXRvLWFjdGl2YXRpb246JywgZXJyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEZ1bmN0aWUgb20gYXV0b21hdGlzY2ggcm90YXRpZXMgdWl0IHRlIHZvZXJlblxuYXN5bmMgZnVuY3Rpb24gYXV0b1JvdGF0ZUNyZXdNZW1iZXJzKGNyZXdEYXRhOiBhbnlbXSkge1xuICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKClcbiAgdG9kYXkuc2V0SG91cnMoMCwgMCwgMCwgMClcbiAgXG4gIGZvciAoY29uc3QgbWVtYmVyIG9mIGNyZXdEYXRhKSB7XG4gICAgLy8gU2tpcCBhbHMgZ2VlbiByZWdpbWUsIHppZWssIG9mIFwiQWx0aWpkXCJcbiAgICBpZiAoIW1lbWJlci5yZWdpbWUgfHwgbWVtYmVyLnN0YXR1cyA9PT0gJ3ppZWsnIHx8IG1lbWJlci5yZWdpbWUgPT09ICdBbHRpamQnKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBcbiAgICBjb25zdCByZWdpbWVXZWVrcyA9IHBhcnNlSW50KG1lbWJlci5yZWdpbWUuc3BsaXQoJy8nKVswXSlcbiAgICBjb25zdCByZWdpbWVEYXlzID0gcmVnaW1lV2Vla3MgKiA3XG4gICAgXG4gICAgLy8gQ2hlY2sgb2YgaWVtYW5kIHZhbiBhYW4tYm9vcmQgbmFhciB0aHVpcyBtb2V0XG4gICAgaWYgKG1lbWJlci5zdGF0dXMgPT09ICdhYW4tYm9vcmQnICYmIG1lbWJlci5vbl9ib2FyZF9zaW5jZSkge1xuICAgICAgY29uc3Qgb25Cb2FyZERhdGUgPSBuZXcgRGF0ZShtZW1iZXIub25fYm9hcmRfc2luY2UpXG4gICAgICBvbkJvYXJkRGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKVxuICAgICAgXG4gICAgICBjb25zdCBkYXlzU2luY2VPbkJvYXJkID0gTWF0aC5mbG9vcigodG9kYXkuZ2V0VGltZSgpIC0gb25Cb2FyZERhdGUuZ2V0VGltZSgpKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KSlcbiAgICAgIFxuICAgICAgaWYgKGRheXNTaW5jZU9uQm9hcmQgPj0gcmVnaW1lRGF5cykge1xuICAgICAgICBjb25zdCB0aHVpc1NpbmRzID0gbmV3IERhdGUob25Cb2FyZERhdGUpXG4gICAgICAgIHRodWlzU2luZHMuc2V0RGF0ZSh0aHVpc1NpbmRzLmdldERhdGUoKSArIHJlZ2ltZURheXMpXG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhg8J+UhCBBdXRvLXJvdGF0aW5nICR7bWVtYmVyLmZpcnN0X25hbWV9ICR7bWVtYmVyLmxhc3RfbmFtZX0gdG8gVEhVSVNgKVxuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgLmZyb20oJ2NyZXcnKVxuICAgICAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgICAgIHN0YXR1czogJ3RodWlzJyxcbiAgICAgICAgICAgICAgdGh1aXNfc2luZHM6IHRodWlzU2luZHMudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxuICAgICAgICAgICAgICBvbl9ib2FyZF9zaW5jZTogbnVsbFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5lcSgnaWQnLCBtZW1iZXIuaWQpXG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByb3RhdGluZyB0byB0aHVpczonLCBlcnJvcilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSAke21lbWJlci5maXJzdF9uYW1lfSBpcyBub3cgdGh1aXNgKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gcm90YXRpb246JywgZXJyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIG9mIGllbWFuZCB2YW4gdGh1aXMgbmFhciBhYW4tYm9vcmQgbW9ldFxuICAgIGlmIChtZW1iZXIuc3RhdHVzID09PSAndGh1aXMnICYmIG1lbWJlci50aHVpc19zaW5kcykge1xuICAgICAgY29uc3QgdGh1aXNEYXRlID0gbmV3IERhdGUobWVtYmVyLnRodWlzX3NpbmRzKVxuICAgICAgdGh1aXNEYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApXG4gICAgICBcbiAgICAgIGNvbnN0IGRheXNTaW5jZVRodWlzID0gTWF0aC5mbG9vcigodG9kYXkuZ2V0VGltZSgpIC0gdGh1aXNEYXRlLmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpXG4gICAgICBcbiAgICAgIGlmIChkYXlzU2luY2VUaHVpcyA+PSByZWdpbWVEYXlzKSB7XG4gICAgICAgIGNvbnN0IG9uQm9hcmRTaW5jZSA9IG5ldyBEYXRlKHRodWlzRGF0ZSlcbiAgICAgICAgb25Cb2FyZFNpbmNlLnNldERhdGUob25Cb2FyZFNpbmNlLmdldERhdGUoKSArIHJlZ2ltZURheXMpXG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhg8J+UhCBBdXRvLXJvdGF0aW5nICR7bWVtYmVyLmZpcnN0X25hbWV9ICR7bWVtYmVyLmxhc3RfbmFtZX0gdG8gQUFOLUJPT1JEYClcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5mcm9tKCdjcmV3JylcbiAgICAgICAgICAgIC51cGRhdGUoe1xuICAgICAgICAgICAgICBzdGF0dXM6ICdhYW4tYm9vcmQnLFxuICAgICAgICAgICAgICBvbl9ib2FyZF9zaW5jZTogb25Cb2FyZFNpbmNlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcbiAgICAgICAgICAgICAgdGh1aXNfc2luZHM6IG51bGxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZXEoJ2lkJywgbWVtYmVyLmlkKVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igcm90YXRpbmcgdG8gYWFuLWJvb3JkOicsIGVycm9yKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFICR7bWVtYmVyLmZpcnN0X25hbWV9IGlzIG5vdyBhYW4tYm9vcmRgKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gcm90YXRpb246JywgZXJyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEZ1bmN0aWUgb20gYXV0b21hdGlzY2ggdmFzdGUgZGllbnN0IHJlY29yZHMgdGUgYmVoZXJlblxuYXN5bmMgZnVuY3Rpb24gYXV0b01hbmFnZVZhc3RlRGllbnN0UmVjb3JkcyhjcmV3RGF0YTogYW55W10sIHZhc3RlRGllbnN0UmVjb3JkczogYW55W10sIHRyaXBzRGF0YTogYW55W10pIHtcbiAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpXG4gIGNvbnN0IGN1cnJlbnRZZWFyID0gdG9kYXkuZ2V0RnVsbFllYXIoKVxuICBjb25zdCBjdXJyZW50TW9udGggPSB0b2RheS5nZXRNb250aCgpICsgMSAvLyBKYXZhU2NyaXB0IG1vbnRocyBhcmUgMC1iYXNlZFxuICBcbiAgY29uc29sZS5sb2coYPCflKcgQXV0by1tYW5hZ2luZyB2YXN0ZSBkaWVuc3QgcmVjb3JkcyBmb3IgJHtjdXJyZW50WWVhcn0tJHtjdXJyZW50TW9udGh9YClcbiAgXG4gIC8vIEdldCBhbGwgYWZsb3NzZXJzIGluIHZhc3RlIGRpZW5zdFxuICBjb25zdCB2YXN0ZURpZW5zdEFmbG9zc2VycyA9IGNyZXdEYXRhLmZpbHRlcihtZW1iZXIgPT4gbWVtYmVyLnZhc3RlX2RpZW5zdCA9PT0gdHJ1ZSlcbiAgXG4gIGZvciAoY29uc3QgYWZsb3NzZXIgb2YgdmFzdGVEaWVuc3RBZmxvc3NlcnMpIHtcbiAgICBjb25zb2xlLmxvZyhg8J+TiyBQcm9jZXNzaW5nIHZhc3RlIGRpZW5zdCBhZmxvc3NlcjogJHthZmxvc3Nlci5maXJzdF9uYW1lfSAke2FmbG9zc2VyLmxhc3RfbmFtZX1gKVxuICAgIFxuICAgIC8vIENoZWNrIGlmIGN1cnJlbnQgbW9udGggcmVjb3JkIGV4aXN0c1xuICAgIGNvbnN0IGV4aXN0aW5nUmVjb3JkID0gdmFzdGVEaWVuc3RSZWNvcmRzLmZpbmQocmVjb3JkID0+IFxuICAgICAgcmVjb3JkLmFmbG9zc2VyX2lkID09PSBhZmxvc3Nlci5pZCAmJiBcbiAgICAgIHJlY29yZC55ZWFyID09PSBjdXJyZW50WWVhciAmJiBcbiAgICAgIHJlY29yZC5tb250aCA9PT0gY3VycmVudE1vbnRoXG4gICAgKVxuICAgIFxuICAgIGlmICghZXhpc3RpbmdSZWNvcmQpIHtcbiAgICAgIC8vIENyZWF0ZSBuZXcgbW9udGhseSByZWNvcmRcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OFIENyZWF0aW5nIG5ldyBtb250aGx5IHJlY29yZCBmb3IgJHthZmxvc3Nlci5maXJzdF9uYW1lfSAke2FmbG9zc2VyLmxhc3RfbmFtZX1gKVxuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBuZXdSZWNvcmQgPSB7XG4gICAgICAgICAgYWZsb3NzZXJfaWQ6IGFmbG9zc2VyLmlkLFxuICAgICAgICAgIHllYXI6IGN1cnJlbnRZZWFyLFxuICAgICAgICAgIG1vbnRoOiBjdXJyZW50TW9udGgsXG4gICAgICAgICAgcmVxdWlyZWRfZGF5czogMTUsIC8vIFN0YW5kYXJkIDE1IGRheXMgcGVyIG1vbnRoXG4gICAgICAgICAgYWN0dWFsX2RheXM6IDAsIC8vIFdpbGwgYmUgY2FsY3VsYXRlZCBmcm9tIHRyaXBzXG4gICAgICAgICAgYmFsYW5jZV9kYXlzOiAwLCAvLyBXaWxsIGJlIGNhbGN1bGF0ZWRcbiAgICAgICAgICBub3RlczogYEF1dG9tYXRpc2NoIGFhbmdlbWFha3Qgdm9vciAke2N1cnJlbnRZZWFyfS0ke2N1cnJlbnRNb250aH1gXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ3Zhc3RlX2RpZW5zdF9yZWNvcmRzJylcbiAgICAgICAgICAuaW5zZXJ0KFtuZXdSZWNvcmRdKVxuICAgICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAgIC5zaW5nbGUoKVxuICAgICAgICBcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgdmFzdGUgZGllbnN0IHJlY29yZDonLCBlcnJvcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIENyZWF0ZWQgbW9udGhseSByZWNvcmQgZm9yICR7YWZsb3NzZXIuZmlyc3RfbmFtZX1gKVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gdmFzdGUgZGllbnN0IHJlY29yZCBjcmVhdGlvbjonLCBlcnIpXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBhY3R1YWwgZGF5cyBmcm9tIGNvbXBsZXRlZCB0cmlwcyBmb3IgY3VycmVudCBtb250aFxuICAgIGNvbnN0IGN1cnJlbnRNb250aFRyaXBzID0gdHJpcHNEYXRhLmZpbHRlcih0cmlwID0+IFxuICAgICAgdHJpcC5hZmxvc3Nlcl9pZCA9PT0gYWZsb3NzZXIuaWQgJiYgXG4gICAgICB0cmlwLnN0YXR1cyA9PT0gJ3ZvbHRvb2lkJyAmJlxuICAgICAgdHJpcC5laW5kX2RhdHVtICYmXG4gICAgICBuZXcgRGF0ZSh0cmlwLmVpbmRfZGF0dW0pLmdldEZ1bGxZZWFyKCkgPT09IGN1cnJlbnRZZWFyICYmXG4gICAgICBuZXcgRGF0ZSh0cmlwLmVpbmRfZGF0dW0pLmdldE1vbnRoKCkgKyAxID09PSBjdXJyZW50TW9udGhcbiAgICApXG4gICAgXG4gICAgbGV0IHRvdGFsV29ya0RheXMgPSAwXG4gICAgZm9yIChjb25zdCB0cmlwIG9mIGN1cnJlbnRNb250aFRyaXBzKSB7XG4gICAgICBjb25zdCB3b3JrRGF5cyA9IGNhbGN1bGF0ZVdvcmtEYXlzKHRyaXAuc3RhcnRfZGF0dW0sIHRyaXAuc3RhcnRfdGlqZCwgdHJpcC5laW5kX2RhdHVtLCB0cmlwLmVpbmRfdGlqZClcbiAgICAgIHRvdGFsV29ya0RheXMgKz0gd29ya0RheXNcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIHRoZSByZWNvcmQgd2l0aCBhY3R1YWwgZGF5cyBhbmQgYmFsYW5jZVxuICAgIGlmIChleGlzdGluZ1JlY29yZCkge1xuICAgICAgY29uc3QgcmVxdWlyZWREYXlzID0gMTVcbiAgICAgIFxuICAgICAgLy8gQ09SUkVDVEUgQkVSRUtFTklORzogRWluZHNhbGRvID0gQmVnaW5zYWxkbyArIChHZXdlcmt0IC0gMTUpXG4gICAgICAvLyBWb29yIGVlcnN0ZSBtYWFuZDogQmVnaW5zYWxkbyA9IC0xNSArIHN0YXJ0c2FsZG9cbiAgICAgIGxldCBiZWdpbnNhbGRvID0gZXhpc3RpbmdSZWNvcmQuYmFsYW5jZV9kYXlzIHx8IDBcbiAgICAgIFxuICAgICAgLy8gQWxzIGRpdCBkZSBlZXJzdGUgbWFhbmQgaXMgZW4gZXIgaXMgZ2VlbiBiZWdpbnNhbGRvLCBnZWJydWlrIC0xNSArIHN0YXJ0c2FsZG9cbiAgICAgIGlmIChiZWdpbnNhbGRvID09PSAwICYmIGN1cnJlbnRNb250aCA9PT0gMSkge1xuICAgICAgICAvLyBQcm9iZWVyIHN0YXJ0c2FsZG8gdWl0IG5vdGVzIHRlIGhhbGVuXG4gICAgICAgIGNvbnN0IHN0YXJ0c2FsZG9Ob3RlID0gYWZsb3NzZXIubm90ZXM/LmZpbmQoKG5vdGU6IGFueSkgPT4gXG4gICAgICAgICAgbm90ZS50ZXh0ICYmIChub3RlLnRleHQuaW5jbHVkZXMoJ3N0YXJ0c2FsZG8nKSB8fCBub3RlLnRleHQuaW5jbHVkZXMoJ1N0YXJ0c2FsZG8nKSlcbiAgICAgICAgKVxuICAgICAgICBpZiAoc3RhcnRzYWxkb05vdGUpIHtcbiAgICAgICAgICBjb25zdCBtYXRjaCA9IHN0YXJ0c2FsZG9Ob3RlLnRleHQubWF0Y2goLygtP1xcZCsoPzpcXC5cXGQrKT8pLylcbiAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0c2FsZG8gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKVxuICAgICAgICAgICAgYmVnaW5zYWxkbyA9IC0xNSArIHN0YXJ0c2FsZG9cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OKIEVlcnN0ZSBtYWFuZDogc3RhcnRzYWxkbyAke3N0YXJ0c2FsZG99LCBiZWdpbnNhbGRvICR7YmVnaW5zYWxkb31gKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmVnaW5zYWxkbyA9PT0gMCkgYmVnaW5zYWxkbyA9IC0xNSAvLyBGYWxsYmFja1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBWb29yIGRlIGVlcnN0ZSBtYWFuZDogdG9vbiBoZXQgYmVnaW5zYWxkbyBhbHMgaHVpZGlnIHNhbGRvXG4gICAgICAvLyBWb29yIHZvbGdlbmRlIG1hYW5kZW46IGJlcmVrZW4gaGV0IGVpbmRzYWxkb1xuICAgICAgbGV0IGJhbGFuY2VEYXlzXG4gICAgICBpZiAoY3VycmVudE1vbnRoID09PSAxICYmIGJlZ2luc2FsZG8gIT09IC0xNSkge1xuICAgICAgICAvLyBFZXJzdGUgbWFhbmQgbWV0IHN0YXJ0c2FsZG86IHRvb24gYmVnaW5zYWxkb1xuICAgICAgICBiYWxhbmNlRGF5cyA9IGJlZ2luc2FsZG9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vcm1hbGUgYmVyZWtlbmluZzogYmVnaW5zYWxkbyArIChnZXdlcmt0IC0gMTUpXG4gICAgICAgIGJhbGFuY2VEYXlzID0gYmVnaW5zYWxkbyArICh0b3RhbFdvcmtEYXlzIC0gcmVxdWlyZWREYXlzKVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDYXAgdmFsdWVzIHRvIGZpdCBpbiBERUNJTUFMKDQsMSkgLSBtYXggOTk5LjlcbiAgICAgIGNvbnN0IGNhcHBlZEFjdHVhbERheXMgPSBNYXRoLm1pbih0b3RhbFdvcmtEYXlzLCA5OTkuOSlcbiAgICAgIGNvbnN0IGNhcHBlZEJhbGFuY2VEYXlzID0gTWF0aC5taW4oTWF0aC5tYXgoYmFsYW5jZURheXMsIC05OTkuOSksIDk5OS45KVxuICAgICAgXG4gICAgICBpZiAoZXhpc3RpbmdSZWNvcmQuYWN0dWFsX2RheXMgIT09IGNhcHBlZEFjdHVhbERheXMgfHwgZXhpc3RpbmdSZWNvcmQuYmFsYW5jZV9kYXlzICE9PSBjYXBwZWRCYWxhbmNlRGF5cykge1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiBVcGRhdGluZyByZWNvcmQgZm9yICR7YWZsb3NzZXIuZmlyc3RfbmFtZX06ICR7Y2FwcGVkQWN0dWFsRGF5c30gZGF5cyAoYmFsYW5jZTogJHtjYXBwZWRCYWxhbmNlRGF5c30pYClcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ3Zhc3RlX2RpZW5zdF9yZWNvcmRzJylcbiAgICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICAgIGFjdHVhbF9kYXlzOiBjYXBwZWRBY3R1YWxEYXlzLFxuICAgICAgICAgICAgYmFsYW5jZV9kYXlzOiBjYXBwZWRCYWxhbmNlRGF5c1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmVxKCdpZCcsIGV4aXN0aW5nUmVjb3JkLmlkKVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIHVwZGF0aW5nIHZhc3RlIGRpZW5zdCByZWNvcmQ6JywgZXJyb3IpXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZGV0YWlsczonLCBKU09OLnN0cmluZ2lmeShlcnJvciwgbnVsbCwgMikpXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgUmVjb3JkIGRhdGE6JywgeyBpZDogZXhpc3RpbmdSZWNvcmQuaWQsIGFjdHVhbF9kYXlzOiB0b3RhbFdvcmtEYXlzLCBiYWxhbmNlX2RheXM6IGJhbGFuY2VEYXlzIH0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgVXBkYXRlZCByZWNvcmQgZm9yICR7YWZsb3NzZXIuZmlyc3RfbmFtZX1gKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgdmFzdGUgZGllbnN0IHJlY29yZDonLCBlcnIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSB3b3JrIGRheXMgZnJvbSB0cmlwIGRhdGFcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVXb3JrRGF5cyhzdGFydERhdGU6IHN0cmluZywgc3RhcnRUaW1lOiBzdHJpbmcsIGVuZERhdGU6IHN0cmluZywgZW5kVGltZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgaWYgKCFzdGFydERhdGUgfHwgIWVuZERhdGUpIHJldHVybiAwXG5cbiAgLy8gUGFyc2UgYm90aCBERC1NTS1ZWVlZIGFuZCBJU08gZm9ybWF0IGRhdGVzXG4gIGNvbnN0IHBhcnNlRGF0ZSA9IChkYXRlU3RyOiBzdHJpbmcpOiBEYXRlID0+IHtcbiAgICBpZiAoIWRhdGVTdHIgfHwgdHlwZW9mIGRhdGVTdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGRhdGUgc3RyaW5nOicsIGRhdGVTdHIpXG4gICAgICByZXR1cm4gbmV3IERhdGUoKSAvLyBSZXR1cm4gY3VycmVudCBkYXRlIGFzIGZhbGxiYWNrXG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIGl0J3MgYWxyZWFkeSBhbiBJU08gZGF0ZSAoY29udGFpbnMgVCBvciBoYXMgNC1kaWdpdCB5ZWFyIGF0IHN0YXJ0KVxuICAgIGlmIChkYXRlU3RyLmluY2x1ZGVzKCdUJykgfHwgL15cXGR7NH0tXFxkezJ9LVxcZHsyfS8udGVzdChkYXRlU3RyKSkge1xuICAgICAgLy8gSXQncyBhbHJlYWR5IGFuIElTTyBkYXRlLCB1c2UgaXQgZGlyZWN0bHlcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShkYXRlU3RyKVxuICAgICAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIElTTyBkYXRlOicsIGRhdGVTdHIpXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpIC8vIFJldHVybiBjdXJyZW50IGRhdGUgYXMgZmFsbGJhY2tcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRlXG4gICAgfVxuICAgIFxuICAgIC8vIE90aGVyd2lzZSwgcGFyc2UgYXMgREQtTU0tWVlZWSBmb3JtYXRcbiAgICBjb25zdCBwYXJ0cyA9IGRhdGVTdHIuc3BsaXQoJy0nKVxuICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgZGF0ZSBmb3JtYXQ6JywgZGF0ZVN0cilcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpIC8vIFJldHVybiBjdXJyZW50IGRhdGUgYXMgZmFsbGJhY2tcbiAgICB9XG4gICAgXG4gICAgY29uc3QgW2RheSwgbW9udGgsIHllYXJdID0gcGFydHNcbiAgICBjb25zdCBpc29EYXRlID0gYCR7eWVhcn0tJHttb250aC5wYWRTdGFydCgyLCAnMCcpfS0ke2RheS5wYWRTdGFydCgyLCAnMCcpfWBcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoaXNvRGF0ZSlcbiAgICBcbiAgICBpZiAoaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGRhdGUgYWZ0ZXIgcGFyc2luZzonLCBpc29EYXRlLCAnZnJvbTonLCBkYXRlU3RyKVxuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkgLy8gUmV0dXJuIGN1cnJlbnQgZGF0ZSBhcyBmYWxsYmFja1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZGF0ZVxuICB9XG5cbiAgY29uc3Qgc3RhcnQgPSBwYXJzZURhdGUoc3RhcnREYXRlKVxuICBjb25zdCBlbmQgPSBwYXJzZURhdGUoZW5kRGF0ZSlcblxuICAvLyBWYWxpZGF0aWU6IGFmc3RhcGRhdHVtIG1hZyBuaWV0IHZvb3IgaW5zdGFwZGF0dW0gbGlnZ2VuXG4gIGlmIChlbmQgPCBzdGFydCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yOiBlbmQgZGF0ZSBpcyBiZWZvcmUgc3RhcnQgZGF0ZScpXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIC8vIFNpbXBlbGUgdGVsbGluZzogdGVsIGthbGVuZGVyZGFnZW4gdmFuIHN0YXJ0IHRvdCBlaW5kIChpbmNsdXNpZWYgYmVpZGUpXG4gIGNvbnN0IHRpbWVEaWZmID0gZW5kLmdldFRpbWUoKSAtIHN0YXJ0LmdldFRpbWUoKVxuICBjb25zdCBkYXlzRGlmZiA9IE1hdGguY2VpbCh0aW1lRGlmZiAvICgxMDAwICogNjAgKiA2MCAqIDI0KSkgKyAxIC8vICsxIG9tZGF0IHdlIGJlaWRlIGRhdHVtcyBpbmNsdXNpZWYgdGVsbGVuXG5cblxuICByZXR1cm4gZGF5c0RpZmZcbn1cblxuLy8gRnVuY3Rpb24gdG8gYXV0by11cGRhdGUgdmFzdGUgZGllbnN0IHJlY29yZHMgd2hlbiBhIHRyaXAgaXMgY29tcGxldGVkXG5hc3luYyBmdW5jdGlvbiBhdXRvVXBkYXRlVmFzdGVEaWVuc3RGcm9tVHJpcChjb21wbGV0ZWRUcmlwOiBhbnkpIHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhg8J+UhCBBdXRvLXVwZGF0aW5nIHZhc3RlIGRpZW5zdCBmb3IgY29tcGxldGVkIHRyaXA6ICR7Y29tcGxldGVkVHJpcC5pZH1gKVxuICAgIGNvbnNvbGUubG9nKGDwn5SEIFRyaXAgZGF0YTpgLCBjb21wbGV0ZWRUcmlwKVxuICAgIFxuICAgIC8vIEdldCB0aGUgYWZsb3NzZXJcbiAgICBjb25zdCB7IGRhdGE6IGFmbG9zc2VyLCBlcnJvcjogYWZsb3NzZXJFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjcmV3JylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdpZCcsIGNvbXBsZXRlZFRyaXAuYWZsb3NzZXJfaWQpXG4gICAgICAuc2luZ2xlKClcbiAgICBcbiAgICBpZiAoYWZsb3NzZXJFcnJvciB8fCAhYWZsb3NzZXIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGFmbG9zc2VyOicsIGFmbG9zc2VyRXJyb3IpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgYWZsb3NzZXIgaXMgaW4gdmFzdGUgZGllbnN0XG4gICAgaWYgKCFhZmxvc3Nlci52YXN0ZV9kaWVuc3QpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdBZmxvc3NlciBpcyBub3QgaW4gdmFzdGUgZGllbnN0LCBza2lwcGluZyBhdXRvLXVwZGF0ZScpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgXG4gICAgLy8gR2V0IHRoZSBtb250aC95ZWFyIG9mIHRoZSB0cmlwIGNvbXBsZXRpb25cbiAgICAvLyBQYXJzZSB0aGUgZGF0ZSB1c2luZyBvdXIgc2FmZSBwYXJzZURhdGUgZnVuY3Rpb25cbiAgICBjb25zdCBwYXJzZURhdGUgPSAoZGF0ZVN0cjogc3RyaW5nKTogRGF0ZSA9PiB7XG4gICAgICBpZiAoIWRhdGVTdHIgfHwgdHlwZW9mIGRhdGVTdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgZGF0ZSBzdHJpbmc6JywgZGF0ZVN0cilcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKClcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhbHJlYWR5IGFuIElTTyBkYXRlIChjb250YWlucyBUIG9yIGhhcyA0LWRpZ2l0IHllYXIgYXQgc3RhcnQpXG4gICAgICBpZiAoZGF0ZVN0ci5pbmNsdWRlcygnVCcpIHx8IC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0vLnRlc3QoZGF0ZVN0cikpIHtcbiAgICAgICAgLy8gSXQncyBhbHJlYWR5IGFuIElTTyBkYXRlLCB1c2UgaXQgZGlyZWN0bHlcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGRhdGVTdHIpXG4gICAgICAgIGlmIChpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIElTTyBkYXRlOicsIGRhdGVTdHIpXG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBPdGhlcndpc2UsIHBhcnNlIGFzIERELU1NLVlZWVkgZm9ybWF0XG4gICAgICBjb25zdCBwYXJ0cyA9IGRhdGVTdHIuc3BsaXQoJy0nKVxuICAgICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGRhdGUgZm9ybWF0OicsIGRhdGVTdHIpXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IFtkYXksIG1vbnRoLCB5ZWFyXSA9IHBhcnRzXG4gICAgICBjb25zdCBpc29EYXRlID0gYCR7eWVhcn0tJHttb250aC5wYWRTdGFydCgyLCAnMCcpfS0ke2RheS5wYWRTdGFydCgyLCAnMCcpfWBcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShpc29EYXRlKVxuICAgICAgXG4gICAgICBpZiAoaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgZGF0ZSBhZnRlciBwYXJzaW5nOicsIGlzb0RhdGUsICdmcm9tOicsIGRhdGVTdHIpXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpXG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBkYXRlXG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGVuZERhdGUgPSBwYXJzZURhdGUoY29tcGxldGVkVHJpcC5laW5kX2RhdHVtKVxuICAgIGNvbnN0IHllYXIgPSBlbmREYXRlLmdldEZ1bGxZZWFyKClcbiAgICBjb25zdCBtb250aCA9IGVuZERhdGUuZ2V0TW9udGgoKSArIDFcbiAgICBcbiAgICAvLyBDaGVjayBpZiBtb250aGx5IHJlY29yZCBleGlzdHNcbiAgICBjb25zdCB7IGRhdGE6IGV4aXN0aW5nUmVjb3JkLCBlcnJvcjogcmVjb3JkRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndmFzdGVfZGllbnN0X3JlY29yZHMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ2FmbG9zc2VyX2lkJywgY29tcGxldGVkVHJpcC5hZmxvc3Nlcl9pZClcbiAgICAgIC5lcSgneWVhcicsIHllYXIpXG4gICAgICAuZXEoJ21vbnRoJywgbW9udGgpXG4gICAgICAuc2luZ2xlKClcbiAgICBcbiAgICBpZiAocmVjb3JkRXJyb3IgJiYgcmVjb3JkRXJyb3IuY29kZSAhPT0gJ1BHUlNUMTE2JykgeyAvLyBQR1JTVDExNiA9IG5vIHJvd3MgZm91bmRcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHZhc3RlIGRpZW5zdCByZWNvcmQ6JywgcmVjb3JkRXJyb3IpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgXG4gICAgbGV0IHJlY29yZElkID0gZXhpc3RpbmdSZWNvcmQ/LmlkXG4gICAgXG4gICAgLy8gQ3JlYXRlIHJlY29yZCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgaWYgKCFleGlzdGluZ1JlY29yZCkge1xuICAgICAgY29uc29sZS5sb2coYPCfk4UgQ3JlYXRpbmcgbmV3IG1vbnRobHkgcmVjb3JkIGZvciAke2FmbG9zc2VyLmZpcnN0X25hbWV9ICR7YWZsb3NzZXIubGFzdF9uYW1lfWApXG4gICAgICBcbiAgICAgIGNvbnN0IG5ld1JlY29yZCA9IHtcbiAgICAgICAgYWZsb3NzZXJfaWQ6IGNvbXBsZXRlZFRyaXAuYWZsb3NzZXJfaWQsXG4gICAgICAgIHllYXI6IHllYXIsXG4gICAgICAgIG1vbnRoOiBtb250aCxcbiAgICAgICAgcmVxdWlyZWRfZGF5czogMTUsXG4gICAgICAgIGFjdHVhbF9kYXlzOiAwLFxuICAgICAgICBiYWxhbmNlX2RheXM6IDAsXG4gICAgICAgIG5vdGVzOiBgQXV0b21hdGlzY2ggYWFuZ2VtYWFrdCB2b29yICR7eWVhcn0tJHttb250aH1gXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YTogY3JlYXRlZFJlY29yZCwgZXJyb3I6IGNyZWF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndmFzdGVfZGllbnN0X3JlY29yZHMnKVxuICAgICAgICAuaW5zZXJ0KFtuZXdSZWNvcmRdKVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpXG4gICAgICBcbiAgICAgIGlmIChjcmVhdGVFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyB2YXN0ZSBkaWVuc3QgcmVjb3JkOicsIGNyZWF0ZUVycm9yKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmVjb3JkSWQgPSBjcmVhdGVkUmVjb3JkLmlkXG4gICAgfVxuICAgIFxuICAgIC8vIENhbGN1bGF0ZSB3b3JrIGRheXMgZm9yIHRoaXMgdHJpcFxuICAgIGNvbnN0IHdvcmtEYXlzID0gY2FsY3VsYXRlV29ya0RheXMoXG4gICAgICBjb21wbGV0ZWRUcmlwLnN0YXJ0X2RhdHVtLCBcbiAgICAgIGNvbXBsZXRlZFRyaXAuc3RhcnRfdGlqZCwgXG4gICAgICBjb21wbGV0ZWRUcmlwLmVpbmRfZGF0dW0sIFxuICAgICAgY29tcGxldGVkVHJpcC5laW5kX3RpamRcbiAgICApXG4gICAgXG4gICAgLy8gR2V0IGFsbCBjb21wbGV0ZWQgdHJpcHMgZm9yIHRoaXMgbW9udGggdG8gY2FsY3VsYXRlIHRvdGFsXG4gICAgY29uc3QgeyBkYXRhOiBhbGxUcmlwcywgZXJyb3I6IHRyaXBzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndHJpcHMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ2FmbG9zc2VyX2lkJywgY29tcGxldGVkVHJpcC5hZmxvc3Nlcl9pZClcbiAgICAgIC5lcSgnc3RhdHVzJywgJ3ZvbHRvb2lkJylcbiAgICAgIC5ub3QoJ2VpbmRfZGF0dW0nLCAnaXMnLCBudWxsKVxuICAgIFxuICAgIGlmICh0cmlwc0Vycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB0cmlwczonLCB0cmlwc0Vycm9yKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIFxuICAgIC8vIENhbGN1bGF0ZSB0b3RhbCB3b3JrIGRheXMgZm9yIHRoZSBtb250aFxuICAgIGxldCB0b3RhbFdvcmtEYXlzID0gMFxuICAgIGZvciAoY29uc3QgdHJpcCBvZiBhbGxUcmlwcyB8fCBbXSkge1xuICAgICAgY29uc3QgdHJpcEVuZERhdGUgPSBwYXJzZURhdGUodHJpcC5laW5kX2RhdHVtKVxuICAgICAgaWYgKHRyaXBFbmREYXRlLmdldEZ1bGxZZWFyKCkgPT09IHllYXIgJiYgdHJpcEVuZERhdGUuZ2V0TW9udGgoKSArIDEgPT09IG1vbnRoKSB7XG4gICAgICAgIGNvbnN0IHRyaXBXb3JrRGF5cyA9IGNhbGN1bGF0ZVdvcmtEYXlzKHRyaXAuc3RhcnRfZGF0dW0sIHRyaXAuc3RhcnRfdGlqZCwgdHJpcC5laW5kX2RhdHVtLCB0cmlwLmVpbmRfdGlqZClcbiAgICAgICAgdG90YWxXb3JrRGF5cyArPSB0cmlwV29ya0RheXNcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIHRoZSByZWNvcmRcbiAgICBjb25zdCByZXF1aXJlZERheXMgPSAxNVxuICAgIFxuICAgIC8vIENPUlJFQ1RFIEJFUkVLRU5JTkc6IEVpbmRzYWxkbyA9IEJlZ2luc2FsZG8gKyAoR2V3ZXJrdCAtIDE1KVxuICAgIC8vIFZvb3IgZWVyc3RlIG1hYW5kOiBCZWdpbnNhbGRvID0gLTE1ICsgc3RhcnRzYWxkb1xuICAgIGxldCBiZWdpbnNhbGRvID0gMFxuICAgIFxuICAgIC8vIFByb2JlZXIgc3RhcnRzYWxkbyB1aXQgbm90ZXMgdGUgaGFsZW4gdm9vciBuaWV1d2UgYWZsb3NzZXJzXG4gICAgY29uc3Qgc3RhcnRzYWxkb05vdGUgPSBhZmxvc3Nlci5ub3Rlcz8uZmluZCgobm90ZTogYW55KSA9PiBcbiAgICAgIG5vdGUudGV4dCAmJiAobm90ZS50ZXh0LmluY2x1ZGVzKCdzdGFydHNhbGRvJykgfHwgbm90ZS50ZXh0LmluY2x1ZGVzKCdTdGFydHNhbGRvJykpXG4gICAgKVxuICAgIGlmIChzdGFydHNhbGRvTm90ZSkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBzdGFydHNhbGRvTm90ZS50ZXh0Lm1hdGNoKC8oLT9cXGQrKD86XFwuXFxkKyk/KS8pXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRzYWxkbyA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pXG4gICAgICAgIGJlZ2luc2FsZG8gPSAtMTUgKyBzdGFydHNhbGRvXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5OKIE5pZXV3ZSBhZmxvc3Nlcjogc3RhcnRzYWxkbyAke3N0YXJ0c2FsZG99LCBiZWdpbnNhbGRvICR7YmVnaW5zYWxkb31gKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmVnaW5zYWxkbyA9PT0gMCkgYmVnaW5zYWxkbyA9IC0xNSAvLyBGYWxsYmFja1xuICAgIFxuICAgIC8vIFZvb3IgZGUgZWVyc3RlIG1hYW5kOiB0b29uIGhldCBiZWdpbnNhbGRvIGFscyBodWlkaWcgc2FsZG9cbiAgICAvLyBWb29yIHZvbGdlbmRlIG1hYW5kZW46IGJlcmVrZW4gaGV0IGVpbmRzYWxkb1xuICAgIGxldCBiYWxhbmNlRGF5c1xuICAgIGlmIChtb250aCA9PT0gMSAmJiBiZWdpbnNhbGRvICE9PSAtMTUpIHtcbiAgICAgIC8vIEVlcnN0ZSBtYWFuZCBtZXQgc3RhcnRzYWxkbzogdG9vbiBiZWdpbnNhbGRvXG4gICAgICBiYWxhbmNlRGF5cyA9IGJlZ2luc2FsZG9cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm9ybWFsZSBiZXJla2VuaW5nOiBiZWdpbnNhbGRvICsgKGdld2Vya3QgLSAxNSlcbiAgICAgIGJhbGFuY2VEYXlzID0gYmVnaW5zYWxkbyArICh0b3RhbFdvcmtEYXlzIC0gcmVxdWlyZWREYXlzKVxuICAgIH1cbiAgICBcbiAgICAvLyBDYXAgdmFsdWVzIHRvIGZpdCBpbiBERUNJTUFMKDQsMSkgLSBtYXggOTk5LjlcbiAgICBjb25zdCBjYXBwZWRBY3R1YWxEYXlzID0gTWF0aC5taW4odG90YWxXb3JrRGF5cywgOTk5LjkpXG4gICAgY29uc3QgY2FwcGVkQmFsYW5jZURheXMgPSBNYXRoLm1pbihNYXRoLm1heChiYWxhbmNlRGF5cywgLTk5OS45KSwgOTk5LjkpXG4gICAgXG4gICAgY29uc3QgeyBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndmFzdGVfZGllbnN0X3JlY29yZHMnKVxuICAgICAgLnVwZGF0ZSh7XG4gICAgICAgIGFjdHVhbF9kYXlzOiBjYXBwZWRBY3R1YWxEYXlzLFxuICAgICAgICBiYWxhbmNlX2RheXM6IGNhcHBlZEJhbGFuY2VEYXlzXG4gICAgICB9KVxuICAgICAgLmVxKCdpZCcsIHJlY29yZElkKVxuICAgIFxuICAgIGlmICh1cGRhdGVFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIHVwZGF0aW5nIHZhc3RlIGRpZW5zdCByZWNvcmQ6JywgdXBkYXRlRXJyb3IpXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZGV0YWlsczonLCBKU09OLnN0cmluZ2lmeSh1cGRhdGVFcnJvciwgbnVsbCwgMikpXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgUmVjb3JkIGRhdGE6JywgeyBpZDogcmVjb3JkSWQsIGFjdHVhbF9kYXlzOiB0b3RhbFdvcmtEYXlzLCBiYWxhbmNlX2RheXM6IGJhbGFuY2VEYXlzIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgVXBkYXRlZCB2YXN0ZSBkaWVuc3QgcmVjb3JkIGZvciAke2FmbG9zc2VyLmZpcnN0X25hbWV9OiAke3RvdGFsV29ya0RheXN9IGRheXMgKGJhbGFuY2U6ICR7YmFsYW5jZURheXN9KWApXG4gICAgfVxuICAgIFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBhdXRvLXVwZGF0ZSB2YXN0ZSBkaWVuc3Q6JywgZXJyKVxuICB9XG59XG5cbi8vIEZ1bmN0aW9uIHRvIGZvcmNlIHJlY2FsY3VsYXRlIGFsbCB2YXN0ZSBkaWVuc3QgcmVjb3JkcyB3aXRoIG5ldyBsb2dpY1xuYXN5bmMgZnVuY3Rpb24gZm9yY2VSZWNhbGN1bGF0ZUFsbFZhc3RlRGllbnN0UmVjb3JkcyhjcmV3RGF0YTogYW55W10sIHRyaXBzRGF0YTogYW55W10pIHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygn8J+UhCBGb3JjZSByZWNhbGN1bGF0aW5nIGFsbCB2YXN0ZSBkaWVuc3QgcmVjb3Jkcy4uLicpXG4gICAgY29uc29sZS5sb2coYPCfk4ogQ3JldyBkYXRhOiAke2NyZXdEYXRhLmxlbmd0aH0gbWVtYmVyc2ApXG4gICAgY29uc29sZS5sb2coYPCfk4ogVHJpcHMgZGF0YTogJHt0cmlwc0RhdGEubGVuZ3RofSB0cmlwc2ApXG4gICAgXG4gICAgLy8gR2V0IGFsbCB2YXN0ZSBkaWVuc3QgcmVjb3Jkc1xuICAgIGNvbnN0IHsgZGF0YTogYWxsUmVjb3JkcywgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndmFzdGVfZGllbnN0X3JlY29yZHMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgXG4gICAgaWYgKGZldGNoRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBmZXRjaGluZyB2YXN0ZSBkaWVuc3QgcmVjb3JkczonLCBmZXRjaEVycm9yKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIFxuICAgIGlmICghYWxsUmVjb3JkcyB8fCBhbGxSZWNvcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS5sb2coJ+KaoO+4jyBObyB2YXN0ZSBkaWVuc3QgcmVjb3JkcyBmb3VuZCB0byByZWNhbGN1bGF0ZScpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYPCfk4sgRm91bmQgJHthbGxSZWNvcmRzLmxlbmd0aH0gcmVjb3JkcyB0byByZWNhbGN1bGF0ZWApXG4gICAgXG4gICAgLy8gUHJvY2VzcyBlYWNoIHJlY29yZFxuICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIGFsbFJlY29yZHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBcXG7wn5SNIFByb2Nlc3NpbmcgcmVjb3JkICR7cmVjb3JkLmlkfSBmb3IgYWZsb3NzZXIgJHtyZWNvcmQuYWZsb3NzZXJfaWR9YClcbiAgICAgICAgXG4gICAgICAgIC8vIEZpbmQgdGhlIGFmbG9zc2VyXG4gICAgICAgIGNvbnN0IGFmbG9zc2VyID0gY3Jld0RhdGEuZmluZChjcmV3ID0+IGNyZXcuaWQgPT09IHJlY29yZC5hZmxvc3Nlcl9pZClcbiAgICAgICAgaWYgKCFhZmxvc3Nlcikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDimqDvuI8gQWZsb3NzZXIgbm90IGZvdW5kIGZvciByZWNvcmQgJHtyZWNvcmQuaWR9YClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhg8J+RpCBGb3VuZCBhZmxvc3NlcjogJHthZmxvc3Nlci5maXJzdF9uYW1lfSAke2FmbG9zc2VyLmxhc3RfbmFtZX1gKVxuICAgICAgICBcbiAgICAgICAgLy8gR2V0IGFsbCBjb21wbGV0ZWQgdHJpcHMgZm9yIHRoaXMgYWZsb3NzZXJcbiAgICAgICAgY29uc3QgYWxsVHJpcHMgPSB0cmlwc0RhdGEuZmlsdGVyKCh0cmlwOiBhbnkpID0+IFxuICAgICAgICAgIHRyaXAuYWZsb3NzZXJfaWQgPT09IHJlY29yZC5hZmxvc3Nlcl9pZCAmJlxuICAgICAgICAgIHRyaXAuc3RhdHVzID09PSAndm9sdG9vaWQnICYmXG4gICAgICAgICAgdHJpcC5zdGFydF9kYXR1bSAmJiB0cmlwLmVpbmRfZGF0dW0gJiYgdHJpcC5zdGFydF90aWpkICYmIHRyaXAuZWluZF90aWpkXG4gICAgICAgIClcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5qiIEZvdW5kICR7YWxsVHJpcHMubGVuZ3RofSBjb21wbGV0ZWQgdHJpcHMgZm9yIHRoaXMgYWZsb3NzZXJgKVxuICAgICAgICBcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRvdGFsIHdvcmsgZGF5cyB3aXRoIG5ldyBsb2dpY1xuICAgICAgICBsZXQgdG90YWxXb3JrRGF5cyA9IDBcbiAgICAgICAgZm9yIChjb25zdCB0cmlwIG9mIGFsbFRyaXBzKSB7XG4gICAgICAgICAgY29uc3Qgd29ya0RheXMgPSBjYWxjdWxhdGVXb3JrRGF5cyh0cmlwLnN0YXJ0X2RhdHVtLCB0cmlwLnN0YXJ0X3RpamQsIHRyaXAuZWluZF9kYXR1bSwgdHJpcC5laW5kX3RpamQpXG4gICAgICAgICAgY29uc29sZS5sb2coYCAg8J+ThSBUcmlwICR7dHJpcC5pZH06ICR7dHJpcC5zdGFydF9kYXR1bX0gdG8gJHt0cmlwLmVpbmRfZGF0dW19ID0gJHt3b3JrRGF5c30gZGF5c2ApXG4gICAgICAgICAgdG90YWxXb3JrRGF5cyArPSB3b3JrRGF5c1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiBUb3RhbCB3b3JrIGRheXMgY2FsY3VsYXRlZDogJHt0b3RhbFdvcmtEYXlzfWApXG4gICAgICAgIFxuICAgICAgICAvLyBDYXAgdmFsdWVzIHRvIGZpdCBpbiBERUNJTUFMKDQsMSlcbiAgICAgICAgY29uc3QgcmVxdWlyZWREYXlzID0gMTVcbiAgICAgICAgXG4gICAgICAgIC8vIENPUlJFQ1RFIEJFUkVLRU5JTkc6IEVpbmRzYWxkbyA9IEJlZ2luc2FsZG8gKyAoR2V3ZXJrdCAtIDE1KVxuICAgICAgICAvLyBWb29yIGVlcnN0ZSBtYWFuZDogQmVnaW5zYWxkbyA9IC0xNSArIHN0YXJ0c2FsZG9cbiAgICAgICAgbGV0IGJlZ2luc2FsZG8gPSByZWNvcmQuYmFsYW5jZV9kYXlzIHx8IDBcbiAgICAgICAgXG4gICAgICAgIC8vIEFscyBkaXQgZGUgZWVyc3RlIG1hYW5kIGlzIGVuIGVyIGlzIGdlZW4gYmVnaW5zYWxkbywgZ2VicnVpayAtMTUgKyBzdGFydHNhbGRvXG4gICAgICAgIGlmIChiZWdpbnNhbGRvID09PSAwICYmIHJlY29yZC5tb250aCA9PT0gMSkge1xuICAgICAgICAgIC8vIFByb2JlZXIgc3RhcnRzYWxkbyB1aXQgbm90ZXMgdGUgaGFsZW5cbiAgICAgICAgICBjb25zdCBzdGFydHNhbGRvTm90ZSA9IGFmbG9zc2VyLm5vdGVzPy5maW5kKChub3RlOiBhbnkpID0+IFxuICAgICAgICAgICAgbm90ZS50ZXh0ICYmIChub3RlLnRleHQuaW5jbHVkZXMoJ3N0YXJ0c2FsZG8nKSB8fCBub3RlLnRleHQuaW5jbHVkZXMoJ1N0YXJ0c2FsZG8nKSlcbiAgICAgICAgICApXG4gICAgICAgICAgaWYgKHN0YXJ0c2FsZG9Ob3RlKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHN0YXJ0c2FsZG9Ob3RlLnRleHQubWF0Y2goLygtP1xcZCsoPzpcXC5cXGQrKT8pLylcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICBjb25zdCBzdGFydHNhbGRvID0gcGFyc2VGbG9hdChtYXRjaFsxXSlcbiAgICAgICAgICAgICAgYmVnaW5zYWxkbyA9IC0xNSArIHN0YXJ0c2FsZG9cbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk4ogRWVyc3RlIG1hYW5kIGhlcmJlcmVrZW5pbmc6IHN0YXJ0c2FsZG8gJHtzdGFydHNhbGRvfSwgYmVnaW5zYWxkbyAke2JlZ2luc2FsZG99YClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJlZ2luc2FsZG8gPT09IDApIGJlZ2luc2FsZG8gPSAtMTUgLy8gRmFsbGJhY2tcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVm9vciBkZSBlZXJzdGUgbWFhbmQ6IHRvb24gaGV0IGJlZ2luc2FsZG8gYWxzIGh1aWRpZyBzYWxkb1xuICAgICAgICAvLyBWb29yIHZvbGdlbmRlIG1hYW5kZW46IGJlcmVrZW4gaGV0IGVpbmRzYWxkb1xuICAgICAgICBsZXQgYmFsYW5jZURheXNcbiAgICAgICAgaWYgKHJlY29yZC5tb250aCA9PT0gMSAmJiBiZWdpbnNhbGRvICE9PSAtMTUpIHtcbiAgICAgICAgICAvLyBFZXJzdGUgbWFhbmQgbWV0IHN0YXJ0c2FsZG86IHRvb24gYmVnaW5zYWxkb1xuICAgICAgICAgIGJhbGFuY2VEYXlzID0gYmVnaW5zYWxkb1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vcm1hbGUgYmVyZWtlbmluZzogYmVnaW5zYWxkbyArIChnZXdlcmt0IC0gMTUpXG4gICAgICAgICAgYmFsYW5jZURheXMgPSBiZWdpbnNhbGRvICsgKHRvdGFsV29ya0RheXMgLSByZXF1aXJlZERheXMpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FwcGVkQWN0dWFsRGF5cyA9IE1hdGgubWluKHRvdGFsV29ya0RheXMsIDk5OS45KVxuICAgICAgICBjb25zdCBjYXBwZWRCYWxhbmNlRGF5cyA9IE1hdGgubWluKE1hdGgubWF4KGJhbGFuY2VEYXlzLCAtOTk5LjkpLCA5OTkuOSlcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5K+IFVwZGF0aW5nIHJlY29yZDogYWN0dWFsPSR7Y2FwcGVkQWN0dWFsRGF5c30sIGJhbGFuY2U9JHtjYXBwZWRCYWxhbmNlRGF5c31gKVxuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHRoZSByZWNvcmRcbiAgICAgICAgY29uc3QgeyBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ3Zhc3RlX2RpZW5zdF9yZWNvcmRzJylcbiAgICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICAgIGFjdHVhbF9kYXlzOiBjYXBwZWRBY3R1YWxEYXlzLFxuICAgICAgICAgICAgYmFsYW5jZV9kYXlzOiBjYXBwZWRCYWxhbmNlRGF5c1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmVxKCdpZCcsIHJlY29yZC5pZClcbiAgICAgICAgXG4gICAgICAgIGlmICh1cGRhdGVFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBFcnJvciB1cGRhdGluZyByZWNvcmQgJHtyZWNvcmQuaWR9OmAsIHVwZGF0ZUVycm9yKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgU3VjY2Vzc2Z1bGx5IHVwZGF0ZWQgcmVjb3JkIGZvciAke2FmbG9zc2VyLmZpcnN0X25hbWV9OiAke2NhcHBlZEFjdHVhbERheXN9IGRheXMgKGJhbGFuY2U6ICR7Y2FwcGVkQmFsYW5jZURheXN9KWApXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihg4p2MIEVycm9yIHByb2Nlc3NpbmcgcmVjb3JkICR7cmVjb3JkLmlkfTpgLCBlcnIpXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCfwn46JIEZvcmNlIHJlY2FsY3VsYXRpb24gY29tcGxldGVkIScpXG4gICAgXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBpbiBmb3JjZSByZWNhbGN1bGF0ZTonLCBlcnIpXG4gIH1cbn1cblxuLy8gRnVuY3Rpb24gdG8gcmVzZXQgYWxsIHZhc3RlIGRpZW5zdCByZWNvcmRzIHRvIDBcbmFzeW5jIGZ1bmN0aW9uIHJlc2V0QWxsVmFzdGVEaWVuc3RSZWNvcmRzKCkge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCfwn6e5IFJlc2V0dGluZyBhbGwgdmFzdGUgZGllbnN0IHJlY29yZHMgdG8gMC4uLicpXG4gICAgXG4gICAgLy8gR2V0IGFsbCB2YXN0ZSBkaWVuc3QgcmVjb3Jkc1xuICAgIGNvbnN0IHsgZGF0YTogYWxsUmVjb3JkcywgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndmFzdGVfZGllbnN0X3JlY29yZHMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgXG4gICAgaWYgKGZldGNoRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHZhc3RlIGRpZW5zdCByZWNvcmRzIGZvciByZXNldDonLCBmZXRjaEVycm9yKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIFxuICAgIGlmICghYWxsUmVjb3JkcyB8fCBhbGxSZWNvcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS5sb2coJ05vIHZhc3RlIGRpZW5zdCByZWNvcmRzIGZvdW5kIHRvIHJlc2V0JylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhgRm91bmQgJHthbGxSZWNvcmRzLmxlbmd0aH0gcmVjb3JkcyB0byByZXNldGApXG4gICAgXG4gICAgLy8gUmVzZXQgZWFjaCByZWNvcmQgdG8gMFxuICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIGFsbFJlY29yZHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCd2YXN0ZV9kaWVuc3RfcmVjb3JkcycpXG4gICAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgICBhY3R1YWxfZGF5czogMCxcbiAgICAgICAgICAgIGJhbGFuY2VfZGF5czogLTE1IC8vIC0xNSBiZWNhdXNlIHJlcXVpcmVkX2RheXMgaXMgMTVcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5lcSgnaWQnLCByZWNvcmQuaWQpXG4gICAgICAgIFxuICAgICAgICBpZiAodXBkYXRlRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGDinYwgRXJyb3IgcmVzZXR0aW5nIHJlY29yZCAke3JlY29yZC5pZH06YCwgdXBkYXRlRXJyb3IpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKchSBSZXNldCByZWNvcmQgJHtyZWNvcmQuaWR9IHRvIDBgKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHJlc2V0dGluZyByZWNvcmQgJHtyZWNvcmQuaWR9OmAsIGVycilcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ/CfjokgUmVzZXQgY29tcGxldGVkIScpXG4gICAgXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHJlc2V0IGFsbCByZWNvcmRzOicsIGVycilcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlU3VwYWJhc2VEYXRhKCkge1xuICBjb25zdCBbc2hpcHMsIHNldFNoaXBzXSA9IHVzZVN0YXRlPGFueVtdPihbXSlcbiAgY29uc3QgW2NyZXcsIHNldENyZXddID0gdXNlU3RhdGU8YW55W10+KFtdKVxuICBjb25zdCBbc2lja0xlYXZlLCBzZXRTaWNrTGVhdmVdID0gdXNlU3RhdGU8YW55W10+KFtdKVxuICBjb25zdCBbc3RhbmRCYWNrUmVjb3Jkcywgc2V0U3RhbmRCYWNrUmVjb3Jkc10gPSB1c2VTdGF0ZTxhbnlbXT4oW10pXG4gIGNvbnN0IFtsb2Fucywgc2V0TG9hbnNdID0gdXNlU3RhdGU8YW55W10+KFtdKVxuICBjb25zdCBbdHJpcHMsIHNldFRyaXBzXSA9IHVzZVN0YXRlPGFueVtdPihbXSlcbiAgY29uc3QgW3Zhc3RlRGllbnN0UmVjb3Jkcywgc2V0VmFzdGVEaWVuc3RSZWNvcmRzXSA9IHVzZVN0YXRlPGFueVtdPihbXSlcbiAgY29uc3QgW3Rhc2tzLCBzZXRUYXNrc10gPSB1c2VTdGF0ZTxhbnlbXT4oW10pXG4gIGNvbnN0IFtpbmNpZGVudHMsIHNldEluY2lkZW50c10gPSB1c2VTdGF0ZTxhbnlbXT4oW10pXG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpXG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbClcbiAgY29uc3QgW2NyZXdDb2xvclRhZ3MsIHNldENyZXdDb2xvclRhZ3NdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgc3RyaW5nPj4oe30pXG5cbiAgLy8gTG9hZCBhbGwgZGF0YSBmcm9tIFN1cGFiYXNlXG4gIGNvbnN0IGxvYWREYXRhID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBzZXRMb2FkaW5nKHRydWUpXG4gICAgICBzZXRFcnJvcihudWxsKVxuICAgICAgY29uc29sZS5sb2coJ0xvYWRpbmcgZGF0YSBmcm9tIFN1cGFiYXNlLi4uJylcblxuICAgICAgLy8gQ2hlY2sgaWYgdXNlciBpcyBhdXRoZW50aWNhdGVkXG4gICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFNlc3Npb24oKVxuICAgICAgY29uc29sZS5sb2coJ0N1cnJlbnQgc2Vzc2lvbjonLCBzZXNzaW9uID8gJ1VzZXIgbG9nZ2VkIGluJyA6ICdObyB1c2VyIHNlc3Npb24nKVxuICAgICAgXG4gICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdObyBhY3RpdmUgc2Vzc2lvbiAtIHVzZXIgbmVlZHMgdG8gbG9naW4nKVxuICAgICAgICBzZXRTaGlwcyhbXSlcbiAgICAgICAgc2V0Q3JldyhbXSlcbiAgICAgICAgc2V0U2lja0xlYXZlKFtdKVxuICAgICAgICBzZXRTdGFuZEJhY2tSZWNvcmRzKFtdKVxuICAgICAgICBzZXRMb2FucyhbXSlcbiAgICAgICAgc2V0VHJpcHMoW10pXG4gICAgICAgIHNldFZhc3RlRGllbnN0UmVjb3JkcyhbXSlcbiAgICAgICAgc2V0VGFza3MoW10pXG4gICAgICAgIHNldEluY2lkZW50cyhbXSlcbiAgICAgICAgc2V0TG9hZGluZyhmYWxzZSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIFRlc3QgU3VwYWJhc2UgY29ubmVjdGlvblxuICAgICAgY29uc29sZS5sb2coJ1Rlc3RpbmcgU3VwYWJhc2UgY29ubmVjdGlvbi4uLicpXG4gICAgICBjb25zdCB7IGRhdGE6IHRlc3REYXRhLCBlcnJvcjogdGVzdEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnc2lja19sZWF2ZScpXG4gICAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgICAgLmxpbWl0KDEpXG4gICAgICBcbiAgICAgIGlmICh0ZXN0RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignU3VwYWJhc2UgY29ubmVjdGlvbiB0ZXN0IGZhaWxlZDonLCB0ZXN0RXJyb3IpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rlc3QgZXJyb3IgZGV0YWlsczonLCBKU09OLnN0cmluZ2lmeSh0ZXN0RXJyb3IsIG51bGwsIDIpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBTdXBhYmFzZSBjb25uZWN0aW9uIHRlc3Qgc3VjY2Vzc2Z1bCcpXG4gICAgICB9XG5cbiAgICAgIC8vIExvYWQgc2hpcHNcbiAgICAgIGNvbnNvbGUubG9nKCdMb2FkaW5nIHNoaXBzLi4uJylcbiAgICAgIGNvbnN0IHsgZGF0YTogc2hpcHNEYXRhLCBlcnJvcjogc2hpcHNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3NoaXBzJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5vcmRlcignbmFtZScpXG5cbiAgICAgIGlmIChzaGlwc0Vycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgc2hpcHM6Jywgc2hpcHNFcnJvcilcbiAgICAgICAgY29uc29sZS5lcnJvcignU2hpcHMgZXJyb3IgZGV0YWlsczonLCBKU09OLnN0cmluZ2lmeShzaGlwc0Vycm9yLCBudWxsLCAyKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdTaGlwcyBsb2FkZWQ6Jywgc2hpcHNEYXRhPy5sZW5ndGggfHwgMClcbiAgICAgICAgc2V0U2hpcHMoc2hpcHNEYXRhIHx8IFtdKVxuICAgICAgfVxuXG4gICAgICAvLyBMb2FkIGNyZXdcbiAgICAgIGNvbnNvbGUubG9nKCdMb2FkaW5nIGNyZXcuLi4nKVxuICAgICAgY29uc3QgeyBkYXRhOiBjcmV3RGF0YSwgZXJyb3I6IGNyZXdFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2NyZXcnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLm9yZGVyKCdmaXJzdF9uYW1lJylcblxuICAgICAgaWYgKGNyZXdFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGNyZXc6JywgY3Jld0Vycm9yKVxuICAgICAgICBjb25zb2xlLmVycm9yKCdDcmV3IGVycm9yIGRldGFpbHM6JywgSlNPTi5zdHJpbmdpZnkoY3Jld0Vycm9yLCBudWxsLCAyKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdDcmV3IGxvYWRlZDonLCBjcmV3RGF0YT8ubGVuZ3RoIHx8IDApXG4gICAgICAgIFxuICAgICAgICAvLyBUZW1wb3JhcmlseSBkaXNhYmxlIGF1dG8tYWN0aXZhdGlvbiBhbmQgcm90YXRpb24gdG8gcHJldmVudCBpbmZpbml0ZSBsb29wc1xuICAgICAgICAvLyBhd2FpdCBhdXRvQWN0aXZhdGVDcmV3TWVtYmVycyhjcmV3RGF0YSB8fCBbXSlcbiAgICAgICAgLy8gYXdhaXQgYXV0b1JvdGF0ZUNyZXdNZW1iZXJzKGNyZXdEYXRhIHx8IFtdKVxuICAgICAgICBcbiAgICAgICAgLy8gU2V0IGNyZXcgZGF0YSBkaXJlY3RseSB3aXRob3V0IHJlbG9hZGluZ1xuICAgICAgICBzZXRDcmV3KGNyZXdEYXRhIHx8IFtdKVxuICAgICAgfVxuXG4gICAgICAvLyBMb2FkIHNpY2sgbGVhdmVcbiAgICAgIGNvbnNvbGUubG9nKCdMb2FkaW5nIHNpY2sgbGVhdmUuLi4nKVxuICAgICAgY29uc3QgeyBkYXRhOiBzaWNrTGVhdmVEYXRhLCBlcnJvcjogc2lja0xlYXZlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdzaWNrX2xlYXZlJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5vcmRlcignc3RhcnRfZGF0ZScsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuXG4gICAgICBpZiAoc2lja0xlYXZlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBzaWNrIGxlYXZlOicsIHNpY2tMZWF2ZUVycm9yKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1NpY2sgbGVhdmUgbG9hZGVkOicsIHNpY2tMZWF2ZURhdGE/Lmxlbmd0aCB8fCAwKVxuICAgICAgICBzZXRTaWNrTGVhdmUoc2lja0xlYXZlRGF0YSB8fCBbXSlcbiAgICAgIH1cblxuICAgICAgLy8gTG9hZCBzdGFuZCBiYWNrIHJlY29yZHNcbiAgICAgIGNvbnNvbGUubG9nKCdMb2FkaW5nIHN0YW5kIGJhY2sgcmVjb3Jkcy4uLicpXG4gICAgICBjb25zdCB7IGRhdGE6IHN0YW5kQmFja0RhdGEsIGVycm9yOiBzdGFuZEJhY2tFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3N0YW5kX2JhY2tfcmVjb3JkcycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcblxuICAgICAgaWYgKHN0YW5kQmFja0Vycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgc3RhbmQgYmFjayByZWNvcmRzOicsIHN0YW5kQmFja0Vycm9yKVxuICAgICAgICBzZXRTdGFuZEJhY2tSZWNvcmRzKFtdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1N0YW5kIGJhY2sgcmVjb3JkcyBsb2FkZWQ6Jywgc3RhbmRCYWNrRGF0YT8ubGVuZ3RoIHx8IDApXG4gICAgICAgIHNldFN0YW5kQmFja1JlY29yZHMoc3RhbmRCYWNrRGF0YSB8fCBbXSlcbiAgICAgIH1cblxuICAgICAgLy8gTG9hZCBsb2Fuc1xuICAgICAgY29uc29sZS5sb2coJ0xvYWRpbmcgbG9hbnMuLi4nKVxuICAgICAgY29uc3QgeyBkYXRhOiBsb2Fuc0RhdGEsIGVycm9yOiBsb2Fuc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnbG9hbnMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgICAgIGlmIChsb2Fuc0Vycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgbG9hbnM6JywgbG9hbnNFcnJvcilcbiAgICAgICAgc2V0TG9hbnMoW10pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnTG9hbnMgbG9hZGVkOicsIGxvYW5zRGF0YT8ubGVuZ3RoIHx8IDApXG4gICAgICAgIHNldExvYW5zKGxvYW5zRGF0YSB8fCBbXSlcbiAgICAgIH1cblxuICAgICAgICAgICAgLy8gTG9hZCB0cmlwc1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0xvYWRpbmcgdHJpcHMuLi4nKVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiB0cmlwc0RhdGEsIGVycm9yOiB0cmlwc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAuZnJvbSgndHJpcHMnKVxuICAgICAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgICAgICAgICAgIGlmICh0cmlwc0Vycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgdHJpcHM6JywgdHJpcHNFcnJvcilcbiAgICAgICAgICAgICAgc2V0VHJpcHMoW10pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVHJpcHMgbG9hZGVkOicsIHRyaXBzRGF0YT8ubGVuZ3RoIHx8IDApXG4gICAgICAgICAgICAgIHNldFRyaXBzKHRyaXBzRGF0YSB8fCBbXSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTG9hZCB2YXN0ZSBkaWVuc3QgcmVjb3Jkc1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0xvYWRpbmcgdmFzdGUgZGllbnN0IHJlY29yZHMuLi4nKVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiB2YXN0ZURpZW5zdERhdGEsIGVycm9yOiB2YXN0ZURpZW5zdEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAuZnJvbSgndmFzdGVfZGllbnN0X3JlY29yZHMnKVxuICAgICAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAgICAgLm9yZGVyKCd5ZWFyJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG4gICAgICAgICAgICAgIC5vcmRlcignbW9udGgnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcblxuICAgICAgICAgICAgaWYgKHZhc3RlRGllbnN0RXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyB2YXN0ZSBkaWVuc3QgcmVjb3JkczonLCB2YXN0ZURpZW5zdEVycm9yKVxuICAgICAgICAgICAgICBzZXRWYXN0ZURpZW5zdFJlY29yZHMoW10pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVmFzdGUgZGllbnN0IHJlY29yZHMgbG9hZGVkOicsIHZhc3RlRGllbnN0RGF0YT8ubGVuZ3RoIHx8IDApXG4gICAgICAgICAgICAgIHNldFZhc3RlRGllbnN0UmVjb3Jkcyh2YXN0ZURpZW5zdERhdGEgfHwgW10pXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBBdXRvLW1hbmFnZSB2YXN0ZSBkaWVuc3QgcmVjb3JkcyBhZnRlciBsb2FkaW5nIGFsbCBkYXRhXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SnIEF1dG8tbWFuYWdpbmcgdmFzdGUgZGllbnN0IHJlY29yZHMuLi4nKVxuICAgICAgICAgICAgICBhd2FpdCBhdXRvTWFuYWdlVmFzdGVEaWVuc3RSZWNvcmRzKGNyZXdEYXRhIHx8IFtdLCB2YXN0ZURpZW5zdERhdGEgfHwgW10sIHRyaXBzRGF0YSB8fCBbXSlcbiAgICAgICAgICAgIH1cblxuICAgICAgLy8gTG9hZCB0YXNrc1xuICAgICAgY29uc29sZS5sb2coJ0xvYWRpbmcgdGFza3MuLi4nKVxuICAgICAgY29uc3QgeyBkYXRhOiB0YXNrc0RhdGEsIGVycm9yOiB0YXNrc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndGFza3MnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgICAgIGlmICh0YXNrc0Vycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgdGFza3M6JywgdGFza3NFcnJvcilcbiAgICAgICAgc2V0VGFza3MoW10pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnVGFza3MgbG9hZGVkOicsIHRhc2tzRGF0YT8ubGVuZ3RoIHx8IDApXG4gICAgICAgIHNldFRhc2tzKHRhc2tzRGF0YSB8fCBbXSlcbiAgICAgIH1cblxuICAgICAgLy8gTG9hZCBpbmNpZGVudHNcbiAgICAgIGNvbnNvbGUubG9nKCdMb2FkaW5nIGluY2lkZW50cy4uLicpXG4gICAgICBjb25zdCB7IGRhdGE6IGluY2lkZW50c0RhdGEsIGVycm9yOiBpbmNpZGVudHNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2luY2lkZW50cycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcblxuICAgICAgaWYgKGluY2lkZW50c0Vycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgaW5jaWRlbnRzOicsIGluY2lkZW50c0Vycm9yKVxuICAgICAgICBzZXRJbmNpZGVudHMoW10pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnSW5jaWRlbnRzIGxvYWRlZDonLCBpbmNpZGVudHNEYXRhPy5sZW5ndGggfHwgMClcbiAgICAgICAgc2V0SW5jaWRlbnRzKGluY2lkZW50c0RhdGEgfHwgW10pXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdEYXRhIGxvYWRpbmcgY29tcGxldGVkIScpXG5cbiAgICAgIC8vIExvYWQgY3JldyBjb2xvciB0YWdzIGxhc3QsIG5vbi1ibG9ja2luZyBmb3IgbWFpbiBkYXRhXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGRhdGE6IGNvbG9yUm93cywgZXJyb3I6IGNvbG9yRXJyIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdjcmV3X2NvbG9yX3RhZ3MnKVxuICAgICAgICAgIC5zZWxlY3QoJ2NyZXdfaWQsIGNvbG9yJylcbiAgICAgICAgaWYgKGNvbG9yRXJyKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0gKGNvbG9yRXJyIGFzIGFueSk/Lm1lc3NhZ2UgfHwgU3RyaW5nKGNvbG9yRXJyKVxuICAgICAgICAgIGNvbnNvbGUud2FybignU2tpcHBpbmcgY3Jld19jb2xvcl90YWdzICh0YWJsZSBtaXNzaW5nIG9yIG5vIGFjY2Vzcyk6JywgbXNnKVxuICAgICAgICAgIHNldENyZXdDb2xvclRhZ3Moe30pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgbWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge31cbiAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiBjb2xvclJvd3MgfHwgW10pIHtcbiAgICAgICAgICAgIGlmIChyb3cuY3Jld19pZCAmJiByb3cuY29sb3IpIG1hcFtyb3cuY3Jld19pZF0gPSByb3cuY29sb3JcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0Q3Jld0NvbG9yVGFncyhtYXApXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdFcnJvciBsb2FkaW5nIGNyZXdfY29sb3JfdGFnczonLCAoZSBhcyBhbnkpPy5tZXNzYWdlIHx8IGUpXG4gICAgICAgIHNldENyZXdDb2xvclRhZ3Moe30pXG4gICAgICB9XG5cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGxvYWREYXRhOicsIGVycilcbiAgICAgIHNldEVycm9yKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpXG4gICAgfVxuICB9XG5cbiAgLy8gTG9hZCBkYXRhIG9uIG1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbG9hZERhdGEoKVxuICAgIFxuICAgIC8vIFRlbXBvcmFyaWx5IGRpc2FibGUgZGFpbHkgY2hlY2sgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wc1xuICAgIC8vIGNvbnN0IGRhaWx5Q2hlY2sgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgLy8gICBjb25zb2xlLmxvZygnUnVubmluZyBkYWlseSBhdXRvLWFjdGl2YXRpb24gY2hlY2suLi4nKVxuICAgIC8vICAgbG9hZERhdGEoKSAvLyBEaXQgemFsIGF1dG9BY3RpdmF0ZUNyZXdNZW1iZXJzIGFhbnJvZXBlblxuICAgIC8vIH0sIDI0ICogNjAgKiA2MCAqIDEwMDApIC8vIDI0IHV1clxuICAgIFxuICAgIC8vIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGRhaWx5Q2hlY2spXG4gIH0sIFtdKVxuXG4gIC8vIFN1YnNjcmliZSB0byByZWFsLXRpbWUgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFN1YnNjcmliZSB0byBzaGlwcyBjaGFuZ2VzXG4gICAgY29uc3Qgc2hpcHNTdWJzY3JpcHRpb24gPSBzdXBhYmFzZVxuICAgICAgLmNoYW5uZWwoJ3NoaXBzLWNoYW5nZXMnKVxuICAgICAgLm9uKCdwb3N0Z3Jlc19jaGFuZ2VzJywgeyBldmVudDogJyonLCBzY2hlbWE6ICdwdWJsaWMnLCB0YWJsZTogJ3NoaXBzJyB9LCAoKSA9PiB7XG4gICAgICAgIGxvYWREYXRhKClcbiAgICAgIH0pXG4gICAgICAuc3Vic2NyaWJlKClcblxuICAgIC8vIFN1YnNjcmliZSB0byBjcmV3IGNoYW5nZXNcbiAgICBjb25zdCBjcmV3U3Vic2NyaXB0aW9uID0gc3VwYWJhc2VcbiAgICAgIC5jaGFubmVsKCdjcmV3LWNoYW5nZXMnKVxuICAgICAgLm9uKCdwb3N0Z3Jlc19jaGFuZ2VzJywgeyBldmVudDogJyonLCBzY2hlbWE6ICdwdWJsaWMnLCB0YWJsZTogJ2NyZXcnIH0sICgpID0+IHtcbiAgICAgICAgbG9hZERhdGEoKVxuICAgICAgfSlcbiAgICAgIC5zdWJzY3JpYmUoKVxuXG4gICAgLy8gU3Vic2NyaWJlIHRvIHNpY2sgbGVhdmUgY2hhbmdlc1xuICAgIGNvbnN0IHNpY2tMZWF2ZVN1YnNjcmlwdGlvbiA9IHN1cGFiYXNlXG4gICAgICAuY2hhbm5lbCgnc2ljay1sZWF2ZS1jaGFuZ2VzJylcbiAgICAgIC5vbigncG9zdGdyZXNfY2hhbmdlcycsIHsgZXZlbnQ6ICcqJywgc2NoZW1hOiAncHVibGljJywgdGFibGU6ICdzaWNrX2xlYXZlJyB9LCAoKSA9PiB7XG4gICAgICAgIGxvYWREYXRhKClcbiAgICAgIH0pXG4gICAgICAuc3Vic2NyaWJlKClcblxuICAgIC8vIFN1YnNjcmliZSB0byBzdGFuZCBiYWNrIHJlY29yZHMgY2hhbmdlc1xuICAgIGNvbnN0IHN0YW5kQmFja1N1YnNjcmlwdGlvbiA9IHN1cGFiYXNlXG4gICAgICAuY2hhbm5lbCgnc3RhbmQtYmFjay1jaGFuZ2VzJylcbiAgICAgIC5vbigncG9zdGdyZXNfY2hhbmdlcycsIHsgZXZlbnQ6ICcqJywgc2NoZW1hOiAncHVibGljJywgdGFibGU6ICdzdGFuZF9iYWNrX3JlY29yZHMnIH0sICgpID0+IHtcbiAgICAgICAgbG9hZERhdGEoKVxuICAgICAgfSlcbiAgICAgIC5zdWJzY3JpYmUoKVxuXG4gICAgLy8gU3Vic2NyaWJlIHRvIGxvYW5zIGNoYW5nZXNcbiAgICBjb25zdCBsb2Fuc1N1YnNjcmlwdGlvbiA9IHN1cGFiYXNlXG4gICAgICAuY2hhbm5lbCgnbG9hbnMtY2hhbmdlcycpXG4gICAgICAub24oJ3Bvc3RncmVzX2NoYW5nZXMnLCB7IGV2ZW50OiAnKicsIHNjaGVtYTogJ3B1YmxpYycsIHRhYmxlOiAnbG9hbnMnIH0sICgpID0+IHtcbiAgICAgICAgbG9hZERhdGEoKVxuICAgICAgfSlcbiAgICAgIC5zdWJzY3JpYmUoKVxuXG4gICAgLy8gU3Vic2NyaWJlIHRvIHRyaXBzIGNoYW5nZXNcbiAgICBjb25zdCB0cmlwc1N1YnNjcmlwdGlvbiA9IHN1cGFiYXNlXG4gICAgICAuY2hhbm5lbCgndHJpcHMtY2hhbmdlcycpXG4gICAgICAub24oJ3Bvc3RncmVzX2NoYW5nZXMnLCB7IGV2ZW50OiAnKicsIHNjaGVtYTogJ3B1YmxpYycsIHRhYmxlOiAndHJpcHMnIH0sICgpID0+IHtcbiAgICAgICAgbG9hZERhdGEoKVxuICAgICAgfSlcbiAgICAgIC5zdWJzY3JpYmUoKVxuXG4gICAgLy8gU3Vic2NyaWJlIHRvIHRhc2tzIGNoYW5nZXNcbiAgICBjb25zdCB0YXNrc1N1YnNjcmlwdGlvbiA9IHN1cGFiYXNlXG4gICAgICAuY2hhbm5lbCgndGFza3MtY2hhbmdlcycpXG4gICAgICAub24oJ3Bvc3RncmVzX2NoYW5nZXMnLCB7IGV2ZW50OiAnKicsIHNjaGVtYTogJ3B1YmxpYycsIHRhYmxlOiAndGFza3MnIH0sICgpID0+IHtcbiAgICAgICAgbG9hZERhdGEoKVxuICAgICAgfSlcbiAgICAgIC5zdWJzY3JpYmUoKVxuXG4gICAgLy8gU3Vic2NyaWJlIHRvIGluY2lkZW50cyBjaGFuZ2VzXG4gICAgY29uc3QgaW5jaWRlbnRzU3Vic2NyaXB0aW9uID0gc3VwYWJhc2VcbiAgICAgIC5jaGFubmVsKCdpbmNpZGVudHMtY2hhbmdlcycpXG4gICAgICAub24oJ3Bvc3RncmVzX2NoYW5nZXMnLCB7IGV2ZW50OiAnKicsIHNjaGVtYTogJ3B1YmxpYycsIHRhYmxlOiAnaW5jaWRlbnRzJyB9LCAoKSA9PiB7XG4gICAgICAgIGxvYWREYXRhKClcbiAgICAgIH0pXG4gICAgICAuc3Vic2NyaWJlKClcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzaGlwc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpXG4gICAgICBjcmV3U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKClcbiAgICAgIHNpY2tMZWF2ZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpXG4gICAgICBzdGFuZEJhY2tTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKVxuICAgICAgbG9hbnNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKVxuICAgICAgdHJpcHNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKVxuICAgICAgdGFza3NTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKVxuICAgICAgaW5jaWRlbnRzU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKClcbiAgICB9XG4gIH0sIFtdKVxuXG4gIC8vIEFkZCBjcmV3IG1lbWJlclxuICBjb25zdCBhZGRDcmV3ID0gYXN5bmMgKGNyZXdEYXRhOiBhbnkpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ0FkZGluZyBjcmV3IG1lbWJlciB0byBTdXBhYmFzZTonLCBjcmV3RGF0YSlcbiAgICAgIGNvbnNvbGUubG9nKCdDcmV3IGRhdGEgZGV0YWlsczonLCBKU09OLnN0cmluZ2lmeShjcmV3RGF0YSwgbnVsbCwgMikpXG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIHJlcXVpcmVkIGZpZWxkc1xuICAgICAgY29uc3QgcmVxdWlyZWRGaWVsZHMgPSBbJ2lkJywgJ2ZpcnN0X25hbWUnLCAnbGFzdF9uYW1lJywgJ25hdGlvbmFsaXR5JywgJ3Bvc2l0aW9uJ11cbiAgICAgIGNvbnN0IG1pc3NpbmdGaWVsZHMgPSByZXF1aXJlZEZpZWxkcy5maWx0ZXIoZmllbGQgPT4gIWNyZXdEYXRhW2ZpZWxkXSlcbiAgICAgIFxuICAgICAgaWYgKG1pc3NpbmdGaWVsZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgTWlzc2luZyByZXF1aXJlZCBmaWVsZHM6ICR7bWlzc2luZ0ZpZWxkcy5qb2luKCcsICcpfWApXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1ZhbGlkYXRpb24gZXJyb3I6JywgZXJyb3IpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBkdXBsaWNhdGUgY3JldyBtZW1iZXJcbiAgICAgIGNvbnN0IHsgZGF0YTogZXhpc3RpbmdDcmV3LCBlcnJvcjogY2hlY2tFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2NyZXcnKVxuICAgICAgICAuc2VsZWN0KCdpZCcpXG4gICAgICAgIC5lcSgnZmlyc3RfbmFtZScsIGNyZXdEYXRhLmZpcnN0X25hbWUpXG4gICAgICAgIC5lcSgnbGFzdF9uYW1lJywgY3Jld0RhdGEubGFzdF9uYW1lKVxuICAgICAgICAuZXEoJ25hdGlvbmFsaXR5JywgY3Jld0RhdGEubmF0aW9uYWxpdHkpXG4gICAgICAgIC5zaW5nbGUoKVxuICAgICAgXG4gICAgICBpZiAoZXhpc3RpbmdDcmV3ICYmICFjaGVja0Vycm9yKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBDcmV3IG1lbWJlciB3aXRoIG5hbWUgJHtjcmV3RGF0YS5maXJzdF9uYW1lfSAke2NyZXdEYXRhLmxhc3RfbmFtZX0gYWxyZWFkeSBleGlzdHNgKVxuICAgICAgICBjb25zb2xlLmVycm9yKCdEdXBsaWNhdGUgY3JldyBtZW1iZXI6JywgZXJyb3IpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdjcmV3JylcbiAgICAgICAgLmluc2VydChbY3Jld0RhdGFdKVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBlcnJvciBhZGRpbmcgY3JldzonLCBlcnJvcilcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGV0YWlsczonLCBKU09OLnN0cmluZ2lmeShlcnJvciwgbnVsbCwgMikpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNvZGU6JywgZXJyb3IuY29kZSlcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbWVzc2FnZTonLCBlcnJvci5tZXNzYWdlKVxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBoaW50OicsIGVycm9yLmhpbnQpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdDcmV3IG1lbWJlciBhZGRlZCBzdWNjZXNzZnVsbHk6JywgZGF0YSlcbiAgICAgIGF3YWl0IGxvYWREYXRhKClcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgY3JldzonLCBlcnIpXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZXRhaWxzOicsIEpTT04uc3RyaW5naWZ5KGVyciwgbnVsbCwgMikpXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICAvLyBVcGRhdGUgY3JldyBtZW1iZXJcbiAgY29uc3QgdXBkYXRlQ3JldyA9IGFzeW5jIChpZDogc3RyaW5nLCB1cGRhdGVzOiBhbnkpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ1VwZGF0aW5nIGNyZXcgbWVtYmVyIGluIFN1cGFiYXNlOicsIGlkLCB1cGRhdGVzKVxuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnY3JldycpXG4gICAgICAgIC51cGRhdGUodXBkYXRlcylcbiAgICAgICAgLmVxKCdpZCcsIGlkKVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBlcnJvciB1cGRhdGluZyBjcmV3OicsIGVycm9yKVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnQ3JldyBtZW1iZXIgdXBkYXRlZCBzdWNjZXNzZnVsbHknKVxuICAgICAgYXdhaXQgbG9hZERhdGEoKVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGNyZXc6JywgZXJyKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgLy8gRGVsZXRlIGNyZXcgbWVtYmVyXG4gIGNvbnN0IGRlbGV0ZUNyZXcgPSBhc3luYyAoaWQ6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnY3JldycpXG4gICAgICAgIC5kZWxldGUoKVxuICAgICAgICAuZXEoJ2lkJywgaWQpXG4gICAgICBcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICAgIFxuICAgICAgYXdhaXQgbG9hZERhdGEoKSAvLyBSZWxvYWQgYWxsIGRhdGFcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIGNyZXc6JywgZXJyKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHNoaXBcbiAgY29uc3QgYWRkU2hpcCA9IGFzeW5jIChzaGlwRGF0YTogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgc2hpcCB0byBTdXBhYmFzZTonLCBzaGlwRGF0YSlcbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3NoaXBzJylcbiAgICAgICAgLmluc2VydChbc2hpcERhdGFdKVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBlcnJvciBhZGRpbmcgc2hpcDonLCBlcnJvcilcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGV0YWlsczonLCBKU09OLnN0cmluZ2lmeShlcnJvciwgbnVsbCwgMikpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdTaGlwIGFkZGVkIHN1Y2Nlc3NmdWxseTonLCBkYXRhKVxuICAgICAgYXdhaXQgbG9hZERhdGEoKVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBzaGlwOicsIGVycilcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZSBzaGlwXG4gIGNvbnN0IHVwZGF0ZVNoaXAgPSBhc3luYyAoaWQ6IHN0cmluZywgdXBkYXRlczogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdzaGlwcycpXG4gICAgICAgIC51cGRhdGUodXBkYXRlcylcbiAgICAgICAgLmVxKCdpZCcsIGlkKVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpXG4gICAgICBcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICAgIFxuICAgICAgYXdhaXQgbG9hZERhdGEoKSAvLyBSZWxvYWQgYWxsIGRhdGFcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBzaGlwOicsIGVycilcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIC8vIERlbGV0ZSBzaGlwXG4gIGNvbnN0IGRlbGV0ZVNoaXAgPSBhc3luYyAoaWQ6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnc2hpcHMnKVxuICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgLmVxKCdpZCcsIGlkKVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIGF3YWl0IGxvYWREYXRhKCkgLy8gUmVsb2FkIGFsbCBkYXRhXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBzaGlwOicsIGVycilcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBzaWNrIGxlYXZlXG4gIGNvbnN0IGFkZFNpY2tMZWF2ZSA9IGFzeW5jIChzaWNrTGVhdmVEYXRhOiBhbnkpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ0FkZGluZyBzaWNrIGxlYXZlIHRvIFN1cGFiYXNlOicsIHNpY2tMZWF2ZURhdGEpXG4gICAgICBcbiAgICAgIC8vIEVuc3VyZSBub3RlcyBpcyBub3QgbnVsbFxuICAgICAgaWYgKHNpY2tMZWF2ZURhdGEubm90ZXMgPT09IG51bGwgfHwgc2lja0xlYXZlRGF0YS5ub3RlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNpY2tMZWF2ZURhdGEubm90ZXMgPSBcIlwiXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdzaWNrX2xlYXZlJylcbiAgICAgICAgLmluc2VydChbc2lja0xlYXZlRGF0YV0pXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N1cGFiYXNlIGVycm9yIGFkZGluZyBzaWNrIGxlYXZlOicsIGVycm9yKVxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZXRhaWxzOicsIEpTT04uc3RyaW5naWZ5KGVycm9yLCBudWxsLCAyKSlcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ1NpY2sgbGVhdmUgYWRkZWQgc3VjY2Vzc2Z1bGx5OicsIGRhdGEpXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpIC8vIFJlbG9hZCBhbGwgZGF0YVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBzaWNrIGxlYXZlOicsIGVycilcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZSBzaWNrIGxlYXZlXG4gIGNvbnN0IHVwZGF0ZVNpY2tMZWF2ZSA9IGFzeW5jIChpZDogc3RyaW5nLCB1cGRhdGVzOiBhbnkpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ1VwZGF0aW5nIHNpY2sgbGVhdmUgaW4gU3VwYWJhc2U6JywgaWQsIHVwZGF0ZXMpXG4gICAgICBcbiAgICAgIC8vIEVuc3VyZSBub3RlcyBpcyBub3QgbnVsbFxuICAgICAgaWYgKHVwZGF0ZXMubm90ZXMgPT09IG51bGwgfHwgdXBkYXRlcy5ub3RlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVwZGF0ZXMubm90ZXMgPSBcIlwiXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdzaWNrX2xlYXZlJylcbiAgICAgICAgLnVwZGF0ZSh1cGRhdGVzKVxuICAgICAgICAuZXEoJ2lkJywgaWQpXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N1cGFiYXNlIGVycm9yIHVwZGF0aW5nIHNpY2sgbGVhdmU6JywgZXJyb3IpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFpbHM6JywgSlNPTi5zdHJpbmdpZnkoZXJyb3IsIG51bGwsIDIpKVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnU2ljayBsZWF2ZSB1cGRhdGVkIHN1Y2Nlc3NmdWxseTonLCBkYXRhKVxuICAgICAgYXdhaXQgbG9hZERhdGEoKSAvLyBSZWxvYWQgYWxsIGRhdGFcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBzaWNrIGxlYXZlOicsIGVycilcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFpbHM6JywgSlNPTi5zdHJpbmdpZnkoZXJyLCBudWxsLCAyKSlcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGFkZFN0YW5kQmFja1JlY29yZCA9IGFzeW5jIChyZWNvcmREYXRhOiBhbnkpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJz09PSBBRERJTkcgU1RBTkQgQkFDSyBSRUNPUkQgPT09JylcbiAgICAgIGNvbnNvbGUubG9nKCdPcmlnaW5hbCByZWNvcmQgZGF0YTonLCByZWNvcmREYXRhKVxuICAgICAgXG4gICAgICAvLyBHZW5lcmF0ZSBhIFVVSUQgZm9yIHRoZSBpZCBmaWVsZFxuICAgICAgY29uc3QgdXVpZCA9IGNyeXB0by5yYW5kb21VVUlEKClcbiAgICAgIGNvbnNvbGUubG9nKCdHZW5lcmF0ZWQgVVVJRDonLCB1dWlkKVxuICAgICAgXG4gICAgICAvLyBSZW1vdmUgaWQgaWYgaXQgZXhpc3RzIGFuZCBhZGQgb3VyIGdlbmVyYXRlZCBVVUlEXG4gICAgICBjb25zdCB7IGlkLCAuLi5kYXRhV2l0aG91dElkIH0gPSByZWNvcmREYXRhXG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIHNhZmUgZGF0YSBvYmplY3Qgd2l0aCBvbmx5IGtub3duIGRhdGFiYXNlIGNvbHVtbnNcbiAgICAgIGNvbnN0IGRhdGFUb0luc2VydCA9IHtcbiAgICAgICAgaWQ6IHV1aWQsXG4gICAgICAgIGNyZXdfbWVtYmVyX2lkOiBkYXRhV2l0aG91dElkLmNyZXdfbWVtYmVyX2lkLFxuICAgICAgICBzdGFydF9kYXRlOiBkYXRhV2l0aG91dElkLnN0YXJ0X2RhdGUsXG4gICAgICAgIGVuZF9kYXRlOiBkYXRhV2l0aG91dElkLmVuZF9kYXRlLFxuICAgICAgICBkYXlzX2NvdW50OiBkYXRhV2l0aG91dElkLmRheXNfY291bnQsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkYXRhV2l0aG91dElkLmRlc2NyaXB0aW9uLFxuICAgICAgICBzdGFuZF9iYWNrX2RheXNfcmVxdWlyZWQ6IGRhdGFXaXRob3V0SWQuc3RhbmRfYmFja19kYXlzX3JlcXVpcmVkLFxuICAgICAgICBzdGFuZF9iYWNrX2RheXNfY29tcGxldGVkOiBkYXRhV2l0aG91dElkLnN0YW5kX2JhY2tfZGF5c19jb21wbGV0ZWQsXG4gICAgICAgIHN0YW5kX2JhY2tfZGF5c19yZW1haW5pbmc6IGRhdGFXaXRob3V0SWQuc3RhbmRfYmFja19kYXlzX3JlbWFpbmluZyxcbiAgICAgICAgc3RhbmRfYmFja19zdGF0dXM6IGRhdGFXaXRob3V0SWQuc3RhbmRfYmFja19zdGF0dXMsXG4gICAgICAgIHN0YW5kX2JhY2tfaGlzdG9yeTogZGF0YVdpdGhvdXRJZC5zdGFuZF9iYWNrX2hpc3RvcnkgfHwgW11cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQWRkIG9wdGlvbmFsIGZpZWxkcyBpZiB0aGV5IGV4aXN0IChmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcbiAgICAgIGlmIChkYXRhV2l0aG91dElkLnJlYXNvbikge1xuICAgICAgICAoZGF0YVRvSW5zZXJ0IGFzIGFueSkucmVhc29uID0gZGF0YVdpdGhvdXRJZC5yZWFzb25cbiAgICAgIH1cbiAgICAgIGlmIChkYXRhV2l0aG91dElkLm5vdGVzKSB7XG4gICAgICAgIChkYXRhVG9JbnNlcnQgYXMgYW55KS5ub3RlcyA9IGRhdGFXaXRob3V0SWQubm90ZXNcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ0RhdGEgdG8gaW5zZXJ0ICh3aXRoIGdlbmVyYXRlZCBVVUlEKTonLCBkYXRhVG9JbnNlcnQpXG4gICAgICBjb25zb2xlLmxvZygnRGF0YSB0byBpbnNlcnQgSlNPTjonLCBKU09OLnN0cmluZ2lmeShkYXRhVG9JbnNlcnQsIG51bGwsIDIpKVxuICAgICAgXG4gICAgICAvLyBWYWxpZGF0ZSByZXF1aXJlZCBmaWVsZHNcbiAgICAgIGNvbnN0IHJlcXVpcmVkRmllbGRzID0gWydpZCcsICdjcmV3X21lbWJlcl9pZCcsICdzdGFydF9kYXRlJywgJ2VuZF9kYXRlJywgJ2RheXNfY291bnQnLCAnc3RhbmRfYmFja19kYXlzX3JlcXVpcmVkJywgJ3N0YW5kX2JhY2tfZGF5c19jb21wbGV0ZWQnLCAnc3RhbmRfYmFja19kYXlzX3JlbWFpbmluZycsICdzdGFuZF9iYWNrX3N0YXR1cyddXG4gICAgICBjb25zdCBtaXNzaW5nRmllbGRzID0gcmVxdWlyZWRGaWVsZHMuZmlsdGVyKGZpZWxkID0+ICEoZGF0YVRvSW5zZXJ0IGFzIGFueSlbZmllbGRdICYmIChkYXRhVG9JbnNlcnQgYXMgYW55KVtmaWVsZF0gIT09IDApXG4gICAgICBcbiAgICAgIGlmIChtaXNzaW5nRmllbGRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignTWlzc2luZyByZXF1aXJlZCBmaWVsZHM6JywgbWlzc2luZ0ZpZWxkcylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIHJlcXVpcmVkIGZpZWxkczogJHttaXNzaW5nRmllbGRzLmpvaW4oJywgJyl9YClcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ0FsbCByZXF1aXJlZCBmaWVsZHMgcHJlc2VudCwgaW5zZXJ0aW5nIHRvIGRhdGFiYXNlLi4uJylcbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3N0YW5kX2JhY2tfcmVjb3JkcycpXG4gICAgICAgIC5pbnNlcnQoW2RhdGFUb0luc2VydF0pXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFN1cGFiYXNlIGVycm9yIGFkZGluZyBzdGFuZCBiYWNrIHJlY29yZDonLCBlcnJvcilcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGRldGFpbHM6JywgSlNPTi5zdHJpbmdpZnkoZXJyb3IsIG51bGwsIDIpKVxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgY29kZTonLCBlcnJvci5jb2RlKVxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgbWVzc2FnZTonLCBlcnJvci5tZXNzYWdlKVxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgaGludDonLCBlcnJvci5oaW50KVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFN0YW5kIGJhY2sgcmVjb3JkIGFkZGVkIHN1Y2Nlc3NmdWxseTonLCBkYXRhKVxuICAgICAgYXdhaXQgbG9hZERhdGEoKSAvLyBSZWxvYWQgYWxsIGRhdGFcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgYWRkaW5nIHN0YW5kIGJhY2sgcmVjb3JkOicsIGVycilcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBkZXRhaWxzOicsIEpTT04uc3RyaW5naWZ5KGVyciwgbnVsbCwgMikpXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICBjb25zdCB1cGRhdGVTdGFuZEJhY2tSZWNvcmQgPSBhc3luYyAocmVjb3JkSWQ6IHN0cmluZywgdXBkYXRlczogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdVcGRhdGluZyBzdGFuZCBiYWNrIHJlY29yZCBpbiBTdXBhYmFzZTonLCByZWNvcmRJZCwgdXBkYXRlcylcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdzdGFuZF9iYWNrX3JlY29yZHMnKVxuICAgICAgICAudXBkYXRlKHVwZGF0ZXMpXG4gICAgICAgIC5lcSgnaWQnLCByZWNvcmRJZClcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICBcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBlcnJvciB1cGRhdGluZyBzdGFuZCBiYWNrIHJlY29yZDonLCBlcnJvcilcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1N0YW5kIGJhY2sgcmVjb3JkIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5OicsIGRhdGEpXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpIC8vIFJlbG9hZCBhbGwgZGF0YVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHN0YW5kIGJhY2sgcmVjb3JkOicsIGVycilcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGFkZExvYW4gPSBhc3luYyAobG9hbkRhdGE6IGFueSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnQWRkaW5nIGxvYW4gdG8gU3VwYWJhc2U6JywgbG9hbkRhdGEpXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnbG9hbnMnKVxuICAgICAgICAuaW5zZXJ0KFtsb2FuRGF0YV0pXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignU3VwYWJhc2UgZXJyb3IgYWRkaW5nIGxvYW46JywgZXJyb3IpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdMb2FuIGFkZGVkIHN1Y2Nlc3NmdWxseTonLCBkYXRhKVxuICAgICAgYXdhaXQgbG9hZERhdGEoKSAvLyBSZWxvYWQgYWxsIGRhdGFcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgbG9hbjonLCBlcnIpXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICBjb25zdCBjb21wbGV0ZUxvYW4gPSBhc3luYyAobG9hbklkOiBzdHJpbmcsIG5vdGVzPzogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdDb21wbGV0aW5nIGxvYW4gaW4gU3VwYWJhc2U6JywgbG9hbklkKVxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2xvYW5zJylcbiAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgc3RhdHVzOiAndm9sdG9vaWQnLFxuICAgICAgICAgIGNvbXBsZXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIG5vdGVzOiBub3RlcyB8fCBcIlwiXG4gICAgICAgIH0pXG4gICAgICAgIC5lcSgnaWQnLCBsb2FuSWQpXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignU3VwYWJhc2UgZXJyb3IgY29tcGxldGluZyBsb2FuOicsIGVycm9yKVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnTG9hbiBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5OicsIGRhdGEpXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpIC8vIFJlbG9hZCBhbGwgZGF0YVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNvbXBsZXRpbmcgbG9hbjonLCBlcnIpXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICBjb25zdCBtYWtlUGF5bWVudCA9IGFzeW5jIChsb2FuSWQ6IHN0cmluZywgcGF5bWVudEFtb3VudDogbnVtYmVyLCBub3RlPzogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdNYWtpbmcgcGF5bWVudCBmb3IgbG9hbjonLCBsb2FuSWQsIHBheW1lbnRBbW91bnQpXG4gICAgICBcbiAgICAgIC8vIEZpcnN0LCBnZXQgdGhlIGN1cnJlbnQgbG9hblxuICAgICAgY29uc3QgeyBkYXRhOiBsb2FuLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2xvYW5zJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5lcSgnaWQnLCBsb2FuSWQpXG4gICAgICAgIC5zaW5nbGUoKVxuICAgICAgXG4gICAgICBpZiAoZmV0Y2hFcnJvciB8fCAhbG9hbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvYW4gbm90IGZvdW5kJylcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIG5ldyB2YWx1ZXNcbiAgICAgIGNvbnN0IG5ld1BhaWQgPSAobG9hbi5hbW91bnRfcGFpZCB8fCAwKSArIHBheW1lbnRBbW91bnRcbiAgICAgIGNvbnN0IG5ld1JlbWFpbmluZyA9IGxvYW4uYW1vdW50IC0gbmV3UGFpZFxuICAgICAgY29uc3QgbmV3U3RhdHVzID0gbmV3UmVtYWluaW5nIDw9IDAgPyAndm9sdG9vaWQnIDogJ29wZW4nXG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBwYXltZW50IGhpc3RvcnkgZW50cnlcbiAgICAgIGNvbnN0IHBheW1lbnRFbnRyeSA9IHtcbiAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBhbW91bnQ6IHBheW1lbnRBbW91bnQsXG4gICAgICAgIG5vdGU6IG5vdGUgfHwgJ0JldGFsaW5nIGFmZ2V0ZWtlbmQnLFxuICAgICAgICBwYWlkQnk6ICdVc2VyJ1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBVcGRhdGUgbG9hblxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2xvYW5zJylcbiAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgYW1vdW50X3BhaWQ6IG5ld1BhaWQsXG4gICAgICAgICAgYW1vdW50X3JlbWFpbmluZzogbmV3UmVtYWluaW5nLFxuICAgICAgICAgIHN0YXR1czogbmV3U3RhdHVzLFxuICAgICAgICAgIGNvbXBsZXRlZF9hdDogbmV3U3RhdHVzID09PSAndm9sdG9vaWQnID8gbmV3IERhdGUoKS50b0lTT1N0cmluZygpIDogbnVsbCxcbiAgICAgICAgICBwYXltZW50X2hpc3Rvcnk6IFsuLi4obG9hbi5wYXltZW50X2hpc3RvcnkgfHwgW10pLCBwYXltZW50RW50cnldXG4gICAgICAgIH0pXG4gICAgICAgIC5lcSgnaWQnLCBsb2FuSWQpXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignU3VwYWJhc2UgZXJyb3IgbWFraW5nIHBheW1lbnQ6JywgZXJyb3IpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdQYXltZW50IG1hZGUgc3VjY2Vzc2Z1bGx5OicsIGRhdGEpXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpIC8vIFJlbG9hZCBhbGwgZGF0YVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG1ha2luZyBwYXltZW50OicsIGVycilcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIC8vIFRyaXAgZnVuY3Rpb25zXG4gIGNvbnN0IGFkZFRyaXAgPSBhc3luYyAodHJpcERhdGE6IGFueSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnQWRkaW5nIHRyaXA6JywgdHJpcERhdGEpXG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd0cmlwcycpXG4gICAgICAgIC5pbnNlcnQoW3RyaXBEYXRhXSlcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICBcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgdHJpcDonLCBlcnJvcilcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1RyaXAgYWRkZWQgc3VjY2Vzc2Z1bGx5OicsIGRhdGEpXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpIC8vIFJlbG9hZCBhbGwgZGF0YVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyB0cmlwOicsIGVycilcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZVRyaXAgPSBhc3luYyAodHJpcElkOiBzdHJpbmcsIHVwZGF0ZXM6IGFueSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnVXBkYXRpbmcgdHJpcDonLCB0cmlwSWQsIHVwZGF0ZXMpXG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd0cmlwcycpXG4gICAgICAgIC51cGRhdGUoeyAuLi51cGRhdGVzLCB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSlcbiAgICAgICAgLmVxKCdpZCcsIHRyaXBJZClcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKVxuICAgICAgXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgdHJpcDonLCBlcnJvcilcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1RyaXAgdXBkYXRlZCBzdWNjZXNzZnVsbHk6JywgZGF0YSlcbiAgICAgIFxuICAgICAgLy8gSWYgdHJpcCBpcyBjb21wbGV0ZWQsIGF1dG8tdXBkYXRlIHZhc3RlIGRpZW5zdCByZWNvcmRzXG4gICAgICBpZiAodXBkYXRlcy5zdGF0dXMgPT09ICd2b2x0b29pZCcgJiYgZGF0YS5hZmxvc3Nlcl9pZCkge1xuICAgICAgICBjb25zb2xlLmxvZygn8J+agCBUcmlwIGNvbXBsZXRlZCAtIGF1dG8tdXBkYXRpbmcgdmFzdGUgZGllbnN0IHJlY29yZHMnKVxuICAgICAgICBhd2FpdCBhdXRvVXBkYXRlVmFzdGVEaWVuc3RGcm9tVHJpcChkYXRhKVxuICAgICAgfVxuICAgICAgXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpIC8vIFJlbG9hZCBhbGwgZGF0YVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHRyaXA6JywgZXJyKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cblxuICAvLyBWYXN0ZSBkaWVuc3QgZnVuY3Rpb25zXG4gIGNvbnN0IGFkZFZhc3RlRGllbnN0UmVjb3JkID0gYXN5bmMgKHJlY29yZERhdGE6IGFueSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnQWRkaW5nIHZhc3RlIGRpZW5zdCByZWNvcmQ6JywgcmVjb3JkRGF0YSlcbiAgICAgIGNvbnNvbGUubG9nKCdSZWNvcmQgZGF0YSBkZXRhaWxzOicsIEpTT04uc3RyaW5naWZ5KHJlY29yZERhdGEsIG51bGwsIDIpKVxuICAgICAgXG4gICAgICAvLyBWYWxpZGF0ZSByZXF1aXJlZCBmaWVsZHNcbiAgICAgIGNvbnN0IHJlcXVpcmVkRmllbGRzID0gWydhZmxvc3Nlcl9pZCcsICd5ZWFyJywgJ21vbnRoJywgJ3JlcXVpcmVkX2RheXMnLCAnYWN0dWFsX2RheXMnLCAnYmFsYW5jZV9kYXlzJ11cbiAgICAgIGNvbnN0IG1pc3NpbmdGaWVsZHMgPSByZXF1aXJlZEZpZWxkcy5maWx0ZXIoZmllbGQgPT4gcmVjb3JkRGF0YVtmaWVsZF0gPT09IHVuZGVmaW5lZCB8fCByZWNvcmREYXRhW2ZpZWxkXSA9PT0gbnVsbClcbiAgICAgIFxuICAgICAgaWYgKG1pc3NpbmdGaWVsZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgTWlzc2luZyByZXF1aXJlZCBmaWVsZHM6ICR7bWlzc2luZ0ZpZWxkcy5qb2luKCcsICcpfWApXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1ZhbGlkYXRpb24gZXJyb3I6JywgZXJyb3IpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHJlY29yZCBhbHJlYWR5IGV4aXN0cyBmb3IgdGhpcyBhZmxvc3Nlci95ZWFyL21vbnRoIGNvbWJpbmF0aW9uXG4gICAgICBjb25zdCB7IGRhdGE6IGV4aXN0aW5nUmVjb3JkLCBlcnJvcjogY2hlY2tFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Zhc3RlX2RpZW5zdF9yZWNvcmRzJylcbiAgICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgICAuZXEoJ2FmbG9zc2VyX2lkJywgcmVjb3JkRGF0YS5hZmxvc3Nlcl9pZClcbiAgICAgICAgLmVxKCd5ZWFyJywgcmVjb3JkRGF0YS55ZWFyKVxuICAgICAgICAuZXEoJ21vbnRoJywgcmVjb3JkRGF0YS5tb250aClcbiAgICAgICAgLnNpbmdsZSgpXG4gICAgICBcbiAgICAgIGlmIChleGlzdGluZ1JlY29yZCkge1xuICAgICAgICBjb25zb2xlLmxvZygnUmVjb3JkIGFscmVhZHkgZXhpc3RzIGZvciB0aGlzIGFmbG9zc2VyL3llYXIvbW9udGggY29tYmluYXRpb24sIHVwZGF0aW5nIGluc3RlYWQnKVxuICAgICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgcmVjb3JkIGluc3RlYWQgb2YgY3JlYXRpbmcgbmV3IG9uZVxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCd2YXN0ZV9kaWVuc3RfcmVjb3JkcycpXG4gICAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgICByZXF1aXJlZF9kYXlzOiByZWNvcmREYXRhLnJlcXVpcmVkX2RheXMsXG4gICAgICAgICAgICBhY3R1YWxfZGF5czogcmVjb3JkRGF0YS5hY3R1YWxfZGF5cyxcbiAgICAgICAgICAgIGJhbGFuY2VfZGF5czogcmVjb3JkRGF0YS5iYWxhbmNlX2RheXMsXG4gICAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5lcSgnaWQnLCBleGlzdGluZ1JlY29yZC5pZClcbiAgICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGV4aXN0aW5nIHZhc3RlIGRpZW5zdCByZWNvcmQ6JywgZXJyb3IpXG4gICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coJ1Zhc3RlIGRpZW5zdCByZWNvcmQgdXBkYXRlZCBzdWNjZXNzZnVsbHk6JywgZGF0YSlcbiAgICAgICAgYXdhaXQgbG9hZERhdGEoKSAvLyBSZWxvYWQgYWxsIGRhdGFcbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgbm8gZXhpc3RpbmcgcmVjb3JkLCBjcmVhdGUgbmV3IG9uZVxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Zhc3RlX2RpZW5zdF9yZWNvcmRzJylcbiAgICAgICAgLmluc2VydChbcmVjb3JkRGF0YV0pXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignU3VwYWJhc2UgZXJyb3IgYWRkaW5nIHZhc3RlIGRpZW5zdCByZWNvcmQ6JywgZXJyb3IpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFpbHM6JywgSlNPTi5zdHJpbmdpZnkoZXJyb3IsIG51bGwsIDIpKVxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjb2RlOicsIGVycm9yLmNvZGUpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG1lc3NhZ2U6JywgZXJyb3IubWVzc2FnZSlcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaGludDonLCBlcnJvci5oaW50KVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnVmFzdGUgZGllbnN0IHJlY29yZCBhZGRlZCBzdWNjZXNzZnVsbHk6JywgZGF0YSlcbiAgICAgIGF3YWl0IGxvYWREYXRhKCkgLy8gUmVsb2FkIGFsbCBkYXRhXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIHZhc3RlIGRpZW5zdCByZWNvcmQ6JywgZXJyKVxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGV0YWlsczonLCBKU09OLnN0cmluZ2lmeShlcnIsIG51bGwsIDIpKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgY29uc3QgdXBkYXRlVmFzdGVEaWVuc3RSZWNvcmQgPSBhc3luYyAocmVjb3JkSWQ6IHN0cmluZywgdXBkYXRlczogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdVcGRhdGluZyB2YXN0ZSBkaWVuc3QgcmVjb3JkOicsIHJlY29yZElkLCB1cGRhdGVzKVxuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndmFzdGVfZGllbnN0X3JlY29yZHMnKVxuICAgICAgICAudXBkYXRlKHsgLi4udXBkYXRlcywgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH0pXG4gICAgICAgIC5lcSgnaWQnLCByZWNvcmRJZClcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKVxuICAgICAgXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgdmFzdGUgZGllbnN0IHJlY29yZDonLCBlcnJvcilcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1Zhc3RlIGRpZW5zdCByZWNvcmQgdXBkYXRlZCBzdWNjZXNzZnVsbHk6JywgZGF0YSlcbiAgICAgIGF3YWl0IGxvYWREYXRhKCkgLy8gUmVsb2FkIGFsbCBkYXRhXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgdmFzdGUgZGllbnN0IHJlY29yZDonLCBlcnIpXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICBjb25zdCBkZWxldGVWYXN0ZURpZW5zdFJlY29yZCA9IGFzeW5jIChyZWNvcmRJZDogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdEZWxldGluZyB2YXN0ZSBkaWVuc3QgcmVjb3JkOicsIHJlY29yZElkKVxuICAgICAgXG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndmFzdGVfZGllbnN0X3JlY29yZHMnKVxuICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgLmVxKCdpZCcsIHJlY29yZElkKVxuICAgICAgXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgdmFzdGUgZGllbnN0IHJlY29yZDonLCBlcnJvcilcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1Zhc3RlIGRpZW5zdCByZWNvcmQgZGVsZXRlZCBzdWNjZXNzZnVsbHknKVxuICAgICAgYXdhaXQgbG9hZERhdGEoKSAvLyBSZWxvYWQgYWxsIGRhdGFcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIHZhc3RlIGRpZW5zdCByZWNvcmQ6JywgZXJyKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgLy8gRGVsZXRlIHRyaXAgcGVybWFuZW50bHlcbiAgY29uc3QgZGVsZXRlVHJpcCA9IGFzeW5jICh0cmlwSWQ6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndHJpcHMnKVxuICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgLmVxKCdpZCcsIHRyaXBJZClcbiAgICAgIFxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N1cGFiYXNlIGVycm9yIGRlbGV0aW5nIHRyaXA6JywgZXJyb3IpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdUcmlwIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5JylcbiAgICAgIGF3YWl0IGxvYWREYXRhKCkgLy8gUmVsb2FkIGFsbCBkYXRhXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyB0cmlwOicsIGVycilcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIC8vIERlbGV0ZSBhZmxvc3NlciBwZXJtYW5lbnRseVxuICBjb25zdCBkZWxldGVBZmxvc3NlciA9IGFzeW5jIChhZmxvc3NlcklkOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gRmlyc3QgZGVsZXRlIGFsbCByZWxhdGVkIHJlY29yZHNcbiAgICAgIGF3YWl0IHN1cGFiYXNlLmZyb20oJ3Zhc3RlX2RpZW5zdF9yZWNvcmRzJykuZGVsZXRlKCkuZXEoJ2FmbG9zc2VyX2lkJywgYWZsb3NzZXJJZClcbiAgICAgIGF3YWl0IHN1cGFiYXNlLmZyb20oJ3RyaXBzJykuZGVsZXRlKCkuZXEoJ2FmbG9zc2VyX2lkJywgYWZsb3NzZXJJZClcbiAgICAgIFxuICAgICAgLy8gVGhlbiBkZWxldGUgdGhlIGFmbG9zc2VyXG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnY3JldycpXG4gICAgICAgIC5kZWxldGUoKVxuICAgICAgICAuZXEoJ2lkJywgYWZsb3NzZXJJZClcbiAgICAgIFxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N1cGFiYXNlIGVycm9yIGRlbGV0aW5nIGFmbG9zc2VyOicsIGVycm9yKVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnQWZsb3NzZXIgZGVsZXRlZCBzdWNjZXNzZnVsbHknKVxuICAgICAgYXdhaXQgbG9hZERhdGEoKSAvLyBSZWxvYWQgYWxsIGRhdGFcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIGFmbG9zc2VyOicsIGVycilcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIC8vIE5vdGVzIGZ1bmN0aW9uc1xuICBjb25zdCBhZGROb3RlVG9DcmV3ID0gYXN5bmMgKGNyZXdJZDogc3RyaW5nLCBub3RlOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gR2V0IGN1cnJlbnQgY3JldyBtZW1iZXIgZGF0YVxuICAgICAgY29uc3QgeyBkYXRhOiBjcmV3RGF0YSwgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdjcmV3JylcbiAgICAgICAgLnNlbGVjdCgnYWN0aXZlX25vdGVzJylcbiAgICAgICAgLmVxKCdpZCcsIGNyZXdJZClcbiAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICBpZiAoZmV0Y2hFcnJvcikgdGhyb3cgZmV0Y2hFcnJvcjtcblxuICAgICAgLy8gUGFyc2UgZXhpc3Rpbmcgbm90ZXMgb3IgaW5pdGlhbGl6ZSBlbXB0eSBhcnJheVxuICAgICAgY29uc3QgY3VycmVudE5vdGVzID0gY3Jld0RhdGE/LmFjdGl2ZV9ub3RlcyB8fCBbXTtcbiAgICAgIFxuICAgICAgLy8gQWRkIG5ldyBub3RlIHdpdGggdGltZXN0YW1wXG4gICAgICBjb25zdCBuZXdOb3RlID0ge1xuICAgICAgICBpZDogRGF0ZS5ub3coKS50b1N0cmluZygpLCAvLyBTaW1wbGUgSUQgZ2VuZXJhdGlvblxuICAgICAgICBjb250ZW50OiBub3RlLFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgY3JlYXRlZEJ5OiAndXNlcicgLy8gWW91IGNvdWxkIGdldCB0aGlzIGZyb20gYXV0aCBjb250ZXh0XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB1cGRhdGVkTm90ZXMgPSBbLi4uY3VycmVudE5vdGVzLCBuZXdOb3RlXTtcblxuICAgICAgLy8gVXBkYXRlIGNyZXcgbWVtYmVyIHdpdGggbmV3IG5vdGVzXG4gICAgICBjb25zdCB7IGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2NyZXcnKVxuICAgICAgICAudXBkYXRlKHsgYWN0aXZlX25vdGVzOiB1cGRhdGVkTm90ZXMgfSlcbiAgICAgICAgLmVxKCdpZCcsIGNyZXdJZCk7XG5cbiAgICAgIGlmICh1cGRhdGVFcnJvcikgdGhyb3cgdXBkYXRlRXJyb3I7XG5cbiAgICAgIGNvbnNvbGUubG9nKCdOb3RlIGFkZGVkIHN1Y2Nlc3NmdWxseScpXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpOyAvLyBSZWxvYWQgZGF0YVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgbm90ZTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcmVtb3ZlTm90ZUZyb21DcmV3ID0gYXN5bmMgKGNyZXdJZDogc3RyaW5nLCBub3RlSWQ6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgY3VycmVudCBjcmV3IG1lbWJlciBkYXRhXG4gICAgICBjb25zdCB7IGRhdGE6IGNyZXdEYXRhLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2NyZXcnKVxuICAgICAgICAuc2VsZWN0KCdhY3RpdmVfbm90ZXMsIGFyY2hpdmVkX25vdGVzJylcbiAgICAgICAgLmVxKCdpZCcsIGNyZXdJZClcbiAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICBpZiAoZmV0Y2hFcnJvcikgdGhyb3cgZmV0Y2hFcnJvcjtcblxuICAgICAgY29uc3QgY3VycmVudEFjdGl2ZU5vdGVzID0gY3Jld0RhdGE/LmFjdGl2ZV9ub3RlcyB8fCBbXTtcbiAgICAgIGNvbnN0IGN1cnJlbnRBcmNoaXZlZE5vdGVzID0gY3Jld0RhdGE/LmFyY2hpdmVkX25vdGVzIHx8IFtdO1xuXG4gICAgICAvLyBGaW5kIHRoZSBub3RlIHRvIHJlbW92ZVxuICAgICAgY29uc3Qgbm90ZVRvQXJjaGl2ZSA9IGN1cnJlbnRBY3RpdmVOb3Rlcy5maW5kKChub3RlOiBhbnkpID0+IG5vdGUuaWQgPT09IG5vdGVJZCk7XG4gICAgICBpZiAoIW5vdGVUb0FyY2hpdmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3RlIG5vdCBmb3VuZCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgZnJvbSBhY3RpdmUgbm90ZXNcbiAgICAgIGNvbnN0IHVwZGF0ZWRBY3RpdmVOb3RlcyA9IGN1cnJlbnRBY3RpdmVOb3Rlcy5maWx0ZXIoKG5vdGU6IGFueSkgPT4gbm90ZS5pZCAhPT0gbm90ZUlkKTtcblxuICAgICAgLy8gQWRkIHRvIGFyY2hpdmVkIG5vdGVzIHdpdGggYXJjaGl2ZSB0aW1lc3RhbXBcbiAgICAgIGNvbnN0IGFyY2hpdmVkTm90ZSA9IHtcbiAgICAgICAgLi4ubm90ZVRvQXJjaGl2ZSxcbiAgICAgICAgYXJjaGl2ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9O1xuICAgICAgY29uc3QgdXBkYXRlZEFyY2hpdmVkTm90ZXMgPSBbLi4uY3VycmVudEFyY2hpdmVkTm90ZXMsIGFyY2hpdmVkTm90ZV07XG5cbiAgICAgIC8vIFVwZGF0ZSBjcmV3IG1lbWJlclxuICAgICAgY29uc3QgeyBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdjcmV3JylcbiAgICAgICAgLnVwZGF0ZSh7IFxuICAgICAgICAgIGFjdGl2ZV9ub3RlczogdXBkYXRlZEFjdGl2ZU5vdGVzLFxuICAgICAgICAgIGFyY2hpdmVkX25vdGVzOiB1cGRhdGVkQXJjaGl2ZWROb3Rlc1xuICAgICAgICB9KVxuICAgICAgICAuZXEoJ2lkJywgY3Jld0lkKTtcblxuICAgICAgaWYgKHVwZGF0ZUVycm9yKSB0aHJvdyB1cGRhdGVFcnJvcjtcblxuICAgICAgY29uc29sZS5sb2coJ05vdGUgYXJjaGl2ZWQgc3VjY2Vzc2Z1bGx5JylcbiAgICAgIGF3YWl0IGxvYWREYXRhKCk7IC8vIFJlbG9hZCBkYXRhXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIG5vdGU6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuXG4gIC8vIEFkZCB0YXNrXG4gIGNvbnN0IGFkZFRhc2sgPSBhc3luYyAodGFza0RhdGE6IGFueSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+TnSBBZGRpbmcgdGFzayB3aXRoIGRhdGE6JywgSlNPTi5zdHJpbmdpZnkodGFza0RhdGEsIG51bGwsIDIpKVxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Rhc2tzJylcbiAgICAgICAgLmluc2VydChbdGFza0RhdGFdKVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpXG4gICAgICBcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgU3VwYWJhc2UgZXJyb3IgYWRkaW5nIHRhc2s6JywgZXJyb3IpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBjb2RlOicsIGVycm9yLmNvZGUpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBtZXNzYWdlOicsIGVycm9yLm1lc3NhZ2UpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBkZXRhaWxzOicsIGVycm9yLmRldGFpbHMpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBoaW50OicsIGVycm9yLmhpbnQpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICBhd2FpdCBsb2FkRGF0YSgpXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgdGFzazonLCBlcnIpXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZXRhaWxzOicsIEpTT04uc3RyaW5naWZ5KGVyciwgbnVsbCwgMikpXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICAvLyBVcGRhdGUgdGFza1xuICBjb25zdCB1cGRhdGVUYXNrID0gYXN5bmMgKHRhc2tJZDogc3RyaW5nLCB1cGRhdGVzOiBhbnkpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Rhc2tzJylcbiAgICAgICAgLnVwZGF0ZSh1cGRhdGVzKVxuICAgICAgICAuZXEoJ2lkJywgdGFza0lkKVxuICAgICAgXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyB0YXNrOicsIGVycilcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIC8vIERlbGV0ZSB0YXNrXG4gIGNvbnN0IGRlbGV0ZVRhc2sgPSBhc3luYyAodGFza0lkOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Rhc2tzJylcbiAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgIC5lcSgnaWQnLCB0YXNrSWQpXG4gICAgICBcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICAgIGF3YWl0IGxvYWREYXRhKClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIHRhc2s6JywgZXJyKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgLy8gQ29tcGxldGUgdGFza1xuICBjb25zdCBjb21wbGV0ZVRhc2sgPSBhc3luYyAodGFza0lkOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gSGFhbCBlZXJzdCBkZSBnZXJlbGF0ZWVyZGUgc2hpcF92aXNpdCBvcCAoYWxzIGRpZSBiZXN0YWF0KVxuICAgICAgY29uc3QgeyBkYXRhOiB0YXNrRGF0YSwgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd0YXNrcycpXG4gICAgICAgIC5zZWxlY3QoJ2lkLCByZWxhdGVkX3NoaXBfdmlzaXRfaWQnKVxuICAgICAgICAuZXEoJ2lkJywgdGFza0lkKVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgaWYgKGZldGNoRXJyb3IpIHRocm93IGZldGNoRXJyb3JcblxuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Rhc2tzJylcbiAgICAgICAgLnVwZGF0ZSh7IFxuICAgICAgICAgIGNvbXBsZXRlZDogdHJ1ZSxcbiAgICAgICAgICBjb21wbGV0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9KVxuICAgICAgICAuZXEoJ2lkJywgdGFza0lkKVxuICAgICAgXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIC8vIEFscyBkZXplIHRhYWsgZ2Vrb3BwZWxkIGlzIGFhbiBlZW4gc2NoZWVwc2Jlem9laywgemV0IGRhYXIgZGUgZm9sbG93LXVwIHVpdFxuICAgICAgaWYgKHRhc2tEYXRhPy5yZWxhdGVkX3NoaXBfdmlzaXRfaWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IGVycm9yOiB2aXNpdEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgLmZyb20oJ3NoaXBfdmlzaXRzJylcbiAgICAgICAgICAgIC51cGRhdGUoe1xuICAgICAgICAgICAgICBmb2xsb3dfdXBfbmVlZGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgZm9sbG93X3VwX25vdGVzOiBudWxsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmVxKCdpZCcsIHRhc2tEYXRhLnJlbGF0ZWRfc2hpcF92aXNpdF9pZClcblxuICAgICAgICAgIGlmICh2aXNpdEVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyByZWxhdGVkIHNoaXBfdmlzaXQgYWZ0ZXIgY29tcGxldGluZyB0YXNrOicsIHZpc2l0RXJyb3IpXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChpbm5lckVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IgdXBkYXRpbmcgc2hpcF92aXNpdCBmb3IgY29tcGxldGVkIHRhc2s6JywgaW5uZXJFcnIpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYXdhaXQgbG9hZERhdGEoKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY29tcGxldGluZyB0YXNrOicsIGVycilcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBpbmNpZGVudFxuICBjb25zdCBhZGRJbmNpZGVudCA9IGFzeW5jIChpbmNpZGVudERhdGE6IGFueSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+TnSBBZGRpbmcgaW5jaWRlbnQgd2l0aCBkYXRhOicsIEpTT04uc3RyaW5naWZ5KGluY2lkZW50RGF0YSwgbnVsbCwgMikpXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnaW5jaWRlbnRzJylcbiAgICAgICAgLmluc2VydChbaW5jaWRlbnREYXRhXSlcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKVxuICAgICAgXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFN1cGFiYXNlIGVycm9yIGFkZGluZyBpbmNpZGVudDonLCBlcnJvcilcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGNvZGU6JywgZXJyb3IuY29kZSlcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIG1lc3NhZ2U6JywgZXJyb3IubWVzc2FnZSlcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGRldGFpbHM6JywgZXJyb3IuZGV0YWlscylcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGhpbnQ6JywgZXJyb3IuaGludClcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIGF3YWl0IGxvYWREYXRhKClcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBpbmNpZGVudDonLCBlcnIpXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZXRhaWxzOicsIEpTT04uc3RyaW5naWZ5KGVyciwgbnVsbCwgMikpXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICAvLyBVcGRhdGUgaW5jaWRlbnRcbiAgY29uc3QgdXBkYXRlSW5jaWRlbnQgPSBhc3luYyAoaW5jaWRlbnRJZDogc3RyaW5nLCB1cGRhdGVzOiBhbnkpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2luY2lkZW50cycpXG4gICAgICAgIC51cGRhdGUodXBkYXRlcylcbiAgICAgICAgLmVxKCdpZCcsIGluY2lkZW50SWQpXG4gICAgICBcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICAgIGF3YWl0IGxvYWREYXRhKClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGluY2lkZW50OicsIGVycilcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIC8vIERlbGV0ZSBpbmNpZGVudFxuICBjb25zdCBkZWxldGVJbmNpZGVudCA9IGFzeW5jIChpbmNpZGVudElkOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2luY2lkZW50cycpXG4gICAgICAgIC5kZWxldGUoKVxuICAgICAgICAuZXEoJ2lkJywgaW5jaWRlbnRJZClcbiAgICAgIFxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgICAgYXdhaXQgbG9hZERhdGEoKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgaW5jaWRlbnQ6JywgZXJyKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzaGlwcyxcbiAgICBjcmV3LFxuICAgIHNpY2tMZWF2ZSxcbiAgICBzdGFuZEJhY2tSZWNvcmRzLFxuICAgIGxvYW5zLFxuICAgIHRyaXBzLFxuICAgIHRhc2tzLFxuICAgIGluY2lkZW50cyxcbiAgICBsb2FkaW5nLFxuICAgIGVycm9yLFxuICAgIGxvYWREYXRhLFxuICAgIGNyZXdDb2xvclRhZ3MsXG4gICAgYXN5bmMgc2V0Q3Jld0NvbG9yVGFnKGNyZXdJZDogc3RyaW5nLCBjb2xvcjogc3RyaW5nIHwgbnVsbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFjcmV3SWQpIHJldHVyblxuICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAvLyB1cHNlcnQgY29sb3JcbiAgICAgICAgICBjb25zdCB7IGVycm9yOiB1cHNlcnRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5mcm9tKCdjcmV3X2NvbG9yX3RhZ3MnKVxuICAgICAgICAgICAgLnVwc2VydCh7IGNyZXdfaWQ6IGNyZXdJZCwgY29sb3IgfSwgeyBvbkNvbmZsaWN0OiAnY3Jld19pZCcgfSlcbiAgICAgICAgICBpZiAodXBzZXJ0RXJyb3IpIHRocm93IHVwc2VydEVycm9yXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZGVsZXRlIGNvbG9yXG4gICAgICAgICAgY29uc3QgeyBlcnJvcjogZGVsRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAuZnJvbSgnY3Jld19jb2xvcl90YWdzJylcbiAgICAgICAgICAgIC5kZWxldGUoKVxuICAgICAgICAgICAgLmVxKCdjcmV3X2lkJywgY3Jld0lkKVxuICAgICAgICAgIGlmIChkZWxFcnJvcikgdGhyb3cgZGVsRXJyb3JcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgbG9jYWwgc3RhdGVcbiAgICAgICAgc2V0Q3Jld0NvbG9yVGFncygocHJldikgPT4ge1xuICAgICAgICAgIGNvbnN0IG5leHQgPSB7IC4uLnByZXYgfVxuICAgICAgICAgIGlmIChjb2xvcikgbmV4dFtjcmV3SWRdID0gY29sb3JcbiAgICAgICAgICBlbHNlIGRlbGV0ZSBuZXh0W2NyZXdJZF1cbiAgICAgICAgICByZXR1cm4gbmV4dFxuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBlcnI6IGFueSA9IGVcbiAgICAgICAgY29uc3QgbXNnID0gZXJyPy5tZXNzYWdlIHx8ICh0eXBlb2YgZXJyID09PSAnc3RyaW5nJyA/IGVyciA6IEpTT04uc3RyaW5naWZ5KGVycikpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNldHRpbmcgY3JldyBjb2xvciB0YWc6JywgbXNnKVxuICAgICAgICAvLyBJZiB0YWJsZSBtaXNzaW5nLCBzdXJmYWNlIGEgY2xlYXIgaGludCBvbmNlXG4gICAgICAgIGlmIChtc2c/LmluY2x1ZGVzKCdyZWxhdGlvbicpICYmIG1zZz8uaW5jbHVkZXMoJ2NyZXdfY29sb3JfdGFncycpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdIaW50OiBjcmVhdGUgdGFibGUgY3Jld19jb2xvcl90YWdzIChjcmV3X2lkIHV1aWQgcHJpbWFyeSBrZXkgcmVmZXJlbmNlcyBjcmV3KGlkKSwgY29sb3IgdGV4dCBub3QgbnVsbCknKVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVcbiAgICAgIH1cbiAgICB9LFxuICAgIGFkZENyZXcsXG4gICAgdXBkYXRlQ3JldyxcbiAgICBkZWxldGVDcmV3LFxuICAgIGFkZFNoaXAsXG4gICAgdXBkYXRlU2hpcCxcbiAgICBkZWxldGVTaGlwLFxuICAgIGFkZFNpY2tMZWF2ZSxcbiAgICB1cGRhdGVTaWNrTGVhdmUsXG4gICAgYWRkU3RhbmRCYWNrUmVjb3JkLFxuICAgIHVwZGF0ZVN0YW5kQmFja1JlY29yZCxcbiAgICBhZGRMb2FuLFxuICAgIGNvbXBsZXRlTG9hbixcbiAgICBtYWtlUGF5bWVudCxcbiAgICBhZGRUcmlwLFxuICAgIHVwZGF0ZVRyaXAsXG4gICAgZGVsZXRlVHJpcCxcbiAgICBkZWxldGVBZmxvc3NlcixcbiAgICB2YXN0ZURpZW5zdFJlY29yZHMsXG4gICAgYWRkVmFzdGVEaWVuc3RSZWNvcmQsXG4gICAgdXBkYXRlVmFzdGVEaWVuc3RSZWNvcmQsXG4gICAgZGVsZXRlVmFzdGVEaWVuc3RSZWNvcmQsXG4gICAgYWRkTm90ZVRvQ3JldyxcbiAgICByZW1vdmVOb3RlRnJvbUNyZXcsXG4gICAgYWRkVGFzayxcbiAgICB1cGRhdGVUYXNrLFxuICAgIGRlbGV0ZVRhc2ssXG4gICAgY29tcGxldGVUYXNrLFxuICAgIGFkZEluY2lkZW50LFxuICAgIHVwZGF0ZUluY2lkZW50LFxuICAgIGRlbGV0ZUluY2lkZW50XG4gIH1cbn0gXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJzdXBhYmFzZSIsImNhbGN1bGF0ZVdvcmtEYXlzVmFzdGVEaWVuc3QiLCJzdGFydERhdGUiLCJzdGFydFRpbWUiLCJlbmREYXRlIiwiZW5kVGltZSIsInBhcnNlRGF0ZSIsImRhdGVTdHIiLCJjb25zb2xlIiwiZXJyb3IiLCJEYXRlIiwiaW5jbHVkZXMiLCJ0ZXN0IiwiZGF0ZSIsImlzTmFOIiwiZ2V0VGltZSIsInBhcnRzIiwic3BsaXQiLCJsZW5ndGgiLCJkYXkiLCJwYXJzZUludCIsIm1vbnRoIiwieWVhciIsInBhcnNlVGltZSIsInRpbWVTdHIiLCJ0aW1lUGFydHMiLCJob3VycyIsIm1pbnV0ZXMiLCJzdGFydCIsImVuZCIsInN0YXJ0VGltZUhvdXJzIiwiZW5kVGltZUhvdXJzIiwic3RhcnREYXRlVGltZSIsInNldEhvdXJzIiwiTWF0aCIsImZsb29yIiwiZW5kRGF0ZVRpbWUiLCJ0aW1lRGlmZk1zIiwidG90YWxIb3VycyIsImRheUNyZWRpdHMiLCJjZWlsIiwiYXV0b0FjdGl2YXRlQ3Jld01lbWJlcnMiLCJjcmV3RGF0YSIsInRvZGF5IiwibWVtYmVyIiwic3RhdHVzIiwiZXhwZWN0ZWRfc3RhcnRfZGF0ZSIsInNoaXBfaWQiLCJyZWdpbWUiLCJsb2ciLCJmaXJzdF9uYW1lIiwibGFzdF9uYW1lIiwiZnJvbSIsInVwZGF0ZSIsIm9uX2JvYXJkX3NpbmNlIiwidGh1aXNfc2luZHMiLCJzdWJfc3RhdHVzIiwiZXEiLCJpZCIsImVyciIsImF1dG9Sb3RhdGVDcmV3TWVtYmVycyIsInJlZ2ltZVdlZWtzIiwicmVnaW1lRGF5cyIsIm9uQm9hcmREYXRlIiwiZGF5c1NpbmNlT25Cb2FyZCIsInRodWlzU2luZHMiLCJzZXREYXRlIiwiZ2V0RGF0ZSIsInRvSVNPU3RyaW5nIiwidGh1aXNEYXRlIiwiZGF5c1NpbmNlVGh1aXMiLCJvbkJvYXJkU2luY2UiLCJhdXRvTWFuYWdlVmFzdGVEaWVuc3RSZWNvcmRzIiwidmFzdGVEaWVuc3RSZWNvcmRzIiwidHJpcHNEYXRhIiwiY3VycmVudFllYXIiLCJnZXRGdWxsWWVhciIsImN1cnJlbnRNb250aCIsImdldE1vbnRoIiwidmFzdGVEaWVuc3RBZmxvc3NlcnMiLCJmaWx0ZXIiLCJ2YXN0ZV9kaWVuc3QiLCJhZmxvc3NlciIsImV4aXN0aW5nUmVjb3JkIiwiZmluZCIsInJlY29yZCIsImFmbG9zc2VyX2lkIiwibmV3UmVjb3JkIiwicmVxdWlyZWRfZGF5cyIsImFjdHVhbF9kYXlzIiwiYmFsYW5jZV9kYXlzIiwibm90ZXMiLCJkYXRhIiwiaW5zZXJ0Iiwic2VsZWN0Iiwic2luZ2xlIiwiY3VycmVudE1vbnRoVHJpcHMiLCJ0cmlwIiwiZWluZF9kYXR1bSIsInRvdGFsV29ya0RheXMiLCJ3b3JrRGF5cyIsImNhbGN1bGF0ZVdvcmtEYXlzIiwic3RhcnRfZGF0dW0iLCJzdGFydF90aWpkIiwiZWluZF90aWpkIiwicmVxdWlyZWREYXlzIiwiYmVnaW5zYWxkbyIsInN0YXJ0c2FsZG9Ob3RlIiwibm90ZSIsInRleHQiLCJtYXRjaCIsInN0YXJ0c2FsZG8iLCJwYXJzZUZsb2F0IiwiYmFsYW5jZURheXMiLCJjYXBwZWRBY3R1YWxEYXlzIiwibWluIiwiY2FwcGVkQmFsYW5jZURheXMiLCJtYXgiLCJKU09OIiwic3RyaW5naWZ5IiwiaXNvRGF0ZSIsInBhZFN0YXJ0IiwidGltZURpZmYiLCJkYXlzRGlmZiIsImF1dG9VcGRhdGVWYXN0ZURpZW5zdEZyb21UcmlwIiwiY29tcGxldGVkVHJpcCIsImFmbG9zc2VyRXJyb3IiLCJyZWNvcmRFcnJvciIsImNvZGUiLCJyZWNvcmRJZCIsImNyZWF0ZWRSZWNvcmQiLCJjcmVhdGVFcnJvciIsImFsbFRyaXBzIiwidHJpcHNFcnJvciIsIm5vdCIsInRyaXBFbmREYXRlIiwidHJpcFdvcmtEYXlzIiwidXBkYXRlRXJyb3IiLCJmb3JjZVJlY2FsY3VsYXRlQWxsVmFzdGVEaWVuc3RSZWNvcmRzIiwiYWxsUmVjb3JkcyIsImZldGNoRXJyb3IiLCJjcmV3IiwicmVzZXRBbGxWYXN0ZURpZW5zdFJlY29yZHMiLCJ1c2VTdXBhYmFzZURhdGEiLCJzaGlwcyIsInNldFNoaXBzIiwic2V0Q3JldyIsInNpY2tMZWF2ZSIsInNldFNpY2tMZWF2ZSIsInN0YW5kQmFja1JlY29yZHMiLCJzZXRTdGFuZEJhY2tSZWNvcmRzIiwibG9hbnMiLCJzZXRMb2FucyIsInRyaXBzIiwic2V0VHJpcHMiLCJzZXRWYXN0ZURpZW5zdFJlY29yZHMiLCJ0YXNrcyIsInNldFRhc2tzIiwiaW5jaWRlbnRzIiwic2V0SW5jaWRlbnRzIiwibG9hZGluZyIsInNldExvYWRpbmciLCJzZXRFcnJvciIsImNyZXdDb2xvclRhZ3MiLCJzZXRDcmV3Q29sb3JUYWdzIiwibG9hZERhdGEiLCJzZXNzaW9uIiwiYXV0aCIsImdldFNlc3Npb24iLCJ3YXJuIiwidGVzdERhdGEiLCJ0ZXN0RXJyb3IiLCJsaW1pdCIsInNoaXBzRGF0YSIsInNoaXBzRXJyb3IiLCJvcmRlciIsImNyZXdFcnJvciIsInNpY2tMZWF2ZURhdGEiLCJzaWNrTGVhdmVFcnJvciIsImFzY2VuZGluZyIsInN0YW5kQmFja0RhdGEiLCJzdGFuZEJhY2tFcnJvciIsImxvYW5zRGF0YSIsImxvYW5zRXJyb3IiLCJ2YXN0ZURpZW5zdERhdGEiLCJ2YXN0ZURpZW5zdEVycm9yIiwidGFza3NEYXRhIiwidGFza3NFcnJvciIsImluY2lkZW50c0RhdGEiLCJpbmNpZGVudHNFcnJvciIsImNvbG9yUm93cyIsImNvbG9yRXJyIiwibXNnIiwibWVzc2FnZSIsIlN0cmluZyIsIm1hcCIsInJvdyIsImNyZXdfaWQiLCJjb2xvciIsImUiLCJFcnJvciIsInNoaXBzU3Vic2NyaXB0aW9uIiwiY2hhbm5lbCIsIm9uIiwiZXZlbnQiLCJzY2hlbWEiLCJ0YWJsZSIsInN1YnNjcmliZSIsImNyZXdTdWJzY3JpcHRpb24iLCJzaWNrTGVhdmVTdWJzY3JpcHRpb24iLCJzdGFuZEJhY2tTdWJzY3JpcHRpb24iLCJsb2Fuc1N1YnNjcmlwdGlvbiIsInRyaXBzU3Vic2NyaXB0aW9uIiwidGFza3NTdWJzY3JpcHRpb24iLCJpbmNpZGVudHNTdWJzY3JpcHRpb24iLCJ1bnN1YnNjcmliZSIsImFkZENyZXciLCJyZXF1aXJlZEZpZWxkcyIsIm1pc3NpbmdGaWVsZHMiLCJmaWVsZCIsImpvaW4iLCJleGlzdGluZ0NyZXciLCJjaGVja0Vycm9yIiwibmF0aW9uYWxpdHkiLCJoaW50IiwidXBkYXRlQ3JldyIsInVwZGF0ZXMiLCJkZWxldGVDcmV3IiwiZGVsZXRlIiwiYWRkU2hpcCIsInNoaXBEYXRhIiwidXBkYXRlU2hpcCIsImRlbGV0ZVNoaXAiLCJhZGRTaWNrTGVhdmUiLCJ1bmRlZmluZWQiLCJ1cGRhdGVTaWNrTGVhdmUiLCJhZGRTdGFuZEJhY2tSZWNvcmQiLCJyZWNvcmREYXRhIiwidXVpZCIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJkYXRhV2l0aG91dElkIiwiZGF0YVRvSW5zZXJ0IiwiY3Jld19tZW1iZXJfaWQiLCJzdGFydF9kYXRlIiwiZW5kX2RhdGUiLCJkYXlzX2NvdW50IiwiZGVzY3JpcHRpb24iLCJzdGFuZF9iYWNrX2RheXNfcmVxdWlyZWQiLCJzdGFuZF9iYWNrX2RheXNfY29tcGxldGVkIiwic3RhbmRfYmFja19kYXlzX3JlbWFpbmluZyIsInN0YW5kX2JhY2tfc3RhdHVzIiwic3RhbmRfYmFja19oaXN0b3J5IiwicmVhc29uIiwidXBkYXRlU3RhbmRCYWNrUmVjb3JkIiwiYWRkTG9hbiIsImxvYW5EYXRhIiwiY29tcGxldGVMb2FuIiwibG9hbklkIiwiY29tcGxldGVkX2F0IiwibWFrZVBheW1lbnQiLCJwYXltZW50QW1vdW50IiwibG9hbiIsIm5ld1BhaWQiLCJhbW91bnRfcGFpZCIsIm5ld1JlbWFpbmluZyIsImFtb3VudCIsIm5ld1N0YXR1cyIsInBheW1lbnRFbnRyeSIsInBhaWRCeSIsImFtb3VudF9yZW1haW5pbmciLCJwYXltZW50X2hpc3RvcnkiLCJhZGRUcmlwIiwidHJpcERhdGEiLCJ1cGRhdGVUcmlwIiwidHJpcElkIiwidXBkYXRlZF9hdCIsImFkZFZhc3RlRGllbnN0UmVjb3JkIiwidXBkYXRlVmFzdGVEaWVuc3RSZWNvcmQiLCJkZWxldGVWYXN0ZURpZW5zdFJlY29yZCIsImRlbGV0ZVRyaXAiLCJkZWxldGVBZmxvc3NlciIsImFmbG9zc2VySWQiLCJhZGROb3RlVG9DcmV3IiwiY3Jld0lkIiwiY3VycmVudE5vdGVzIiwiYWN0aXZlX25vdGVzIiwibmV3Tm90ZSIsIm5vdyIsInRvU3RyaW5nIiwiY29udGVudCIsImNyZWF0ZWRBdCIsImNyZWF0ZWRCeSIsInVwZGF0ZWROb3RlcyIsInJlbW92ZU5vdGVGcm9tQ3JldyIsIm5vdGVJZCIsImN1cnJlbnRBY3RpdmVOb3RlcyIsImN1cnJlbnRBcmNoaXZlZE5vdGVzIiwiYXJjaGl2ZWRfbm90ZXMiLCJub3RlVG9BcmNoaXZlIiwidXBkYXRlZEFjdGl2ZU5vdGVzIiwiYXJjaGl2ZWROb3RlIiwiYXJjaGl2ZWRBdCIsInVwZGF0ZWRBcmNoaXZlZE5vdGVzIiwiYWRkVGFzayIsInRhc2tEYXRhIiwiZGV0YWlscyIsInVwZGF0ZVRhc2siLCJ0YXNrSWQiLCJkZWxldGVUYXNrIiwiY29tcGxldGVUYXNrIiwiY29tcGxldGVkIiwicmVsYXRlZF9zaGlwX3Zpc2l0X2lkIiwidmlzaXRFcnJvciIsImZvbGxvd191cF9uZWVkZWQiLCJmb2xsb3dfdXBfbm90ZXMiLCJpbm5lckVyciIsImFkZEluY2lkZW50IiwiaW5jaWRlbnREYXRhIiwidXBkYXRlSW5jaWRlbnQiLCJpbmNpZGVudElkIiwiZGVsZXRlSW5jaWRlbnQiLCJzZXRDcmV3Q29sb3JUYWciLCJ1cHNlcnRFcnJvciIsInVwc2VydCIsIm9uQ29uZmxpY3QiLCJkZWxFcnJvciIsInByZXYiLCJuZXh0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/use-supabase-data.ts\n"));

/***/ })

});