"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/schepen/bezoeken/page",{

/***/ "(app-pages-browser)/./hooks/use-supabase-data.ts":
/*!************************************!*\
  !*** ./hooks/use-supabase-data.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateWorkDays: () => (/* binding */ calculateWorkDays),\n/* harmony export */   calculateWorkDaysVasteDienst: () => (/* binding */ calculateWorkDaysVasteDienst),\n/* harmony export */   useSupabaseData: () => (/* binding */ useSupabaseData)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n\n\n// Function to calculate work days for vaste dienst aflossers based on hours\n// Uses 12-hour increments: 0-12h = 0.5 day, 12-24h = 1.0 day, etc.\nfunction calculateWorkDaysVasteDienst(startDate, startTime, endDate, endTime) {\n    if (!startDate || !endDate || !startTime || !endTime) return 0;\n    // Parse both DD-MM-YYYY and ISO format dates\n    const parseDate = (dateStr)=>{\n        if (!dateStr || typeof dateStr !== 'string') {\n            console.error('Invalid date string:', dateStr);\n            return new Date() // Return current date as fallback\n            ;\n        }\n        // Check if it's already an ISO date (contains T or has 4-digit year at start)\n        if (dateStr.includes('T') || /^\\d{4}-\\d{2}-\\d{2}/.test(dateStr)) {\n            // It's already an ISO date, use it directly\n            const date = new Date(dateStr);\n            if (isNaN(date.getTime())) {\n                console.error('Invalid ISO date:', dateStr);\n                return new Date() // Return current date as fallback\n                ;\n            }\n            return date;\n        }\n        // Otherwise, parse as DD-MM-YYYY format\n        const parts = dateStr.split('-');\n        if (parts.length !== 3) {\n            console.error('Invalid date format:', dateStr);\n            return new Date() // Return current date as fallback\n            ;\n        }\n        const day = parseInt(parts[0], 10);\n        const month = parseInt(parts[1], 10) - 1 // JavaScript months are 0-based\n        ;\n        const year = parseInt(parts[2], 10);\n        const date = new Date(year, month, day);\n        if (isNaN(date.getTime())) {\n            console.error('Invalid parsed date:', dateStr);\n            return new Date() // Return current date as fallback\n            ;\n        }\n        return date;\n    };\n    // Parse time string (HH:MM:SS or HH:MM format)\n    const parseTime = (timeStr)=>{\n        if (!timeStr || typeof timeStr !== 'string') {\n            console.error('Invalid time string:', timeStr);\n            return 0;\n        }\n        const timeParts = timeStr.split(':');\n        if (timeParts.length < 2) {\n            console.error('Invalid time format:', timeStr);\n            return 0;\n        }\n        const hours = parseInt(timeParts[0], 10);\n        const minutes = parseInt(timeParts[1], 10);\n        if (isNaN(hours) || isNaN(minutes)) {\n            console.error('Invalid time values:', timeStr);\n            return 0;\n        }\n        return hours + minutes / 60;\n    };\n    const start = parseDate(startDate);\n    const end = parseDate(endDate);\n    const startTimeHours = parseTime(startTime);\n    const endTimeHours = parseTime(endTime);\n    if (end < start) {\n        console.error('Error: end date is before start date');\n        return 0;\n    }\n    // Create full datetime objects\n    const startDateTime = new Date(start);\n    startDateTime.setHours(Math.floor(startTimeHours), startTimeHours % 1 * 60, 0, 0);\n    const endDateTime = new Date(end);\n    endDateTime.setHours(Math.floor(endTimeHours), endTimeHours % 1 * 60, 0, 0);\n    // Calculate duration in hours\n    const timeDiffMs = endDateTime.getTime() - startDateTime.getTime();\n    const totalHours = timeDiffMs / (1000 * 60 * 60);\n    // Convert to day credits using 12-hour increments\n    // Formula: credits = ceil(hours / 12) * 0.5\n    const dayCredits = Math.ceil(totalHours / 12) * 0.5;\n    return dayCredits;\n}\n// Functie om automatisch crew members te activeren op hun startdatum\nasync function autoActivateCrewMembers(crewData) {\n    const today = new Date();\n    today.setHours(0, 0, 0, 0) // Reset naar start van de dag\n    ;\n    for (const member of crewData){\n        // Check of deze persoon moet worden geactiveerd\n        // Status kan \"thuis\" zijn (wachtend op startdatum) of \"nog-in-te-delen\"\n        if ((member.status === 'thuis' || member.status === 'nog-in-te-delen') && member.expected_start_date && member.ship_id && member.regime) {\n            const startDate = new Date(member.expected_start_date);\n            startDate.setHours(0, 0, 0, 0);\n            // Is vandaag >= startdatum?\n            if (today >= startDate) {\n                console.log(\"\\uD83D\\uDE80 Auto-activating \".concat(member.first_name, \" \").concat(member.last_name, \" - Start date reached!\"));\n                try {\n                    // Update naar \"aan-boord\" status\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').update({\n                        status: 'aan-boord',\n                        on_board_since: member.expected_start_date,\n                        thuis_sinds: null,\n                        expected_start_date: null,\n                        sub_status: null // Clear sub_status\n                    }).eq('id', member.id);\n                    if (error) {\n                        console.error('Error auto-activating crew member:', error);\n                    } else {\n                        console.log(\"âœ… \".concat(member.first_name, \" \").concat(member.last_name, \" is now active!\"));\n                    }\n                } catch (err) {\n                    console.error('Error in auto-activation:', err);\n                }\n            }\n        }\n    }\n}\n// Functie om automatisch rotaties uit te voeren\nasync function autoRotateCrewMembers(crewData) {\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    for (const member of crewData){\n        // Skip als geen regime, ziek, of \"Altijd\"\n        if (!member.regime || member.status === 'ziek' || member.regime === 'Altijd') {\n            continue;\n        }\n        const regimeWeeks = parseInt(member.regime.split('/')[0]);\n        const regimeDays = regimeWeeks * 7;\n        // Check of iemand van aan-boord naar thuis moet\n        if (member.status === 'aan-boord' && member.on_board_since) {\n            const onBoardDate = new Date(member.on_board_since);\n            onBoardDate.setHours(0, 0, 0, 0);\n            const daysSinceOnBoard = Math.floor((today.getTime() - onBoardDate.getTime()) / (1000 * 60 * 60 * 24));\n            if (daysSinceOnBoard >= regimeDays) {\n                const thuisSinds = new Date(onBoardDate);\n                thuisSinds.setDate(thuisSinds.getDate() + regimeDays);\n                console.log(\"\\uD83D\\uDD04 Auto-rotating \".concat(member.first_name, \" \").concat(member.last_name, \" to THUIS\"));\n                try {\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').update({\n                        status: 'thuis',\n                        thuis_sinds: thuisSinds.toISOString().split('T')[0],\n                        on_board_since: null\n                    }).eq('id', member.id);\n                    if (error) {\n                        console.error('Error rotating to thuis:', error);\n                    } else {\n                        console.log(\"âœ… \".concat(member.first_name, \" is now thuis\"));\n                    }\n                } catch (err) {\n                    console.error('Error in rotation:', err);\n                }\n            }\n        }\n        // Check of iemand van thuis naar aan-boord moet\n        if (member.status === 'thuis' && member.thuis_sinds) {\n            const thuisDate = new Date(member.thuis_sinds);\n            thuisDate.setHours(0, 0, 0, 0);\n            const daysSinceThuis = Math.floor((today.getTime() - thuisDate.getTime()) / (1000 * 60 * 60 * 24));\n            if (daysSinceThuis >= regimeDays) {\n                const onBoardSince = new Date(thuisDate);\n                onBoardSince.setDate(onBoardSince.getDate() + regimeDays);\n                console.log(\"\\uD83D\\uDD04 Auto-rotating \".concat(member.first_name, \" \").concat(member.last_name, \" to AAN-BOORD\"));\n                try {\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').update({\n                        status: 'aan-boord',\n                        on_board_since: onBoardSince.toISOString().split('T')[0],\n                        thuis_sinds: null\n                    }).eq('id', member.id);\n                    if (error) {\n                        console.error('Error rotating to aan-boord:', error);\n                    } else {\n                        console.log(\"âœ… \".concat(member.first_name, \" is now aan-boord\"));\n                    }\n                } catch (err) {\n                    console.error('Error in rotation:', err);\n                }\n            }\n        }\n    }\n}\n// Functie om automatisch vaste dienst records te beheren\nasync function autoManageVasteDienstRecords(crewData, vasteDienstRecords, tripsData) {\n    const today = new Date();\n    const currentYear = today.getFullYear();\n    const currentMonth = today.getMonth() + 1 // JavaScript months are 0-based\n    ;\n    console.log(\"\\uD83D\\uDD27 Auto-managing vaste dienst records for \".concat(currentYear, \"-\").concat(currentMonth));\n    // Get all aflossers in vaste dienst\n    const vasteDienstAflossers = crewData.filter((member)=>member.vaste_dienst === true);\n    for (const aflosser of vasteDienstAflossers){\n        console.log(\"\\uD83D\\uDCCB Processing vaste dienst aflosser: \".concat(aflosser.first_name, \" \").concat(aflosser.last_name));\n        // Check if current month record exists\n        const existingRecord = vasteDienstRecords.find((record)=>record.aflosser_id === aflosser.id && record.year === currentYear && record.month === currentMonth);\n        if (!existingRecord) {\n            // Create new monthly record\n            console.log(\"\\uD83D\\uDCC5 Creating new monthly record for \".concat(aflosser.first_name, \" \").concat(aflosser.last_name));\n            try {\n                const newRecord = {\n                    aflosser_id: aflosser.id,\n                    year: currentYear,\n                    month: currentMonth,\n                    required_days: 15,\n                    actual_days: 0,\n                    balance_days: 0,\n                    notes: \"Automatisch aangemaakt voor \".concat(currentYear, \"-\").concat(currentMonth)\n                };\n                const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').insert([\n                    newRecord\n                ]).select().single();\n                if (error) {\n                    console.error('Error creating vaste dienst record:', error);\n                } else {\n                    console.log(\"âœ… Created monthly record for \".concat(aflosser.first_name));\n                }\n            } catch (err) {\n                console.error('Error in vaste dienst record creation:', err);\n            }\n        }\n        // Calculate actual days from completed trips for current month\n        const currentMonthTrips = tripsData.filter((trip)=>trip.aflosser_id === aflosser.id && trip.status === 'voltooid' && trip.eind_datum && new Date(trip.eind_datum).getFullYear() === currentYear && new Date(trip.eind_datum).getMonth() + 1 === currentMonth);\n        let totalWorkDays = 0;\n        for (const trip of currentMonthTrips){\n            const workDays = calculateWorkDays(trip.start_datum, trip.start_tijd, trip.eind_datum, trip.eind_tijd);\n            totalWorkDays += workDays;\n        }\n        // Update the record with actual days and balance\n        if (existingRecord) {\n            const requiredDays = 15;\n            // CORRECTE BEREKENING: Eindsaldo = Beginsaldo + (Gewerkt - 15)\n            // Voor eerste maand: Beginsaldo = -15 + startsaldo\n            let beginsaldo = existingRecord.balance_days || 0;\n            // Als dit de eerste maand is en er is geen beginsaldo, gebruik -15 + startsaldo\n            if (beginsaldo === 0 && currentMonth === 1) {\n                var _aflosser_notes;\n                // Probeer startsaldo uit notes te halen\n                const startsaldoNote = (_aflosser_notes = aflosser.notes) === null || _aflosser_notes === void 0 ? void 0 : _aflosser_notes.find((note)=>note.text && (note.text.includes('startsaldo') || note.text.includes('Startsaldo')));\n                if (startsaldoNote) {\n                    const match = startsaldoNote.text.match(/(-?\\d+(?:\\.\\d+)?)/);\n                    if (match) {\n                        const startsaldo = parseFloat(match[1]);\n                        beginsaldo = -15 + startsaldo;\n                        console.log(\"\\uD83D\\uDCCA Eerste maand: startsaldo \".concat(startsaldo, \", beginsaldo \").concat(beginsaldo));\n                    }\n                }\n                if (beginsaldo === 0) beginsaldo = -15 // Fallback\n                ;\n            }\n            // Voor de eerste maand: toon het beginsaldo als huidig saldo\n            // Voor volgende maanden: bereken het eindsaldo\n            let balanceDays;\n            if (currentMonth === 1 && beginsaldo !== -15) {\n                // Eerste maand met startsaldo: toon beginsaldo\n                balanceDays = beginsaldo;\n            } else {\n                // Normale berekening: beginsaldo + (gewerkt - 15)\n                balanceDays = beginsaldo + (totalWorkDays - requiredDays);\n            }\n            // Cap values to fit in DECIMAL(4,1) - max 999.9\n            const cappedActualDays = Math.min(totalWorkDays, 999.9);\n            const cappedBalanceDays = Math.min(Math.max(balanceDays, -999.9), 999.9);\n            if (existingRecord.actual_days !== cappedActualDays || existingRecord.balance_days !== cappedBalanceDays) {\n                console.log(\"\\uD83D\\uDCCA Updating record for \".concat(aflosser.first_name, \": \").concat(cappedActualDays, \" days (balance: \").concat(cappedBalanceDays, \")\"));\n                try {\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').update({\n                        actual_days: cappedActualDays,\n                        balance_days: cappedBalanceDays\n                    }).eq('id', existingRecord.id);\n                    if (error) {\n                        console.error('âŒ Error updating vaste dienst record:', error);\n                        console.error('âŒ Error details:', JSON.stringify(error, null, 2));\n                        console.error('âŒ Record data:', {\n                            id: existingRecord.id,\n                            actual_days: totalWorkDays,\n                            balance_days: balanceDays\n                        });\n                    } else {\n                        console.log(\"âœ… Updated record for \".concat(aflosser.first_name));\n                    }\n                } catch (err) {\n                    console.error('Error updating vaste dienst record:', err);\n                }\n            }\n        }\n    }\n}\n// Helper function to calculate work days from trip data\nfunction calculateWorkDays(startDate, startTime, endDate, endTime) {\n    if (!startDate || !endDate) return 0;\n    // Parse both DD-MM-YYYY and ISO format dates\n    const parseDate = (dateStr)=>{\n        if (!dateStr || typeof dateStr !== 'string') {\n            console.error('Invalid date string:', dateStr);\n            return new Date() // Return current date as fallback\n            ;\n        }\n        // Check if it's already an ISO date (contains T or has 4-digit year at start)\n        if (dateStr.includes('T') || /^\\d{4}-\\d{2}-\\d{2}/.test(dateStr)) {\n            // It's already an ISO date, use it directly\n            const date = new Date(dateStr);\n            if (isNaN(date.getTime())) {\n                console.error('Invalid ISO date:', dateStr);\n                return new Date() // Return current date as fallback\n                ;\n            }\n            return date;\n        }\n        // Otherwise, parse as DD-MM-YYYY format\n        const parts = dateStr.split('-');\n        if (parts.length !== 3) {\n            console.error('Invalid date format:', dateStr);\n            return new Date() // Return current date as fallback\n            ;\n        }\n        const [day, month, year] = parts;\n        const isoDate = \"\".concat(year, \"-\").concat(month.padStart(2, '0'), \"-\").concat(day.padStart(2, '0'));\n        const date = new Date(isoDate);\n        if (isNaN(date.getTime())) {\n            console.error('Invalid date after parsing:', isoDate, 'from:', dateStr);\n            return new Date() // Return current date as fallback\n            ;\n        }\n        return date;\n    };\n    const start = parseDate(startDate);\n    const end = parseDate(endDate);\n    // Validatie: afstapdatum mag niet voor instapdatum liggen\n    if (end < start) {\n        console.error('Error: end date is before start date');\n        return 0;\n    }\n    // Simpele telling: tel kalenderdagen van start tot eind (inclusief beide)\n    const timeDiff = end.getTime() - start.getTime();\n    const daysDiff = Math.ceil(timeDiff / (1000 * 60 * 60 * 24)) + 1 // +1 omdat we beide datums inclusief tellen\n    ;\n    return daysDiff;\n}\n// Function to auto-update vaste dienst records when a trip is completed\nasync function autoUpdateVasteDienstFromTrip(completedTrip) {\n    try {\n        var _aflosser_notes;\n        console.log(\"\\uD83D\\uDD04 Auto-updating vaste dienst for completed trip: \".concat(completedTrip.id));\n        console.log(\"\\uD83D\\uDD04 Trip data:\", completedTrip);\n        // Get the aflosser\n        const { data: aflosser, error: aflosserError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').select('*').eq('id', completedTrip.aflosser_id).single();\n        if (aflosserError || !aflosser) {\n            console.error('Error fetching aflosser:', aflosserError);\n            return;\n        }\n        // Check if aflosser is in vaste dienst\n        if (!aflosser.vaste_dienst) {\n            console.log('Aflosser is not in vaste dienst, skipping auto-update');\n            return;\n        }\n        // Get the month/year of the trip completion\n        // Parse the date using our safe parseDate function\n        const parseDate = (dateStr)=>{\n            if (!dateStr || typeof dateStr !== 'string') {\n                console.error('Invalid date string:', dateStr);\n                return new Date();\n            }\n            // Check if it's already an ISO date (contains T or has 4-digit year at start)\n            if (dateStr.includes('T') || /^\\d{4}-\\d{2}-\\d{2}/.test(dateStr)) {\n                // It's already an ISO date, use it directly\n                const date = new Date(dateStr);\n                if (isNaN(date.getTime())) {\n                    console.error('Invalid ISO date:', dateStr);\n                    return new Date();\n                }\n                return date;\n            }\n            // Otherwise, parse as DD-MM-YYYY format\n            const parts = dateStr.split('-');\n            if (parts.length !== 3) {\n                console.error('Invalid date format:', dateStr);\n                return new Date();\n            }\n            const [day, month, year] = parts;\n            const isoDate = \"\".concat(year, \"-\").concat(month.padStart(2, '0'), \"-\").concat(day.padStart(2, '0'));\n            const date = new Date(isoDate);\n            if (isNaN(date.getTime())) {\n                console.error('Invalid date after parsing:', isoDate, 'from:', dateStr);\n                return new Date();\n            }\n            return date;\n        };\n        const endDate = parseDate(completedTrip.eind_datum);\n        const year = endDate.getFullYear();\n        const month = endDate.getMonth() + 1;\n        // Check if monthly record exists\n        const { data: existingRecord, error: recordError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').select('*').eq('aflosser_id', completedTrip.aflosser_id).eq('year', year).eq('month', month).single();\n        if (recordError && recordError.code !== 'PGRST116') {\n            console.error('Error fetching vaste dienst record:', recordError);\n            return;\n        }\n        let recordId = existingRecord === null || existingRecord === void 0 ? void 0 : existingRecord.id;\n        // Create record if it doesn't exist\n        if (!existingRecord) {\n            console.log(\"\\uD83D\\uDCC5 Creating new monthly record for \".concat(aflosser.first_name, \" \").concat(aflosser.last_name));\n            const newRecord = {\n                aflosser_id: completedTrip.aflosser_id,\n                year: year,\n                month: month,\n                required_days: 15,\n                actual_days: 0,\n                balance_days: 0,\n                notes: \"Automatisch aangemaakt voor \".concat(year, \"-\").concat(month)\n            };\n            const { data: createdRecord, error: createError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').insert([\n                newRecord\n            ]).select().single();\n            if (createError) {\n                console.error('Error creating vaste dienst record:', createError);\n                return;\n            }\n            recordId = createdRecord.id;\n        }\n        // Calculate work days for this trip\n        const workDays = calculateWorkDays(completedTrip.start_datum, completedTrip.start_tijd, completedTrip.eind_datum, completedTrip.eind_tijd);\n        // Get all completed trips for this month to calculate total\n        const { data: allTrips, error: tripsError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('trips').select('*').eq('aflosser_id', completedTrip.aflosser_id).eq('status', 'voltooid').not('eind_datum', 'is', null);\n        if (tripsError) {\n            console.error('Error fetching trips:', tripsError);\n            return;\n        }\n        // Calculate total work days for the month\n        let totalWorkDays = 0;\n        for (const trip of allTrips || []){\n            const tripEndDate = parseDate(trip.eind_datum);\n            if (tripEndDate.getFullYear() === year && tripEndDate.getMonth() + 1 === month) {\n                const tripWorkDays = calculateWorkDays(trip.start_datum, trip.start_tijd, trip.eind_datum, trip.eind_tijd);\n                totalWorkDays += tripWorkDays;\n            }\n        }\n        // Update the record\n        const requiredDays = 15;\n        // CORRECTE BEREKENING: Eindsaldo = Beginsaldo + (Gewerkt - 15)\n        // Voor eerste maand: Beginsaldo = -15 + startsaldo\n        let beginsaldo = 0;\n        // Probeer startsaldo uit notes te halen voor nieuwe aflossers\n        const startsaldoNote = (_aflosser_notes = aflosser.notes) === null || _aflosser_notes === void 0 ? void 0 : _aflosser_notes.find((note)=>note.text && (note.text.includes('startsaldo') || note.text.includes('Startsaldo')));\n        if (startsaldoNote) {\n            const match = startsaldoNote.text.match(/(-?\\d+(?:\\.\\d+)?)/);\n            if (match) {\n                const startsaldo = parseFloat(match[1]);\n                beginsaldo = -15 + startsaldo;\n                console.log(\"\\uD83D\\uDCCA Nieuwe aflosser: startsaldo \".concat(startsaldo, \", beginsaldo \").concat(beginsaldo));\n            }\n        }\n        if (beginsaldo === 0) beginsaldo = -15 // Fallback\n        ;\n        // Voor de eerste maand: toon het beginsaldo als huidig saldo\n        // Voor volgende maanden: bereken het eindsaldo\n        let balanceDays;\n        if (month === 1 && beginsaldo !== -15) {\n            // Eerste maand met startsaldo: toon beginsaldo\n            balanceDays = beginsaldo;\n        } else {\n            // Normale berekening: beginsaldo + (gewerkt - 15)\n            balanceDays = beginsaldo + (totalWorkDays - requiredDays);\n        }\n        // Cap values to fit in DECIMAL(4,1) - max 999.9\n        const cappedActualDays = Math.min(totalWorkDays, 999.9);\n        const cappedBalanceDays = Math.min(Math.max(balanceDays, -999.9), 999.9);\n        const { error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').update({\n            actual_days: cappedActualDays,\n            balance_days: cappedBalanceDays\n        }).eq('id', recordId);\n        if (updateError) {\n            console.error('âŒ Error updating vaste dienst record:', updateError);\n            console.error('âŒ Error details:', JSON.stringify(updateError, null, 2));\n            console.error('âŒ Record data:', {\n                id: recordId,\n                actual_days: totalWorkDays,\n                balance_days: balanceDays\n            });\n        } else {\n            console.log(\"âœ… Updated vaste dienst record for \".concat(aflosser.first_name, \": \").concat(totalWorkDays, \" days (balance: \").concat(balanceDays, \")\"));\n        }\n    } catch (err) {\n        console.error('Error in auto-update vaste dienst:', err);\n    }\n}\n// Function to force recalculate all vaste dienst records with new logic\nasync function forceRecalculateAllVasteDienstRecords(crewData, tripsData) {\n    try {\n        console.log('ðŸ”„ Force recalculating all vaste dienst records...');\n        console.log(\"\\uD83D\\uDCCA Crew data: \".concat(crewData.length, \" members\"));\n        console.log(\"\\uD83D\\uDCCA Trips data: \".concat(tripsData.length, \" trips\"));\n        // Get all vaste dienst records\n        const { data: allRecords, error: fetchError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').select('*');\n        if (fetchError) {\n            console.error('âŒ Error fetching vaste dienst records:', fetchError);\n            return;\n        }\n        if (!allRecords || allRecords.length === 0) {\n            console.log('âš ï¸ No vaste dienst records found to recalculate');\n            return;\n        }\n        console.log(\"\\uD83D\\uDCCB Found \".concat(allRecords.length, \" records to recalculate\"));\n        // Process each record\n        for (const record of allRecords){\n            try {\n                console.log(\"\\n\\uD83D\\uDD0D Processing record \".concat(record.id, \" for aflosser \").concat(record.aflosser_id));\n                // Find the aflosser\n                const aflosser = crewData.find((crew)=>crew.id === record.aflosser_id);\n                if (!aflosser) {\n                    console.log(\"âš ï¸ Aflosser not found for record \".concat(record.id));\n                    continue;\n                }\n                console.log(\"\\uD83D\\uDC64 Found aflosser: \".concat(aflosser.first_name, \" \").concat(aflosser.last_name));\n                // Get all completed trips for this aflosser\n                const allTrips = tripsData.filter((trip)=>trip.aflosser_id === record.aflosser_id && trip.status === 'voltooid' && trip.start_datum && trip.eind_datum && trip.start_tijd && trip.eind_tijd);\n                console.log(\"\\uD83D\\uDEA2 Found \".concat(allTrips.length, \" completed trips for this aflosser\"));\n                // Calculate total work days with new logic\n                let totalWorkDays = 0;\n                for (const trip of allTrips){\n                    const workDays = calculateWorkDays(trip.start_datum, trip.start_tijd, trip.eind_datum, trip.eind_tijd);\n                    console.log(\"  \\uD83D\\uDCC5 Trip \".concat(trip.id, \": \").concat(trip.start_datum, \" to \").concat(trip.eind_datum, \" = \").concat(workDays, \" days\"));\n                    totalWorkDays += workDays;\n                }\n                console.log(\"\\uD83D\\uDCCA Total work days calculated: \".concat(totalWorkDays));\n                // Cap values to fit in DECIMAL(4,1)\n                const requiredDays = 15;\n                // CORRECTE BEREKENING: Eindsaldo = Beginsaldo + (Gewerkt - 15)\n                // Voor eerste maand: Beginsaldo = -15 + startsaldo\n                let beginsaldo = record.balance_days || 0;\n                // Als dit de eerste maand is en er is geen beginsaldo, gebruik -15 + startsaldo\n                if (beginsaldo === 0 && record.month === 1) {\n                    var _aflosser_notes;\n                    // Probeer startsaldo uit notes te halen\n                    const startsaldoNote = (_aflosser_notes = aflosser.notes) === null || _aflosser_notes === void 0 ? void 0 : _aflosser_notes.find((note)=>note.text && (note.text.includes('startsaldo') || note.text.includes('Startsaldo')));\n                    if (startsaldoNote) {\n                        const match = startsaldoNote.text.match(/(-?\\d+(?:\\.\\d+)?)/);\n                        if (match) {\n                            const startsaldo = parseFloat(match[1]);\n                            beginsaldo = -15 + startsaldo;\n                            console.log(\"\\uD83D\\uDCCA Eerste maand herberekening: startsaldo \".concat(startsaldo, \", beginsaldo \").concat(beginsaldo));\n                        }\n                    }\n                    if (beginsaldo === 0) beginsaldo = -15 // Fallback\n                    ;\n                }\n                // Voor de eerste maand: toon het beginsaldo als huidig saldo\n                // Voor volgende maanden: bereken het eindsaldo\n                let balanceDays;\n                if (record.month === 1 && beginsaldo !== -15) {\n                    // Eerste maand met startsaldo: toon beginsaldo\n                    balanceDays = beginsaldo;\n                } else {\n                    // Normale berekening: beginsaldo + (gewerkt - 15)\n                    balanceDays = beginsaldo + (totalWorkDays - requiredDays);\n                }\n                const cappedActualDays = Math.min(totalWorkDays, 999.9);\n                const cappedBalanceDays = Math.min(Math.max(balanceDays, -999.9), 999.9);\n                console.log(\"\\uD83D\\uDCBE Updating record: actual=\".concat(cappedActualDays, \", balance=\").concat(cappedBalanceDays));\n                // Update the record\n                const { error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').update({\n                    actual_days: cappedActualDays,\n                    balance_days: cappedBalanceDays\n                }).eq('id', record.id);\n                if (updateError) {\n                    console.error(\"âŒ Error updating record \".concat(record.id, \":\"), updateError);\n                } else {\n                    console.log(\"âœ… Successfully updated record for \".concat(aflosser.first_name, \": \").concat(cappedActualDays, \" days (balance: \").concat(cappedBalanceDays, \")\"));\n                }\n            } catch (err) {\n                console.error(\"âŒ Error processing record \".concat(record.id, \":\"), err);\n            }\n        }\n        console.log('ðŸŽ‰ Force recalculation completed!');\n    } catch (err) {\n        console.error('âŒ Error in force recalculate:', err);\n    }\n}\n// Function to reset all vaste dienst records to 0\nasync function resetAllVasteDienstRecords() {\n    try {\n        console.log('ðŸ§¹ Resetting all vaste dienst records to 0...');\n        // Get all vaste dienst records\n        const { data: allRecords, error: fetchError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').select('*');\n        if (fetchError) {\n            console.error('Error fetching vaste dienst records for reset:', fetchError);\n            return;\n        }\n        if (!allRecords || allRecords.length === 0) {\n            console.log('No vaste dienst records found to reset');\n            return;\n        }\n        console.log(\"Found \".concat(allRecords.length, \" records to reset\"));\n        // Reset each record to 0\n        for (const record of allRecords){\n            try {\n                const { error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').update({\n                    actual_days: 0,\n                    balance_days: -15 // -15 because required_days is 15\n                }).eq('id', record.id);\n                if (updateError) {\n                    console.error(\"âŒ Error resetting record \".concat(record.id, \":\"), updateError);\n                } else {\n                    console.log(\"âœ… Reset record \".concat(record.id, \" to 0\"));\n                }\n            } catch (err) {\n                console.error(\"Error resetting record \".concat(record.id, \":\"), err);\n            }\n        }\n        console.log('ðŸŽ‰ Reset completed!');\n    } catch (err) {\n        console.error('Error in reset all records:', err);\n    }\n}\nfunction useSupabaseData() {\n    const [ships, setShips] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [crew, setCrew] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [sickLeave, setSickLeave] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [standBackRecords, setStandBackRecords] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loans, setLoans] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [trips, setTrips] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [vasteDienstRecords, setVasteDienstRecords] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [tasks, setTasks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [crewColorTags, setCrewColorTags] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    // Load all data from Supabase\n    const loadData = async ()=>{\n        try {\n            setLoading(true);\n            setError(null);\n            console.log('Loading data from Supabase...');\n            // Check if user is authenticated\n            const { data: { session } } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.auth.getSession();\n            console.log('Current session:', session ? 'User logged in' : 'No user session');\n            if (!session) {\n                console.warn('No active session - user needs to login');\n                setShips([]);\n                setCrew([]);\n                setSickLeave([]);\n                setStandBackRecords([]);\n                setLoans([]);\n                setTrips([]);\n                setVasteDienstRecords([]);\n                setTasks([]);\n                setLoading(false);\n                return;\n            }\n            // Test Supabase connection\n            console.log('Testing Supabase connection...');\n            const { data: testData, error: testError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('sick_leave').select('id').limit(1);\n            if (testError) {\n                console.error('Supabase connection test failed:', testError);\n                console.error('Test error details:', JSON.stringify(testError, null, 2));\n            } else {\n                console.log('âœ… Supabase connection test successful');\n            }\n            // Load ships\n            console.log('Loading ships...');\n            const { data: shipsData, error: shipsError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('ships').select('*').order('name');\n            if (shipsError) {\n                console.error('Error loading ships:', shipsError);\n                console.error('Ships error details:', JSON.stringify(shipsError, null, 2));\n            } else {\n                console.log('Ships loaded:', (shipsData === null || shipsData === void 0 ? void 0 : shipsData.length) || 0);\n                setShips(shipsData || []);\n            }\n            // Load crew\n            console.log('Loading crew...');\n            const { data: crewData, error: crewError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').select('*').order('first_name');\n            if (crewError) {\n                console.error('Error loading crew:', crewError);\n                console.error('Crew error details:', JSON.stringify(crewError, null, 2));\n            } else {\n                console.log('Crew loaded:', (crewData === null || crewData === void 0 ? void 0 : crewData.length) || 0);\n                // Temporarily disable auto-activation and rotation to prevent infinite loops\n                // await autoActivateCrewMembers(crewData || [])\n                // await autoRotateCrewMembers(crewData || [])\n                // Set crew data directly without reloading\n                setCrew(crewData || []);\n            }\n            // Load sick leave\n            console.log('Loading sick leave...');\n            const { data: sickLeaveData, error: sickLeaveError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('sick_leave').select('*').order('start_date', {\n                ascending: false\n            });\n            if (sickLeaveError) {\n                console.error('Error loading sick leave:', sickLeaveError);\n            } else {\n                console.log('Sick leave loaded:', (sickLeaveData === null || sickLeaveData === void 0 ? void 0 : sickLeaveData.length) || 0);\n                setSickLeave(sickLeaveData || []);\n            }\n            // Load stand back records\n            console.log('Loading stand back records...');\n            const { data: standBackData, error: standBackError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('stand_back_records').select('*').order('created_at', {\n                ascending: false\n            });\n            if (standBackError) {\n                console.error('Error loading stand back records:', standBackError);\n                setStandBackRecords([]);\n            } else {\n                console.log('Stand back records loaded:', (standBackData === null || standBackData === void 0 ? void 0 : standBackData.length) || 0);\n                setStandBackRecords(standBackData || []);\n            }\n            // Load loans\n            console.log('Loading loans...');\n            const { data: loansData, error: loansError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('loans').select('*').order('created_at', {\n                ascending: false\n            });\n            if (loansError) {\n                console.error('Error loading loans:', loansError);\n                setLoans([]);\n            } else {\n                console.log('Loans loaded:', (loansData === null || loansData === void 0 ? void 0 : loansData.length) || 0);\n                setLoans(loansData || []);\n            }\n            // Load trips\n            console.log('Loading trips...');\n            const { data: tripsData, error: tripsError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('trips').select('*').order('created_at', {\n                ascending: false\n            });\n            if (tripsError) {\n                console.error('Error loading trips:', tripsError);\n                setTrips([]);\n            } else {\n                console.log('Trips loaded:', (tripsData === null || tripsData === void 0 ? void 0 : tripsData.length) || 0);\n                setTrips(tripsData || []);\n            }\n            // Load vaste dienst records\n            console.log('Loading vaste dienst records...');\n            const { data: vasteDienstData, error: vasteDienstError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').select('*').order('year', {\n                ascending: false\n            }).order('month', {\n                ascending: false\n            });\n            if (vasteDienstError) {\n                console.error('Error loading vaste dienst records:', vasteDienstError);\n                setVasteDienstRecords([]);\n            } else {\n                console.log('Vaste dienst records loaded:', (vasteDienstData === null || vasteDienstData === void 0 ? void 0 : vasteDienstData.length) || 0);\n                setVasteDienstRecords(vasteDienstData || []);\n                // Auto-manage vaste dienst records after loading all data\n                console.log('ðŸ”§ Auto-managing vaste dienst records...');\n                await autoManageVasteDienstRecords(crewData || [], vasteDienstData || [], tripsData || []);\n            }\n            // Load tasks\n            console.log('Loading tasks...');\n            const { data: tasksData, error: tasksError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('tasks').select('*').order('created_at', {\n                ascending: false\n            });\n            if (tasksError) {\n                console.error('Error loading tasks:', tasksError);\n                setTasks([]);\n            } else {\n                console.log('Tasks loaded:', (tasksData === null || tasksData === void 0 ? void 0 : tasksData.length) || 0);\n                setTasks(tasksData || []);\n            }\n            console.log('Data loading completed!');\n            // Load crew color tags last, non-blocking for main data\n            try {\n                const { data: colorRows, error: colorErr } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew_color_tags').select('crew_id, color');\n                if (colorErr) {\n                    const msg = (colorErr === null || colorErr === void 0 ? void 0 : colorErr.message) || String(colorErr);\n                    console.warn('Skipping crew_color_tags (table missing or no access):', msg);\n                    setCrewColorTags({});\n                } else {\n                    const map = {};\n                    for (const row of colorRows || []){\n                        if (row.crew_id && row.color) map[row.crew_id] = row.color;\n                    }\n                    setCrewColorTags(map);\n                }\n            } catch (e) {\n                console.warn('Error loading crew_color_tags:', (e === null || e === void 0 ? void 0 : e.message) || e);\n                setCrewColorTags({});\n            }\n        } catch (err) {\n            console.error('Error in loadData:', err);\n            setError(err instanceof Error ? err.message : 'Unknown error');\n        } finally{\n            setLoading(false);\n        }\n    };\n    // Load data on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSupabaseData.useEffect\": ()=>{\n            loadData();\n        // Temporarily disable daily check to prevent infinite loops\n        // const dailyCheck = setInterval(() => {\n        //   console.log('Running daily auto-activation check...')\n        //   loadData() // Dit zal autoActivateCrewMembers aanroepen\n        // }, 24 * 60 * 60 * 1000) // 24 uur\n        // return () => clearInterval(dailyCheck)\n        }\n    }[\"useSupabaseData.useEffect\"], []);\n    // Subscribe to real-time changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSupabaseData.useEffect\": ()=>{\n            // Subscribe to ships changes\n            const shipsSubscription = _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.channel('ships-changes').on('postgres_changes', {\n                event: '*',\n                schema: 'public',\n                table: 'ships'\n            }, {\n                \"useSupabaseData.useEffect.shipsSubscription\": ()=>{\n                    loadData();\n                }\n            }[\"useSupabaseData.useEffect.shipsSubscription\"]).subscribe();\n            // Subscribe to crew changes\n            const crewSubscription = _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.channel('crew-changes').on('postgres_changes', {\n                event: '*',\n                schema: 'public',\n                table: 'crew'\n            }, {\n                \"useSupabaseData.useEffect.crewSubscription\": ()=>{\n                    loadData();\n                }\n            }[\"useSupabaseData.useEffect.crewSubscription\"]).subscribe();\n            // Subscribe to sick leave changes\n            const sickLeaveSubscription = _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.channel('sick-leave-changes').on('postgres_changes', {\n                event: '*',\n                schema: 'public',\n                table: 'sick_leave'\n            }, {\n                \"useSupabaseData.useEffect.sickLeaveSubscription\": ()=>{\n                    loadData();\n                }\n            }[\"useSupabaseData.useEffect.sickLeaveSubscription\"]).subscribe();\n            // Subscribe to stand back records changes\n            const standBackSubscription = _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.channel('stand-back-changes').on('postgres_changes', {\n                event: '*',\n                schema: 'public',\n                table: 'stand_back_records'\n            }, {\n                \"useSupabaseData.useEffect.standBackSubscription\": ()=>{\n                    loadData();\n                }\n            }[\"useSupabaseData.useEffect.standBackSubscription\"]).subscribe();\n            // Subscribe to loans changes\n            const loansSubscription = _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.channel('loans-changes').on('postgres_changes', {\n                event: '*',\n                schema: 'public',\n                table: 'loans'\n            }, {\n                \"useSupabaseData.useEffect.loansSubscription\": ()=>{\n                    loadData();\n                }\n            }[\"useSupabaseData.useEffect.loansSubscription\"]).subscribe();\n            // Subscribe to trips changes\n            const tripsSubscription = _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.channel('trips-changes').on('postgres_changes', {\n                event: '*',\n                schema: 'public',\n                table: 'trips'\n            }, {\n                \"useSupabaseData.useEffect.tripsSubscription\": ()=>{\n                    loadData();\n                }\n            }[\"useSupabaseData.useEffect.tripsSubscription\"]).subscribe();\n            // Subscribe to tasks changes\n            const tasksSubscription = _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.channel('tasks-changes').on('postgres_changes', {\n                event: '*',\n                schema: 'public',\n                table: 'tasks'\n            }, {\n                \"useSupabaseData.useEffect.tasksSubscription\": ()=>{\n                    loadData();\n                }\n            }[\"useSupabaseData.useEffect.tasksSubscription\"]).subscribe();\n            return ({\n                \"useSupabaseData.useEffect\": ()=>{\n                    shipsSubscription.unsubscribe();\n                    crewSubscription.unsubscribe();\n                    sickLeaveSubscription.unsubscribe();\n                    standBackSubscription.unsubscribe();\n                    loansSubscription.unsubscribe();\n                    tripsSubscription.unsubscribe();\n                    tasksSubscription.unsubscribe();\n                }\n            })[\"useSupabaseData.useEffect\"];\n        }\n    }[\"useSupabaseData.useEffect\"], []);\n    // Add crew member\n    const addCrew = async (crewData)=>{\n        try {\n            console.log('Adding crew member to Supabase:', crewData);\n            console.log('Crew data details:', JSON.stringify(crewData, null, 2));\n            // Validate required fields\n            const requiredFields = [\n                'id',\n                'first_name',\n                'last_name',\n                'nationality',\n                'position'\n            ];\n            const missingFields = requiredFields.filter((field)=>!crewData[field]);\n            if (missingFields.length > 0) {\n                const error = new Error(\"Missing required fields: \".concat(missingFields.join(', ')));\n                console.error('Validation error:', error);\n                throw error;\n            }\n            // Check for duplicate crew member\n            const { data: existingCrew, error: checkError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').select('id').eq('first_name', crewData.first_name).eq('last_name', crewData.last_name).eq('nationality', crewData.nationality).single();\n            if (existingCrew && !checkError) {\n                const error = new Error(\"Crew member with name \".concat(crewData.first_name, \" \").concat(crewData.last_name, \" already exists\"));\n                console.error('Duplicate crew member:', error);\n                throw error;\n            }\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').insert([\n                crewData\n            ]).select().single();\n            if (error) {\n                console.error('Supabase error adding crew:', error);\n                console.error('Error details:', JSON.stringify(error, null, 2));\n                console.error('Error code:', error.code);\n                console.error('Error message:', error.message);\n                console.error('Error hint:', error.hint);\n                throw error;\n            }\n            console.log('Crew member added successfully:', data);\n            await loadData();\n            return data;\n        } catch (err) {\n            console.error('Error adding crew:', err);\n            console.error('Error details:', JSON.stringify(err, null, 2));\n            throw err;\n        }\n    };\n    // Update crew member\n    const updateCrew = async (id, updates)=>{\n        try {\n            console.log('Updating crew member in Supabase:', id, updates);\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').update(updates).eq('id', id).select().single();\n            if (error) {\n                console.error('Supabase error updating crew:', error);\n                throw error;\n            }\n            console.log('Crew member updated successfully');\n            await loadData();\n            return data;\n        } catch (err) {\n            console.error('Error updating crew:', err);\n            throw err;\n        }\n    };\n    // Delete crew member\n    const deleteCrew = async (id)=>{\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').delete().eq('id', id);\n            if (error) throw error;\n            await loadData() // Reload all data\n            ;\n        } catch (err) {\n            console.error('Error deleting crew:', err);\n            throw err;\n        }\n    };\n    // Add ship\n    const addShip = async (shipData)=>{\n        try {\n            console.log('Adding ship to Supabase:', shipData);\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('ships').insert([\n                shipData\n            ]).select().single();\n            if (error) {\n                console.error('Supabase error adding ship:', error);\n                console.error('Error details:', JSON.stringify(error, null, 2));\n                throw error;\n            }\n            console.log('Ship added successfully:', data);\n            await loadData();\n            return data;\n        } catch (err) {\n            console.error('Error adding ship:', err);\n            throw err;\n        }\n    };\n    // Update ship\n    const updateShip = async (id, updates)=>{\n        try {\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('ships').update(updates).eq('id', id).select().single();\n            if (error) throw error;\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error updating ship:', err);\n            throw err;\n        }\n    };\n    // Delete ship\n    const deleteShip = async (id)=>{\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('ships').delete().eq('id', id);\n            if (error) throw error;\n            await loadData() // Reload all data\n            ;\n        } catch (err) {\n            console.error('Error deleting ship:', err);\n            throw err;\n        }\n    };\n    // Add sick leave\n    const addSickLeave = async (sickLeaveData)=>{\n        try {\n            console.log('Adding sick leave to Supabase:', sickLeaveData);\n            // Ensure notes is not null\n            if (sickLeaveData.notes === null || sickLeaveData.notes === undefined) {\n                sickLeaveData.notes = \"\";\n            }\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('sick_leave').insert([\n                sickLeaveData\n            ]).select().single();\n            if (error) {\n                console.error('Supabase error adding sick leave:', error);\n                console.error('Error details:', JSON.stringify(error, null, 2));\n                throw error;\n            }\n            console.log('Sick leave added successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error adding sick leave:', err);\n            throw err;\n        }\n    };\n    // Update sick leave\n    const updateSickLeave = async (id, updates)=>{\n        try {\n            console.log('Updating sick leave in Supabase:', id, updates);\n            // Ensure notes is not null\n            if (updates.notes === null || updates.notes === undefined) {\n                updates.notes = \"\";\n            }\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('sick_leave').update(updates).eq('id', id).select().single();\n            if (error) {\n                console.error('Supabase error updating sick leave:', error);\n                console.error('Error details:', JSON.stringify(error, null, 2));\n                throw error;\n            }\n            console.log('Sick leave updated successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error updating sick leave:', err);\n            console.error('Error details:', JSON.stringify(err, null, 2));\n            throw err;\n        }\n    };\n    const addStandBackRecord = async (recordData)=>{\n        try {\n            console.log('=== ADDING STAND BACK RECORD ===');\n            console.log('Original record data:', recordData);\n            // Generate a UUID for the id field\n            const uuid = crypto.randomUUID();\n            console.log('Generated UUID:', uuid);\n            // Remove id if it exists and add our generated UUID\n            const { id, ...dataWithoutId } = recordData;\n            // Create a safe data object with only known database columns\n            const dataToInsert = {\n                id: uuid,\n                crew_member_id: dataWithoutId.crew_member_id,\n                start_date: dataWithoutId.start_date,\n                end_date: dataWithoutId.end_date,\n                days_count: dataWithoutId.days_count,\n                description: dataWithoutId.description,\n                stand_back_days_required: dataWithoutId.stand_back_days_required,\n                stand_back_days_completed: dataWithoutId.stand_back_days_completed,\n                stand_back_days_remaining: dataWithoutId.stand_back_days_remaining,\n                stand_back_status: dataWithoutId.stand_back_status,\n                stand_back_history: dataWithoutId.stand_back_history || []\n            };\n            // Add optional fields if they exist (for backward compatibility)\n            if (dataWithoutId.reason) {\n                dataToInsert.reason = dataWithoutId.reason;\n            }\n            if (dataWithoutId.notes) {\n                dataToInsert.notes = dataWithoutId.notes;\n            }\n            console.log('Data to insert (with generated UUID):', dataToInsert);\n            console.log('Data to insert JSON:', JSON.stringify(dataToInsert, null, 2));\n            // Validate required fields\n            const requiredFields = [\n                'id',\n                'crew_member_id',\n                'start_date',\n                'end_date',\n                'days_count',\n                'stand_back_days_required',\n                'stand_back_days_completed',\n                'stand_back_days_remaining',\n                'stand_back_status'\n            ];\n            const missingFields = requiredFields.filter((field)=>!dataToInsert[field] && dataToInsert[field] !== 0);\n            if (missingFields.length > 0) {\n                console.error('Missing required fields:', missingFields);\n                throw new Error(\"Missing required fields: \".concat(missingFields.join(', ')));\n            }\n            console.log('All required fields present, inserting to database...');\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('stand_back_records').insert([\n                dataToInsert\n            ]).select();\n            if (error) {\n                console.error('âŒ Supabase error adding stand back record:', error);\n                console.error('âŒ Error details:', JSON.stringify(error, null, 2));\n                console.error('âŒ Error code:', error.code);\n                console.error('âŒ Error message:', error.message);\n                console.error('âŒ Error hint:', error.hint);\n                throw error;\n            }\n            console.log('âœ… Stand back record added successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('âŒ Error adding stand back record:', err);\n            console.error('âŒ Error details:', JSON.stringify(err, null, 2));\n            throw err;\n        }\n    };\n    const updateStandBackRecord = async (recordId, updates)=>{\n        try {\n            console.log('Updating stand back record in Supabase:', recordId, updates);\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('stand_back_records').update(updates).eq('id', recordId).select();\n            if (error) {\n                console.error('Supabase error updating stand back record:', error);\n                throw error;\n            }\n            console.log('Stand back record updated successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error updating stand back record:', err);\n            throw err;\n        }\n    };\n    const addLoan = async (loanData)=>{\n        try {\n            console.log('Adding loan to Supabase:', loanData);\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('loans').insert([\n                loanData\n            ]).select();\n            if (error) {\n                console.error('Supabase error adding loan:', error);\n                throw error;\n            }\n            console.log('Loan added successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error adding loan:', err);\n            throw err;\n        }\n    };\n    const completeLoan = async (loanId, notes)=>{\n        try {\n            console.log('Completing loan in Supabase:', loanId);\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('loans').update({\n                status: 'voltooid',\n                completed_at: new Date().toISOString(),\n                notes: notes || \"\"\n            }).eq('id', loanId).select();\n            if (error) {\n                console.error('Supabase error completing loan:', error);\n                throw error;\n            }\n            console.log('Loan completed successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error completing loan:', err);\n            throw err;\n        }\n    };\n    const makePayment = async (loanId, paymentAmount, note)=>{\n        try {\n            console.log('Making payment for loan:', loanId, paymentAmount);\n            // First, get the current loan\n            const { data: loan, error: fetchError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('loans').select('*').eq('id', loanId).single();\n            if (fetchError || !loan) {\n                throw new Error('Loan not found');\n            }\n            // Calculate new values\n            const newPaid = (loan.amount_paid || 0) + paymentAmount;\n            const newRemaining = loan.amount - newPaid;\n            const newStatus = newRemaining <= 0 ? 'voltooid' : 'open';\n            // Create payment history entry\n            const paymentEntry = {\n                date: new Date().toISOString(),\n                amount: paymentAmount,\n                note: note || 'Betaling afgetekend',\n                paidBy: 'User'\n            };\n            // Update loan\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('loans').update({\n                amount_paid: newPaid,\n                amount_remaining: newRemaining,\n                status: newStatus,\n                completed_at: newStatus === 'voltooid' ? new Date().toISOString() : null,\n                payment_history: [\n                    ...loan.payment_history || [],\n                    paymentEntry\n                ]\n            }).eq('id', loanId).select();\n            if (error) {\n                console.error('Supabase error making payment:', error);\n                throw error;\n            }\n            console.log('Payment made successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error making payment:', err);\n            throw err;\n        }\n    };\n    // Trip functions\n    const addTrip = async (tripData)=>{\n        try {\n            console.log('Adding trip:', tripData);\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('trips').insert([\n                tripData\n            ]).select();\n            if (error) {\n                console.error('Error adding trip:', error);\n                throw error;\n            }\n            console.log('Trip added successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error adding trip:', err);\n            throw err;\n        }\n    };\n    const updateTrip = async (tripId, updates)=>{\n        try {\n            console.log('Updating trip:', tripId, updates);\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('trips').update({\n                ...updates,\n                updated_at: new Date().toISOString()\n            }).eq('id', tripId).select().single();\n            if (error) {\n                console.error('Error updating trip:', error);\n                throw error;\n            }\n            console.log('Trip updated successfully:', data);\n            // If trip is completed, auto-update vaste dienst records\n            if (updates.status === 'voltooid' && data.aflosser_id) {\n                console.log('ðŸš€ Trip completed - auto-updating vaste dienst records');\n                await autoUpdateVasteDienstFromTrip(data);\n            }\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error updating trip:', err);\n            throw err;\n        }\n    };\n    // Vaste dienst functions\n    const addVasteDienstRecord = async (recordData)=>{\n        try {\n            console.log('Adding vaste dienst record:', recordData);\n            console.log('Record data details:', JSON.stringify(recordData, null, 2));\n            // Validate required fields\n            const requiredFields = [\n                'aflosser_id',\n                'year',\n                'month',\n                'required_days',\n                'actual_days',\n                'balance_days'\n            ];\n            const missingFields = requiredFields.filter((field)=>recordData[field] === undefined || recordData[field] === null);\n            if (missingFields.length > 0) {\n                const error = new Error(\"Missing required fields: \".concat(missingFields.join(', ')));\n                console.error('Validation error:', error);\n                throw error;\n            }\n            // Check if record already exists for this aflosser/year/month combination\n            const { data: existingRecord, error: checkError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').select('id').eq('aflosser_id', recordData.aflosser_id).eq('year', recordData.year).eq('month', recordData.month).single();\n            if (existingRecord) {\n                console.log('Record already exists for this aflosser/year/month combination, updating instead');\n                // Update existing record instead of creating new one\n                const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').update({\n                    required_days: recordData.required_days,\n                    actual_days: recordData.actual_days,\n                    balance_days: recordData.balance_days,\n                    updated_at: new Date().toISOString()\n                }).eq('id', existingRecord.id).select();\n                if (error) {\n                    console.error('Error updating existing vaste dienst record:', error);\n                    throw error;\n                }\n                console.log('Vaste dienst record updated successfully:', data);\n                await loadData() // Reload all data\n                ;\n                return data;\n            }\n            // If no existing record, create new one\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').insert([\n                recordData\n            ]).select();\n            if (error) {\n                console.error('Supabase error adding vaste dienst record:', error);\n                console.error('Error details:', JSON.stringify(error, null, 2));\n                console.error('Error code:', error.code);\n                console.error('Error message:', error.message);\n                console.error('Error hint:', error.hint);\n                throw error;\n            }\n            console.log('Vaste dienst record added successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error adding vaste dienst record:', err);\n            console.error('Error details:', JSON.stringify(err, null, 2));\n            throw err;\n        }\n    };\n    const updateVasteDienstRecord = async (recordId, updates)=>{\n        try {\n            console.log('Updating vaste dienst record:', recordId, updates);\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').update({\n                ...updates,\n                updated_at: new Date().toISOString()\n            }).eq('id', recordId).select().single();\n            if (error) {\n                console.error('Error updating vaste dienst record:', error);\n                throw error;\n            }\n            console.log('Vaste dienst record updated successfully:', data);\n            await loadData() // Reload all data\n            ;\n            return data;\n        } catch (err) {\n            console.error('Error updating vaste dienst record:', err);\n            throw err;\n        }\n    };\n    const deleteVasteDienstRecord = async (recordId)=>{\n        try {\n            console.log('Deleting vaste dienst record:', recordId);\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').delete().eq('id', recordId);\n            if (error) {\n                console.error('Error deleting vaste dienst record:', error);\n                throw error;\n            }\n            console.log('Vaste dienst record deleted successfully');\n            await loadData() // Reload all data\n            ;\n        } catch (err) {\n            console.error('Error deleting vaste dienst record:', err);\n            throw err;\n        }\n    };\n    // Delete trip permanently\n    const deleteTrip = async (tripId)=>{\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('trips').delete().eq('id', tripId);\n            if (error) {\n                console.error('Supabase error deleting trip:', error);\n                throw error;\n            }\n            console.log('Trip deleted successfully');\n            await loadData() // Reload all data\n            ;\n        } catch (err) {\n            console.error('Error deleting trip:', err);\n            throw err;\n        }\n    };\n    // Delete aflosser permanently\n    const deleteAflosser = async (aflosserId)=>{\n        try {\n            // First delete all related records\n            await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('vaste_dienst_records').delete().eq('aflosser_id', aflosserId);\n            await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('trips').delete().eq('aflosser_id', aflosserId);\n            // Then delete the aflosser\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').delete().eq('id', aflosserId);\n            if (error) {\n                console.error('Supabase error deleting aflosser:', error);\n                throw error;\n            }\n            console.log('Aflosser deleted successfully');\n            await loadData() // Reload all data\n            ;\n        } catch (err) {\n            console.error('Error deleting aflosser:', err);\n            throw err;\n        }\n    };\n    // Notes functions\n    const addNoteToCrew = async (crewId, note)=>{\n        try {\n            // Get current crew member data\n            const { data: crewData, error: fetchError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').select('active_notes').eq('id', crewId).single();\n            if (fetchError) throw fetchError;\n            // Parse existing notes or initialize empty array\n            const currentNotes = (crewData === null || crewData === void 0 ? void 0 : crewData.active_notes) || [];\n            // Add new note with timestamp\n            const newNote = {\n                id: Date.now().toString(),\n                content: note,\n                createdAt: new Date().toISOString(),\n                createdBy: 'user' // You could get this from auth context\n            };\n            const updatedNotes = [\n                ...currentNotes,\n                newNote\n            ];\n            // Update crew member with new notes\n            const { error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').update({\n                active_notes: updatedNotes\n            }).eq('id', crewId);\n            if (updateError) throw updateError;\n            console.log('Note added successfully');\n            await loadData(); // Reload data\n        } catch (error) {\n            console.error('Error adding note:', error);\n            throw error;\n        }\n    };\n    const removeNoteFromCrew = async (crewId, noteId)=>{\n        try {\n            // Get current crew member data\n            const { data: crewData, error: fetchError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').select('active_notes, archived_notes').eq('id', crewId).single();\n            if (fetchError) throw fetchError;\n            const currentActiveNotes = (crewData === null || crewData === void 0 ? void 0 : crewData.active_notes) || [];\n            const currentArchivedNotes = (crewData === null || crewData === void 0 ? void 0 : crewData.archived_notes) || [];\n            // Find the note to remove\n            const noteToArchive = currentActiveNotes.find((note)=>note.id === noteId);\n            if (!noteToArchive) {\n                throw new Error('Note not found');\n            }\n            // Remove from active notes\n            const updatedActiveNotes = currentActiveNotes.filter((note)=>note.id !== noteId);\n            // Add to archived notes with archive timestamp\n            const archivedNote = {\n                ...noteToArchive,\n                archivedAt: new Date().toISOString()\n            };\n            const updatedArchivedNotes = [\n                ...currentArchivedNotes,\n                archivedNote\n            ];\n            // Update crew member\n            const { error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew').update({\n                active_notes: updatedActiveNotes,\n                archived_notes: updatedArchivedNotes\n            }).eq('id', crewId);\n            if (updateError) throw updateError;\n            console.log('Note archived successfully');\n            await loadData(); // Reload data\n        } catch (error) {\n            console.error('Error removing note:', error);\n            throw error;\n        }\n    };\n    // Add task\n    const addTask = async (taskData)=>{\n        try {\n            console.log('ðŸ“ Adding task with data:', JSON.stringify(taskData, null, 2));\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('tasks').insert([\n                taskData\n            ]).select().single();\n            if (error) {\n                console.error('âŒ Supabase error adding task:', error);\n                console.error('âŒ Error code:', error.code);\n                console.error('âŒ Error message:', error.message);\n                console.error('âŒ Error details:', error.details);\n                console.error('âŒ Error hint:', error.hint);\n                throw error;\n            }\n            await loadData();\n            return data;\n        } catch (err) {\n            console.error('Error adding task:', err);\n            console.error('Error details:', JSON.stringify(err, null, 2));\n            throw err;\n        }\n    };\n    // Update task\n    const updateTask = async (taskId, updates)=>{\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('tasks').update(updates).eq('id', taskId);\n            if (error) throw error;\n            await loadData();\n        } catch (err) {\n            console.error('Error updating task:', err);\n            throw err;\n        }\n    };\n    // Delete task\n    const deleteTask = async (taskId)=>{\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('tasks').delete().eq('id', taskId);\n            if (error) throw error;\n            await loadData();\n        } catch (err) {\n            console.error('Error deleting task:', err);\n            throw err;\n        }\n    };\n    // Complete task\n    const completeTask = async (taskId)=>{\n        try {\n            // Haal eerst de gerelateerde ship_visit op (als die bestaat)\n            const { data: taskData, error: fetchError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('tasks').select('id, related_ship_visit_id').eq('id', taskId).single();\n            if (fetchError) throw fetchError;\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('tasks').update({\n                completed: true,\n                completed_at: new Date().toISOString()\n            }).eq('id', taskId);\n            if (error) throw error;\n            // Als deze taak gekoppeld is aan een scheepsbezoek, zet daar de follow-up uit\n            if (taskData === null || taskData === void 0 ? void 0 : taskData.related_ship_visit_id) {\n                try {\n                    const { error: visitError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('ship_visits').update({\n                        follow_up_needed: false,\n                        follow_up_notes: null\n                    }).eq('id', taskData.related_ship_visit_id);\n                    if (visitError) {\n                        console.error('Error updating related ship_visit after completing task:', visitError);\n                    }\n                } catch (innerErr) {\n                    console.error('Unexpected error updating ship_visit for completed task:', innerErr);\n                }\n            }\n            await loadData();\n        } catch (err) {\n            console.error('Error completing task:', err);\n            throw err;\n        }\n    };\n    return {\n        ships,\n        crew,\n        sickLeave,\n        standBackRecords,\n        loans,\n        trips,\n        tasks,\n        loading,\n        error,\n        loadData,\n        crewColorTags,\n        async setCrewColorTag (crewId, color) {\n            try {\n                if (!crewId) return;\n                if (color) {\n                    // upsert color\n                    const { error: upsertError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew_color_tags').upsert({\n                        crew_id: crewId,\n                        color\n                    }, {\n                        onConflict: 'crew_id'\n                    });\n                    if (upsertError) throw upsertError;\n                } else {\n                    // delete color\n                    const { error: delError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('crew_color_tags').delete().eq('crew_id', crewId);\n                    if (delError) throw delError;\n                }\n                // update local state\n                setCrewColorTags((prev)=>{\n                    const next = {\n                        ...prev\n                    };\n                    if (color) next[crewId] = color;\n                    else delete next[crewId];\n                    return next;\n                });\n            } catch (e) {\n                const err = e;\n                const msg = (err === null || err === void 0 ? void 0 : err.message) || (typeof err === 'string' ? err : JSON.stringify(err));\n                console.error('Error setting crew color tag:', msg);\n                // If table missing, surface a clear hint once\n                if ((msg === null || msg === void 0 ? void 0 : msg.includes('relation')) && (msg === null || msg === void 0 ? void 0 : msg.includes('crew_color_tags'))) {\n                    console.warn('Hint: create table crew_color_tags (crew_id uuid primary key references crew(id), color text not null)');\n                }\n                throw e;\n            }\n        },\n        addCrew,\n        updateCrew,\n        deleteCrew,\n        addShip,\n        updateShip,\n        deleteShip,\n        addSickLeave,\n        updateSickLeave,\n        addStandBackRecord,\n        updateStandBackRecord,\n        addLoan,\n        completeLoan,\n        makePayment,\n        addTrip,\n        updateTrip,\n        deleteTrip,\n        deleteAflosser,\n        vasteDienstRecords,\n        addVasteDienstRecord,\n        updateVasteDienstRecord,\n        deleteVasteDienstRecord,\n        addNoteToCrew,\n        removeNoteFromCrew,\n        addTask,\n        updateTask,\n        deleteTask,\n        completeTask\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZS1zdXBhYmFzZS1kYXRhLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUEyQztBQUNGO0FBRXpDLDRFQUE0RTtBQUM1RSxtRUFBbUU7QUFDNUQsU0FBU0csNkJBQTZCQyxTQUFpQixFQUFFQyxTQUFpQixFQUFFQyxPQUFlLEVBQUVDLE9BQWU7SUFDakgsSUFBSSxDQUFDSCxhQUFhLENBQUNFLFdBQVcsQ0FBQ0QsYUFBYSxDQUFDRSxTQUFTLE9BQU87SUFFN0QsNkNBQTZDO0lBQzdDLE1BQU1DLFlBQVksQ0FBQ0M7UUFDakIsSUFBSSxDQUFDQSxXQUFXLE9BQU9BLFlBQVksVUFBVTtZQUMzQ0MsUUFBUUMsS0FBSyxDQUFDLHdCQUF3QkY7WUFDdEMsT0FBTyxJQUFJRyxPQUFPLGtDQUFrQzs7UUFDdEQ7UUFFQSw4RUFBOEU7UUFDOUUsSUFBSUgsUUFBUUksUUFBUSxDQUFDLFFBQVEscUJBQXFCQyxJQUFJLENBQUNMLFVBQVU7WUFDL0QsNENBQTRDO1lBQzVDLE1BQU1NLE9BQU8sSUFBSUgsS0FBS0g7WUFDdEIsSUFBSU8sTUFBTUQsS0FBS0UsT0FBTyxLQUFLO2dCQUN6QlAsUUFBUUMsS0FBSyxDQUFDLHFCQUFxQkY7Z0JBQ25DLE9BQU8sSUFBSUcsT0FBTyxrQ0FBa0M7O1lBQ3REO1lBQ0EsT0FBT0c7UUFDVDtRQUVBLHdDQUF3QztRQUN4QyxNQUFNRyxRQUFRVCxRQUFRVSxLQUFLLENBQUM7UUFDNUIsSUFBSUQsTUFBTUUsTUFBTSxLQUFLLEdBQUc7WUFDdEJWLFFBQVFDLEtBQUssQ0FBQyx3QkFBd0JGO1lBQ3RDLE9BQU8sSUFBSUcsT0FBTyxrQ0FBa0M7O1FBQ3REO1FBRUEsTUFBTVMsTUFBTUMsU0FBU0osS0FBSyxDQUFDLEVBQUUsRUFBRTtRQUMvQixNQUFNSyxRQUFRRCxTQUFTSixLQUFLLENBQUMsRUFBRSxFQUFFLE1BQU0sRUFBRSxnQ0FBZ0M7O1FBQ3pFLE1BQU1NLE9BQU9GLFNBQVNKLEtBQUss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QVErSixJQUFJLENBQUM7Z0JBQ2Y7Z0JBQ0EsTUFBTTRCO1lBQ1I7UUFDRjtRQUNBZ0I7UUFDQVM7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQUM7UUFDQUM7UUFDQUU7UUFDQUM7UUFDQWtCO1FBQ0FDO1FBQ0FFO1FBQ0FHO1FBQ0FZO1FBQ0FFO1FBQ0FNO1FBQ0FDO1FBQ0EzTTtRQUNBdU07UUFDQUM7UUFDQUM7UUFDQUk7UUFDQVc7UUFDQVU7UUFDQUc7UUFDQUU7UUFDQUM7SUFDRjtBQUNGIiwic291cmNlcyI6WyJDOlxcRGV2XFxiYW1hbGl0ZS1oci1zeXN0ZW0gQmVtYW5uaW5nc2xpanN0XFxob29rc1xcdXNlLXN1cGFiYXNlLWRhdGEudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgc3VwYWJhc2UgfSBmcm9tICdAL2xpYi9zdXBhYmFzZSdcblxuLy8gRnVuY3Rpb24gdG8gY2FsY3VsYXRlIHdvcmsgZGF5cyBmb3IgdmFzdGUgZGllbnN0IGFmbG9zc2VycyBiYXNlZCBvbiBob3Vyc1xuLy8gVXNlcyAxMi1ob3VyIGluY3JlbWVudHM6IDAtMTJoID0gMC41IGRheSwgMTItMjRoID0gMS4wIGRheSwgZXRjLlxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVdvcmtEYXlzVmFzdGVEaWVuc3Qoc3RhcnREYXRlOiBzdHJpbmcsIHN0YXJ0VGltZTogc3RyaW5nLCBlbmREYXRlOiBzdHJpbmcsIGVuZFRpbWU6IHN0cmluZyk6IG51bWJlciB7XG4gIGlmICghc3RhcnREYXRlIHx8ICFlbmREYXRlIHx8ICFzdGFydFRpbWUgfHwgIWVuZFRpbWUpIHJldHVybiAwXG5cbiAgLy8gUGFyc2UgYm90aCBERC1NTS1ZWVlZIGFuZCBJU08gZm9ybWF0IGRhdGVzXG4gIGNvbnN0IHBhcnNlRGF0ZSA9IChkYXRlU3RyOiBzdHJpbmcpOiBEYXRlID0+IHtcbiAgICBpZiAoIWRhdGVTdHIgfHwgdHlwZW9mIGRhdGVTdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGRhdGUgc3RyaW5nOicsIGRhdGVTdHIpXG4gICAgICByZXR1cm4gbmV3IERhdGUoKSAvLyBSZXR1cm4gY3VycmVudCBkYXRlIGFzIGZhbGxiYWNrXG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIGl0J3MgYWxyZWFkeSBhbiBJU08gZGF0ZSAoY29udGFpbnMgVCBvciBoYXMgNC1kaWdpdCB5ZWFyIGF0IHN0YXJ0KVxuICAgIGlmIChkYXRlU3RyLmluY2x1ZGVzKCdUJykgfHwgL15cXGR7NH0tXFxkezJ9LVxcZHsyfS8udGVzdChkYXRlU3RyKSkge1xuICAgICAgLy8gSXQncyBhbHJlYWR5IGFuIElTTyBkYXRlLCB1c2UgaXQgZGlyZWN0bHlcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShkYXRlU3RyKVxuICAgICAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIElTTyBkYXRlOicsIGRhdGVTdHIpXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpIC8vIFJldHVybiBjdXJyZW50IGRhdGUgYXMgZmFsbGJhY2tcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRlXG4gICAgfVxuICAgIFxuICAgIC8vIE90aGVyd2lzZSwgcGFyc2UgYXMgREQtTU0tWVlZWSBmb3JtYXRcbiAgICBjb25zdCBwYXJ0cyA9IGRhdGVTdHIuc3BsaXQoJy0nKVxuICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgZGF0ZSBmb3JtYXQ6JywgZGF0ZVN0cilcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpIC8vIFJldHVybiBjdXJyZW50IGRhdGUgYXMgZmFsbGJhY2tcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZGF5ID0gcGFyc2VJbnQocGFydHNbMF0sIDEwKVxuICAgIGNvbnN0IG1vbnRoID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKSAtIDEgLy8gSmF2YVNjcmlwdCBtb250aHMgYXJlIDAtYmFzZWRcbiAgICBjb25zdCB5ZWFyID0gcGFyc2VJbnQocGFydHNbMl0sIDEwKVxuICAgIFxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5KVxuICAgIGlmIChpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgcGFyc2VkIGRhdGU6JywgZGF0ZVN0cilcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpIC8vIFJldHVybiBjdXJyZW50IGRhdGUgYXMgZmFsbGJhY2tcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGRhdGVcbiAgfVxuXG4gIC8vIFBhcnNlIHRpbWUgc3RyaW5nIChISDpNTTpTUyBvciBISDpNTSBmb3JtYXQpXG4gIGNvbnN0IHBhcnNlVGltZSA9ICh0aW1lU3RyOiBzdHJpbmcpOiBudW1iZXIgPT4ge1xuICAgIGlmICghdGltZVN0ciB8fCB0eXBlb2YgdGltZVN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgdGltZSBzdHJpbmc6JywgdGltZVN0cilcbiAgICAgIHJldHVybiAwXG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHRpbWVQYXJ0cyA9IHRpbWVTdHIuc3BsaXQoJzonKVxuICAgIGlmICh0aW1lUGFydHMubGVuZ3RoIDwgMikge1xuICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCB0aW1lIGZvcm1hdDonLCB0aW1lU3RyKVxuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gICAgXG4gICAgY29uc3QgaG91cnMgPSBwYXJzZUludCh0aW1lUGFydHNbMF0sIDEwKVxuICAgIGNvbnN0IG1pbnV0ZXMgPSBwYXJzZUludCh0aW1lUGFydHNbMV0sIDEwKVxuICAgIFxuICAgIGlmIChpc05hTihob3VycykgfHwgaXNOYU4obWludXRlcykpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgdGltZSB2YWx1ZXM6JywgdGltZVN0cilcbiAgICAgIHJldHVybiAwXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBob3VycyArIChtaW51dGVzIC8gNjApXG4gIH1cblxuICBjb25zdCBzdGFydCA9IHBhcnNlRGF0ZShzdGFydERhdGUpXG4gIGNvbnN0IGVuZCA9IHBhcnNlRGF0ZShlbmREYXRlKVxuICBjb25zdCBzdGFydFRpbWVIb3VycyA9IHBhcnNlVGltZShzdGFydFRpbWUpXG4gIGNvbnN0IGVuZFRpbWVIb3VycyA9IHBhcnNlVGltZShlbmRUaW1lKVxuXG4gIGlmIChlbmQgPCBzdGFydCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yOiBlbmQgZGF0ZSBpcyBiZWZvcmUgc3RhcnQgZGF0ZScpXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIC8vIENyZWF0ZSBmdWxsIGRhdGV0aW1lIG9iamVjdHNcbiAgY29uc3Qgc3RhcnREYXRlVGltZSA9IG5ldyBEYXRlKHN0YXJ0KVxuICBzdGFydERhdGVUaW1lLnNldEhvdXJzKE1hdGguZmxvb3Ioc3RhcnRUaW1lSG91cnMpLCAoc3RhcnRUaW1lSG91cnMgJSAxKSAqIDYwLCAwLCAwKVxuXG4gIGNvbnN0IGVuZERhdGVUaW1lID0gbmV3IERhdGUoZW5kKVxuICBlbmREYXRlVGltZS5zZXRIb3VycyhNYXRoLmZsb29yKGVuZFRpbWVIb3VycyksIChlbmRUaW1lSG91cnMgJSAxKSAqIDYwLCAwLCAwKVxuXG4gIC8vIENhbGN1bGF0ZSBkdXJhdGlvbiBpbiBob3Vyc1xuICBjb25zdCB0aW1lRGlmZk1zID0gZW5kRGF0ZVRpbWUuZ2V0VGltZSgpIC0gc3RhcnREYXRlVGltZS5nZXRUaW1lKClcbiAgY29uc3QgdG90YWxIb3VycyA9IHRpbWVEaWZmTXMgLyAoMTAwMCAqIDYwICogNjApXG5cbiAgLy8gQ29udmVydCB0byBkYXkgY3JlZGl0cyB1c2luZyAxMi1ob3VyIGluY3JlbWVudHNcbiAgLy8gRm9ybXVsYTogY3JlZGl0cyA9IGNlaWwoaG91cnMgLyAxMikgKiAwLjVcbiAgY29uc3QgZGF5Q3JlZGl0cyA9IE1hdGguY2VpbCh0b3RhbEhvdXJzIC8gMTIpICogMC41XG5cbiAgcmV0dXJuIGRheUNyZWRpdHNcbn1cblxuLy8gRnVuY3RpZSBvbSBhdXRvbWF0aXNjaCBjcmV3IG1lbWJlcnMgdGUgYWN0aXZlcmVuIG9wIGh1biBzdGFydGRhdHVtXG5hc3luYyBmdW5jdGlvbiBhdXRvQWN0aXZhdGVDcmV3TWVtYmVycyhjcmV3RGF0YTogYW55W10pIHtcbiAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpXG4gIHRvZGF5LnNldEhvdXJzKDAsIDAsIDAsIDApIC8vIFJlc2V0IG5hYXIgc3RhcnQgdmFuIGRlIGRhZ1xuICBcbiAgZm9yIChjb25zdCBtZW1iZXIgb2YgY3Jld0RhdGEpIHtcbiAgICAvLyBDaGVjayBvZiBkZXplIHBlcnNvb24gbW9ldCB3b3JkZW4gZ2VhY3RpdmVlcmRcbiAgICAvLyBTdGF0dXMga2FuIFwidGh1aXNcIiB6aWpuICh3YWNodGVuZCBvcCBzdGFydGRhdHVtKSBvZiBcIm5vZy1pbi10ZS1kZWxlblwiXG4gICAgaWYgKFxuICAgICAgKG1lbWJlci5zdGF0dXMgPT09ICd0aHVpcycgfHwgbWVtYmVyLnN0YXR1cyA9PT0gJ25vZy1pbi10ZS1kZWxlbicpICYmXG4gICAgICBtZW1iZXIuZXhwZWN0ZWRfc3RhcnRfZGF0ZSAmJlxuICAgICAgbWVtYmVyLnNoaXBfaWQgJiZcbiAgICAgIG1lbWJlci5yZWdpbWVcbiAgICApIHtcbiAgICAgIGNvbnN0IHN0YXJ0RGF0ZSA9IG5ldyBEYXRlKG1lbWJlci5leHBlY3RlZF9zdGFydF9kYXRlKVxuICAgICAgc3RhcnREYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApXG4gICAgICBcbiAgICAgIC8vIElzIHZhbmRhYWcgPj0gc3RhcnRkYXR1bT9cbiAgICAgIGlmICh0b2RheSA+PSBzdGFydERhdGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coYPCfmoAgQXV0by1hY3RpdmF0aW5nICR7bWVtYmVyLmZpcnN0X25hbWV9ICR7bWVtYmVyLmxhc3RfbmFtZX0gLSBTdGFydCBkYXRlIHJlYWNoZWQhYClcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVXBkYXRlIG5hYXIgXCJhYW4tYm9vcmRcIiBzdGF0dXNcbiAgICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgLmZyb20oJ2NyZXcnKVxuICAgICAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgICAgIHN0YXR1czogJ2Fhbi1ib29yZCcsXG4gICAgICAgICAgICAgIG9uX2JvYXJkX3NpbmNlOiBtZW1iZXIuZXhwZWN0ZWRfc3RhcnRfZGF0ZSxcbiAgICAgICAgICAgICAgdGh1aXNfc2luZHM6IG51bGwsIC8vIENsZWFyIHRodWlzX3NpbmRzICh3YXMgdGh1aXMsIG51IGFhbiBib29yZClcbiAgICAgICAgICAgICAgZXhwZWN0ZWRfc3RhcnRfZGF0ZTogbnVsbCwgLy8gQ2xlYXIgZXhwZWN0ZWRfc3RhcnRfZGF0ZVxuICAgICAgICAgICAgICBzdWJfc3RhdHVzOiBudWxsIC8vIENsZWFyIHN1Yl9zdGF0dXNcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZXEoJ2lkJywgbWVtYmVyLmlkKVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYXV0by1hY3RpdmF0aW5nIGNyZXcgbWVtYmVyOicsIGVycm9yKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFICR7bWVtYmVyLmZpcnN0X25hbWV9ICR7bWVtYmVyLmxhc3RfbmFtZX0gaXMgbm93IGFjdGl2ZSFgKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gYXV0by1hY3RpdmF0aW9uOicsIGVycilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBGdW5jdGllIG9tIGF1dG9tYXRpc2NoIHJvdGF0aWVzIHVpdCB0ZSB2b2VyZW5cbmFzeW5jIGZ1bmN0aW9uIGF1dG9Sb3RhdGVDcmV3TWVtYmVycyhjcmV3RGF0YTogYW55W10pIHtcbiAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpXG4gIHRvZGF5LnNldEhvdXJzKDAsIDAsIDAsIDApXG4gIFxuICBmb3IgKGNvbnN0IG1lbWJlciBvZiBjcmV3RGF0YSkge1xuICAgIC8vIFNraXAgYWxzIGdlZW4gcmVnaW1lLCB6aWVrLCBvZiBcIkFsdGlqZFwiXG4gICAgaWYgKCFtZW1iZXIucmVnaW1lIHx8IG1lbWJlci5zdGF0dXMgPT09ICd6aWVrJyB8fCBtZW1iZXIucmVnaW1lID09PSAnQWx0aWpkJykge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgXG4gICAgY29uc3QgcmVnaW1lV2Vla3MgPSBwYXJzZUludChtZW1iZXIucmVnaW1lLnNwbGl0KCcvJylbMF0pXG4gICAgY29uc3QgcmVnaW1lRGF5cyA9IHJlZ2ltZVdlZWtzICogN1xuICAgIFxuICAgIC8vIENoZWNrIG9mIGllbWFuZCB2YW4gYWFuLWJvb3JkIG5hYXIgdGh1aXMgbW9ldFxuICAgIGlmIChtZW1iZXIuc3RhdHVzID09PSAnYWFuLWJvb3JkJyAmJiBtZW1iZXIub25fYm9hcmRfc2luY2UpIHtcbiAgICAgIGNvbnN0IG9uQm9hcmREYXRlID0gbmV3IERhdGUobWVtYmVyLm9uX2JvYXJkX3NpbmNlKVxuICAgICAgb25Cb2FyZERhdGUuc2V0SG91cnMoMCwgMCwgMCwgMClcbiAgICAgIFxuICAgICAgY29uc3QgZGF5c1NpbmNlT25Cb2FyZCA9IE1hdGguZmxvb3IoKHRvZGF5LmdldFRpbWUoKSAtIG9uQm9hcmREYXRlLmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpXG4gICAgICBcbiAgICAgIGlmIChkYXlzU2luY2VPbkJvYXJkID49IHJlZ2ltZURheXMpIHtcbiAgICAgICAgY29uc3QgdGh1aXNTaW5kcyA9IG5ldyBEYXRlKG9uQm9hcmREYXRlKVxuICAgICAgICB0aHVpc1NpbmRzLnNldERhdGUodGh1aXNTaW5kcy5nZXREYXRlKCkgKyByZWdpbWVEYXlzKVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYPCflIQgQXV0by1yb3RhdGluZyAke21lbWJlci5maXJzdF9uYW1lfSAke21lbWJlci5sYXN0X25hbWV9IHRvIFRIVUlTYClcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5mcm9tKCdjcmV3JylcbiAgICAgICAgICAgIC51cGRhdGUoe1xuICAgICAgICAgICAgICBzdGF0dXM6ICd0aHVpcycsXG4gICAgICAgICAgICAgIHRodWlzX3NpbmRzOiB0aHVpc1NpbmRzLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcbiAgICAgICAgICAgICAgb25fYm9hcmRfc2luY2U6IG51bGxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZXEoJ2lkJywgbWVtYmVyLmlkKVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igcm90YXRpbmcgdG8gdGh1aXM6JywgZXJyb3IpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgJHttZW1iZXIuZmlyc3RfbmFtZX0gaXMgbm93IHRodWlzYClcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHJvdGF0aW9uOicsIGVycilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBvZiBpZW1hbmQgdmFuIHRodWlzIG5hYXIgYWFuLWJvb3JkIG1vZXRcbiAgICBpZiAobWVtYmVyLnN0YXR1cyA9PT0gJ3RodWlzJyAmJiBtZW1iZXIudGh1aXNfc2luZHMpIHtcbiAgICAgIGNvbnN0IHRodWlzRGF0ZSA9IG5ldyBEYXRlKG1lbWJlci50aHVpc19zaW5kcylcbiAgICAgIHRodWlzRGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKVxuICAgICAgXG4gICAgICBjb25zdCBkYXlzU2luY2VUaHVpcyA9IE1hdGguZmxvb3IoKHRvZGF5LmdldFRpbWUoKSAtIHRodWlzRGF0ZS5nZXRUaW1lKCkpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKVxuICAgICAgXG4gICAgICBpZiAoZGF5c1NpbmNlVGh1aXMgPj0gcmVnaW1lRGF5cykge1xuICAgICAgICBjb25zdCBvbkJvYXJkU2luY2UgPSBuZXcgRGF0ZSh0aHVpc0RhdGUpXG4gICAgICAgIG9uQm9hcmRTaW5jZS5zZXREYXRlKG9uQm9hcmRTaW5jZS5nZXREYXRlKCkgKyByZWdpbWVEYXlzKVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYPCflIQgQXV0by1yb3RhdGluZyAke21lbWJlci5maXJzdF9uYW1lfSAke21lbWJlci5sYXN0X25hbWV9IHRvIEFBTi1CT09SRGApXG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAuZnJvbSgnY3JldycpXG4gICAgICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICAgICAgc3RhdHVzOiAnYWFuLWJvb3JkJyxcbiAgICAgICAgICAgICAgb25fYm9hcmRfc2luY2U6IG9uQm9hcmRTaW5jZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXG4gICAgICAgICAgICAgIHRodWlzX3NpbmRzOiBudWxsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmVxKCdpZCcsIG1lbWJlci5pZClcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJvdGF0aW5nIHRvIGFhbi1ib29yZDonLCBlcnJvcilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSAke21lbWJlci5maXJzdF9uYW1lfSBpcyBub3cgYWFuLWJvb3JkYClcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHJvdGF0aW9uOicsIGVycilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBGdW5jdGllIG9tIGF1dG9tYXRpc2NoIHZhc3RlIGRpZW5zdCByZWNvcmRzIHRlIGJlaGVyZW5cbmFzeW5jIGZ1bmN0aW9uIGF1dG9NYW5hZ2VWYXN0ZURpZW5zdFJlY29yZHMoY3Jld0RhdGE6IGFueVtdLCB2YXN0ZURpZW5zdFJlY29yZHM6IGFueVtdLCB0cmlwc0RhdGE6IGFueVtdKSB7XG4gIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKVxuICBjb25zdCBjdXJyZW50WWVhciA9IHRvZGF5LmdldEZ1bGxZZWFyKClcbiAgY29uc3QgY3VycmVudE1vbnRoID0gdG9kYXkuZ2V0TW9udGgoKSArIDEgLy8gSmF2YVNjcmlwdCBtb250aHMgYXJlIDAtYmFzZWRcbiAgXG4gIGNvbnNvbGUubG9nKGDwn5SnIEF1dG8tbWFuYWdpbmcgdmFzdGUgZGllbnN0IHJlY29yZHMgZm9yICR7Y3VycmVudFllYXJ9LSR7Y3VycmVudE1vbnRofWApXG4gIFxuICAvLyBHZXQgYWxsIGFmbG9zc2VycyBpbiB2YXN0ZSBkaWVuc3RcbiAgY29uc3QgdmFzdGVEaWVuc3RBZmxvc3NlcnMgPSBjcmV3RGF0YS5maWx0ZXIobWVtYmVyID0+IG1lbWJlci52YXN0ZV9kaWVuc3QgPT09IHRydWUpXG4gIFxuICBmb3IgKGNvbnN0IGFmbG9zc2VyIG9mIHZhc3RlRGllbnN0QWZsb3NzZXJzKSB7XG4gICAgY29uc29sZS5sb2coYPCfk4sgUHJvY2Vzc2luZyB2YXN0ZSBkaWVuc3QgYWZsb3NzZXI6ICR7YWZsb3NzZXIuZmlyc3RfbmFtZX0gJHthZmxvc3Nlci5sYXN0X25hbWV9YClcbiAgICBcbiAgICAvLyBDaGVjayBpZiBjdXJyZW50IG1vbnRoIHJlY29yZCBleGlzdHNcbiAgICBjb25zdCBleGlzdGluZ1JlY29yZCA9IHZhc3RlRGllbnN0UmVjb3Jkcy5maW5kKHJlY29yZCA9PiBcbiAgICAgIHJlY29yZC5hZmxvc3Nlcl9pZCA9PT0gYWZsb3NzZXIuaWQgJiYgXG4gICAgICByZWNvcmQueWVhciA9PT0gY3VycmVudFllYXIgJiYgXG4gICAgICByZWNvcmQubW9udGggPT09IGN1cnJlbnRNb250aFxuICAgIClcbiAgICBcbiAgICBpZiAoIWV4aXN0aW5nUmVjb3JkKSB7XG4gICAgICAvLyBDcmVhdGUgbmV3IG1vbnRobHkgcmVjb3JkXG4gICAgICBjb25zb2xlLmxvZyhg8J+ThSBDcmVhdGluZyBuZXcgbW9udGhseSByZWNvcmQgZm9yICR7YWZsb3NzZXIuZmlyc3RfbmFtZX0gJHthZmxvc3Nlci5sYXN0X25hbWV9YClcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbmV3UmVjb3JkID0ge1xuICAgICAgICAgIGFmbG9zc2VyX2lkOiBhZmxvc3Nlci5pZCxcbiAgICAgICAgICB5ZWFyOiBjdXJyZW50WWVhcixcbiAgICAgICAgICBtb250aDogY3VycmVudE1vbnRoLFxuICAgICAgICAgIHJlcXVpcmVkX2RheXM6IDE1LCAvLyBTdGFuZGFyZCAxNSBkYXlzIHBlciBtb250aFxuICAgICAgICAgIGFjdHVhbF9kYXlzOiAwLCAvLyBXaWxsIGJlIGNhbGN1bGF0ZWQgZnJvbSB0cmlwc1xuICAgICAgICAgIGJhbGFuY2VfZGF5czogMCwgLy8gV2lsbCBiZSBjYWxjdWxhdGVkXG4gICAgICAgICAgbm90ZXM6IGBBdXRvbWF0aXNjaCBhYW5nZW1hYWt0IHZvb3IgJHtjdXJyZW50WWVhcn0tJHtjdXJyZW50TW9udGh9YFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCd2YXN0ZV9kaWVuc3RfcmVjb3JkcycpXG4gICAgICAgICAgLmluc2VydChbbmV3UmVjb3JkXSlcbiAgICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgICAuc2luZ2xlKClcbiAgICAgICAgXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHZhc3RlIGRpZW5zdCByZWNvcmQ6JywgZXJyb3IpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKchSBDcmVhdGVkIG1vbnRobHkgcmVjb3JkIGZvciAke2FmbG9zc2VyLmZpcnN0X25hbWV9YClcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHZhc3RlIGRpZW5zdCByZWNvcmQgY3JlYXRpb246JywgZXJyKVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgYWN0dWFsIGRheXMgZnJvbSBjb21wbGV0ZWQgdHJpcHMgZm9yIGN1cnJlbnQgbW9udGhcbiAgICBjb25zdCBjdXJyZW50TW9udGhUcmlwcyA9IHRyaXBzRGF0YS5maWx0ZXIodHJpcCA9PiBcbiAgICAgIHRyaXAuYWZsb3NzZXJfaWQgPT09IGFmbG9zc2VyLmlkICYmIFxuICAgICAgdHJpcC5zdGF0dXMgPT09ICd2b2x0b29pZCcgJiZcbiAgICAgIHRyaXAuZWluZF9kYXR1bSAmJlxuICAgICAgbmV3IERhdGUodHJpcC5laW5kX2RhdHVtKS5nZXRGdWxsWWVhcigpID09PSBjdXJyZW50WWVhciAmJlxuICAgICAgbmV3IERhdGUodHJpcC5laW5kX2RhdHVtKS5nZXRNb250aCgpICsgMSA9PT0gY3VycmVudE1vbnRoXG4gICAgKVxuICAgIFxuICAgIGxldCB0b3RhbFdvcmtEYXlzID0gMFxuICAgIGZvciAoY29uc3QgdHJpcCBvZiBjdXJyZW50TW9udGhUcmlwcykge1xuICAgICAgY29uc3Qgd29ya0RheXMgPSBjYWxjdWxhdGVXb3JrRGF5cyh0cmlwLnN0YXJ0X2RhdHVtLCB0cmlwLnN0YXJ0X3RpamQsIHRyaXAuZWluZF9kYXR1bSwgdHJpcC5laW5kX3RpamQpXG4gICAgICB0b3RhbFdvcmtEYXlzICs9IHdvcmtEYXlzXG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSB0aGUgcmVjb3JkIHdpdGggYWN0dWFsIGRheXMgYW5kIGJhbGFuY2VcbiAgICBpZiAoZXhpc3RpbmdSZWNvcmQpIHtcbiAgICAgIGNvbnN0IHJlcXVpcmVkRGF5cyA9IDE1XG4gICAgICBcbiAgICAgIC8vIENPUlJFQ1RFIEJFUkVLRU5JTkc6IEVpbmRzYWxkbyA9IEJlZ2luc2FsZG8gKyAoR2V3ZXJrdCAtIDE1KVxuICAgICAgLy8gVm9vciBlZXJzdGUgbWFhbmQ6IEJlZ2luc2FsZG8gPSAtMTUgKyBzdGFydHNhbGRvXG4gICAgICBsZXQgYmVnaW5zYWxkbyA9IGV4aXN0aW5nUmVjb3JkLmJhbGFuY2VfZGF5cyB8fCAwXG4gICAgICBcbiAgICAgIC8vIEFscyBkaXQgZGUgZWVyc3RlIG1hYW5kIGlzIGVuIGVyIGlzIGdlZW4gYmVnaW5zYWxkbywgZ2VicnVpayAtMTUgKyBzdGFydHNhbGRvXG4gICAgICBpZiAoYmVnaW5zYWxkbyA9PT0gMCAmJiBjdXJyZW50TW9udGggPT09IDEpIHtcbiAgICAgICAgLy8gUHJvYmVlciBzdGFydHNhbGRvIHVpdCBub3RlcyB0ZSBoYWxlblxuICAgICAgICBjb25zdCBzdGFydHNhbGRvTm90ZSA9IGFmbG9zc2VyLm5vdGVzPy5maW5kKChub3RlOiBhbnkpID0+IFxuICAgICAgICAgIG5vdGUudGV4dCAmJiAobm90ZS50ZXh0LmluY2x1ZGVzKCdzdGFydHNhbGRvJykgfHwgbm90ZS50ZXh0LmluY2x1ZGVzKCdTdGFydHNhbGRvJykpXG4gICAgICAgIClcbiAgICAgICAgaWYgKHN0YXJ0c2FsZG9Ob3RlKSB7XG4gICAgICAgICAgY29uc3QgbWF0Y2ggPSBzdGFydHNhbGRvTm90ZS50ZXh0Lm1hdGNoKC8oLT9cXGQrKD86XFwuXFxkKyk/KS8pXG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydHNhbGRvID0gcGFyc2VGbG9hdChtYXRjaFsxXSlcbiAgICAgICAgICAgIGJlZ2luc2FsZG8gPSAtMTUgKyBzdGFydHNhbGRvXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiBFZXJzdGUgbWFhbmQ6IHN0YXJ0c2FsZG8gJHtzdGFydHNhbGRvfSwgYmVnaW5zYWxkbyAke2JlZ2luc2FsZG99YClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlZ2luc2FsZG8gPT09IDApIGJlZ2luc2FsZG8gPSAtMTUgLy8gRmFsbGJhY2tcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVm9vciBkZSBlZXJzdGUgbWFhbmQ6IHRvb24gaGV0IGJlZ2luc2FsZG8gYWxzIGh1aWRpZyBzYWxkb1xuICAgICAgLy8gVm9vciB2b2xnZW5kZSBtYWFuZGVuOiBiZXJla2VuIGhldCBlaW5kc2FsZG9cbiAgICAgIGxldCBiYWxhbmNlRGF5c1xuICAgICAgaWYgKGN1cnJlbnRNb250aCA9PT0gMSAmJiBiZWdpbnNhbGRvICE9PSAtMTUpIHtcbiAgICAgICAgLy8gRWVyc3RlIG1hYW5kIG1ldCBzdGFydHNhbGRvOiB0b29uIGJlZ2luc2FsZG9cbiAgICAgICAgYmFsYW5jZURheXMgPSBiZWdpbnNhbGRvXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3JtYWxlIGJlcmVrZW5pbmc6IGJlZ2luc2FsZG8gKyAoZ2V3ZXJrdCAtIDE1KVxuICAgICAgICBiYWxhbmNlRGF5cyA9IGJlZ2luc2FsZG8gKyAodG90YWxXb3JrRGF5cyAtIHJlcXVpcmVkRGF5cylcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2FwIHZhbHVlcyB0byBmaXQgaW4gREVDSU1BTCg0LDEpIC0gbWF4IDk5OS45XG4gICAgICBjb25zdCBjYXBwZWRBY3R1YWxEYXlzID0gTWF0aC5taW4odG90YWxXb3JrRGF5cywgOTk5LjkpXG4gICAgICBjb25zdCBjYXBwZWRCYWxhbmNlRGF5cyA9IE1hdGgubWluKE1hdGgubWF4KGJhbGFuY2VEYXlzLCAtOTk5LjkpLCA5OTkuOSlcbiAgICAgIFxuICAgICAgaWYgKGV4aXN0aW5nUmVjb3JkLmFjdHVhbF9kYXlzICE9PSBjYXBwZWRBY3R1YWxEYXlzIHx8IGV4aXN0aW5nUmVjb3JkLmJhbGFuY2VfZGF5cyAhPT0gY2FwcGVkQmFsYW5jZURheXMpIHtcbiAgICAgICAgY29uc29sZS5sb2coYPCfk4ogVXBkYXRpbmcgcmVjb3JkIGZvciAke2FmbG9zc2VyLmZpcnN0X25hbWV9OiAke2NhcHBlZEFjdHVhbERheXN9IGRheXMgKGJhbGFuY2U6ICR7Y2FwcGVkQmFsYW5jZURheXN9KWApXG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCd2YXN0ZV9kaWVuc3RfcmVjb3JkcycpXG4gICAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgICBhY3R1YWxfZGF5czogY2FwcGVkQWN0dWFsRGF5cyxcbiAgICAgICAgICAgIGJhbGFuY2VfZGF5czogY2FwcGVkQmFsYW5jZURheXNcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5lcSgnaWQnLCBleGlzdGluZ1JlY29yZC5pZClcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciB1cGRhdGluZyB2YXN0ZSBkaWVuc3QgcmVjb3JkOicsIGVycm9yKVxuICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGRldGFpbHM6JywgSlNPTi5zdHJpbmdpZnkoZXJyb3IsIG51bGwsIDIpKVxuICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFJlY29yZCBkYXRhOicsIHsgaWQ6IGV4aXN0aW5nUmVjb3JkLmlkLCBhY3R1YWxfZGF5czogdG90YWxXb3JrRGF5cywgYmFsYW5jZV9kYXlzOiBiYWxhbmNlRGF5cyB9KVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFVwZGF0ZWQgcmVjb3JkIGZvciAke2FmbG9zc2VyLmZpcnN0X25hbWV9YClcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHZhc3RlIGRpZW5zdCByZWNvcmQ6JywgZXJyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjYWxjdWxhdGUgd29yayBkYXlzIGZyb20gdHJpcCBkYXRhXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlV29ya0RheXMoc3RhcnREYXRlOiBzdHJpbmcsIHN0YXJ0VGltZTogc3RyaW5nLCBlbmREYXRlOiBzdHJpbmcsIGVuZFRpbWU6IHN0cmluZyk6IG51bWJlciB7XG4gIGlmICghc3RhcnREYXRlIHx8ICFlbmREYXRlKSByZXR1cm4gMFxuXG4gIC8vIFBhcnNlIGJvdGggREQtTU0tWVlZWSBhbmQgSVNPIGZvcm1hdCBkYXRlc1xuICBjb25zdCBwYXJzZURhdGUgPSAoZGF0ZVN0cjogc3RyaW5nKTogRGF0ZSA9PiB7XG4gICAgaWYgKCFkYXRlU3RyIHx8IHR5cGVvZiBkYXRlU3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBkYXRlIHN0cmluZzonLCBkYXRlU3RyKVxuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkgLy8gUmV0dXJuIGN1cnJlbnQgZGF0ZSBhcyBmYWxsYmFja1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiBpdCdzIGFscmVhZHkgYW4gSVNPIGRhdGUgKGNvbnRhaW5zIFQgb3IgaGFzIDQtZGlnaXQgeWVhciBhdCBzdGFydClcbiAgICBpZiAoZGF0ZVN0ci5pbmNsdWRlcygnVCcpIHx8IC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0vLnRlc3QoZGF0ZVN0cikpIHtcbiAgICAgIC8vIEl0J3MgYWxyZWFkeSBhbiBJU08gZGF0ZSwgdXNlIGl0IGRpcmVjdGx5XG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoZGF0ZVN0cilcbiAgICAgIGlmIChpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBJU08gZGF0ZTonLCBkYXRlU3RyKVxuICAgICAgICByZXR1cm4gbmV3IERhdGUoKSAvLyBSZXR1cm4gY3VycmVudCBkYXRlIGFzIGZhbGxiYWNrXG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0ZVxuICAgIH1cbiAgICBcbiAgICAvLyBPdGhlcndpc2UsIHBhcnNlIGFzIERELU1NLVlZWVkgZm9ybWF0XG4gICAgY29uc3QgcGFydHMgPSBkYXRlU3RyLnNwbGl0KCctJylcbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSAzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGRhdGUgZm9ybWF0OicsIGRhdGVTdHIpXG4gICAgICByZXR1cm4gbmV3IERhdGUoKSAvLyBSZXR1cm4gY3VycmVudCBkYXRlIGFzIGZhbGxiYWNrXG4gICAgfVxuICAgIFxuICAgIGNvbnN0IFtkYXksIG1vbnRoLCB5ZWFyXSA9IHBhcnRzXG4gICAgY29uc3QgaXNvRGF0ZSA9IGAke3llYXJ9LSR7bW9udGgucGFkU3RhcnQoMiwgJzAnKX0tJHtkYXkucGFkU3RhcnQoMiwgJzAnKX1gXG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGlzb0RhdGUpXG4gICAgXG4gICAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBkYXRlIGFmdGVyIHBhcnNpbmc6JywgaXNvRGF0ZSwgJ2Zyb206JywgZGF0ZVN0cilcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpIC8vIFJldHVybiBjdXJyZW50IGRhdGUgYXMgZmFsbGJhY2tcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGRhdGVcbiAgfVxuXG4gIGNvbnN0IHN0YXJ0ID0gcGFyc2VEYXRlKHN0YXJ0RGF0ZSlcbiAgY29uc3QgZW5kID0gcGFyc2VEYXRlKGVuZERhdGUpXG5cbiAgLy8gVmFsaWRhdGllOiBhZnN0YXBkYXR1bSBtYWcgbmlldCB2b29yIGluc3RhcGRhdHVtIGxpZ2dlblxuICBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvcjogZW5kIGRhdGUgaXMgYmVmb3JlIHN0YXJ0IGRhdGUnKVxuICAgIHJldHVybiAwXG4gIH1cblxuICAvLyBTaW1wZWxlIHRlbGxpbmc6IHRlbCBrYWxlbmRlcmRhZ2VuIHZhbiBzdGFydCB0b3QgZWluZCAoaW5jbHVzaWVmIGJlaWRlKVxuICBjb25zdCB0aW1lRGlmZiA9IGVuZC5nZXRUaW1lKCkgLSBzdGFydC5nZXRUaW1lKClcbiAgY29uc3QgZGF5c0RpZmYgPSBNYXRoLmNlaWwodGltZURpZmYgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpICsgMSAvLyArMSBvbWRhdCB3ZSBiZWlkZSBkYXR1bXMgaW5jbHVzaWVmIHRlbGxlblxuXG5cbiAgcmV0dXJuIGRheXNEaWZmXG59XG5cbi8vIEZ1bmN0aW9uIHRvIGF1dG8tdXBkYXRlIHZhc3RlIGRpZW5zdCByZWNvcmRzIHdoZW4gYSB0cmlwIGlzIGNvbXBsZXRlZFxuYXN5bmMgZnVuY3Rpb24gYXV0b1VwZGF0ZVZhc3RlRGllbnN0RnJvbVRyaXAoY29tcGxldGVkVHJpcDogYW55KSB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coYPCflIQgQXV0by11cGRhdGluZyB2YXN0ZSBkaWVuc3QgZm9yIGNvbXBsZXRlZCB0cmlwOiAke2NvbXBsZXRlZFRyaXAuaWR9YClcbiAgICBjb25zb2xlLmxvZyhg8J+UhCBUcmlwIGRhdGE6YCwgY29tcGxldGVkVHJpcClcbiAgICBcbiAgICAvLyBHZXQgdGhlIGFmbG9zc2VyXG4gICAgY29uc3QgeyBkYXRhOiBhZmxvc3NlciwgZXJyb3I6IGFmbG9zc2VyRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY3JldycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgnaWQnLCBjb21wbGV0ZWRUcmlwLmFmbG9zc2VyX2lkKVxuICAgICAgLnNpbmdsZSgpXG4gICAgXG4gICAgaWYgKGFmbG9zc2VyRXJyb3IgfHwgIWFmbG9zc2VyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBhZmxvc3NlcjonLCBhZmxvc3NlckVycm9yKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIGFmbG9zc2VyIGlzIGluIHZhc3RlIGRpZW5zdFxuICAgIGlmICghYWZsb3NzZXIudmFzdGVfZGllbnN0KSB7XG4gICAgICBjb25zb2xlLmxvZygnQWZsb3NzZXIgaXMgbm90IGluIHZhc3RlIGRpZW5zdCwgc2tpcHBpbmcgYXV0by11cGRhdGUnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIFxuICAgIC8vIEdldCB0aGUgbW9udGgveWVhciBvZiB0aGUgdHJpcCBjb21wbGV0aW9uXG4gICAgLy8gUGFyc2UgdGhlIGRhdGUgdXNpbmcgb3VyIHNhZmUgcGFyc2VEYXRlIGZ1bmN0aW9uXG4gICAgY29uc3QgcGFyc2VEYXRlID0gKGRhdGVTdHI6IHN0cmluZyk6IERhdGUgPT4ge1xuICAgICAgaWYgKCFkYXRlU3RyIHx8IHR5cGVvZiBkYXRlU3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGRhdGUgc3RyaW5nOicsIGRhdGVTdHIpXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIGl0J3MgYWxyZWFkeSBhbiBJU08gZGF0ZSAoY29udGFpbnMgVCBvciBoYXMgNC1kaWdpdCB5ZWFyIGF0IHN0YXJ0KVxuICAgICAgaWYgKGRhdGVTdHIuaW5jbHVkZXMoJ1QnKSB8fCAvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9Ly50ZXN0KGRhdGVTdHIpKSB7XG4gICAgICAgIC8vIEl0J3MgYWxyZWFkeSBhbiBJU08gZGF0ZSwgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShkYXRlU3RyKVxuICAgICAgICBpZiAoaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBJU08gZGF0ZTonLCBkYXRlU3RyKVxuICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gT3RoZXJ3aXNlLCBwYXJzZSBhcyBERC1NTS1ZWVlZIGZvcm1hdFxuICAgICAgY29uc3QgcGFydHMgPSBkYXRlU3RyLnNwbGl0KCctJylcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBkYXRlIGZvcm1hdDonLCBkYXRlU3RyKVxuICAgICAgICByZXR1cm4gbmV3IERhdGUoKVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBbZGF5LCBtb250aCwgeWVhcl0gPSBwYXJ0c1xuICAgICAgY29uc3QgaXNvRGF0ZSA9IGAke3llYXJ9LSR7bW9udGgucGFkU3RhcnQoMiwgJzAnKX0tJHtkYXkucGFkU3RhcnQoMiwgJzAnKX1gXG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoaXNvRGF0ZSlcbiAgICAgIFxuICAgICAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGRhdGUgYWZ0ZXIgcGFyc2luZzonLCBpc29EYXRlLCAnZnJvbTonLCBkYXRlU3RyKVxuICAgICAgICByZXR1cm4gbmV3IERhdGUoKVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gZGF0ZVxuICAgIH1cbiAgICBcbiAgICBjb25zdCBlbmREYXRlID0gcGFyc2VEYXRlKGNvbXBsZXRlZFRyaXAuZWluZF9kYXR1bSlcbiAgICBjb25zdCB5ZWFyID0gZW5kRGF0ZS5nZXRGdWxsWWVhcigpXG4gICAgY29uc3QgbW9udGggPSBlbmREYXRlLmdldE1vbnRoKCkgKyAxXG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgbW9udGhseSByZWNvcmQgZXhpc3RzXG4gICAgY29uc3QgeyBkYXRhOiBleGlzdGluZ1JlY29yZCwgZXJyb3I6IHJlY29yZEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3Zhc3RlX2RpZW5zdF9yZWNvcmRzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdhZmxvc3Nlcl9pZCcsIGNvbXBsZXRlZFRyaXAuYWZsb3NzZXJfaWQpXG4gICAgICAuZXEoJ3llYXInLCB5ZWFyKVxuICAgICAgLmVxKCdtb250aCcsIG1vbnRoKVxuICAgICAgLnNpbmdsZSgpXG4gICAgXG4gICAgaWYgKHJlY29yZEVycm9yICYmIHJlY29yZEVycm9yLmNvZGUgIT09ICdQR1JTVDExNicpIHsgLy8gUEdSU1QxMTYgPSBubyByb3dzIGZvdW5kXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB2YXN0ZSBkaWVuc3QgcmVjb3JkOicsIHJlY29yZEVycm9yKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIFxuICAgIGxldCByZWNvcmRJZCA9IGV4aXN0aW5nUmVjb3JkPy5pZFxuICAgIFxuICAgIC8vIENyZWF0ZSByZWNvcmQgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgIGlmICghZXhpc3RpbmdSZWNvcmQpIHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OFIENyZWF0aW5nIG5ldyBtb250aGx5IHJlY29yZCBmb3IgJHthZmxvc3Nlci5maXJzdF9uYW1lfSAke2FmbG9zc2VyLmxhc3RfbmFtZX1gKVxuICAgICAgXG4gICAgICBjb25zdCBuZXdSZWNvcmQgPSB7XG4gICAgICAgIGFmbG9zc2VyX2lkOiBjb21wbGV0ZWRUcmlwLmFmbG9zc2VyX2lkLFxuICAgICAgICB5ZWFyOiB5ZWFyLFxuICAgICAgICBtb250aDogbW9udGgsXG4gICAgICAgIHJlcXVpcmVkX2RheXM6IDE1LFxuICAgICAgICBhY3R1YWxfZGF5czogMCxcbiAgICAgICAgYmFsYW5jZV9kYXlzOiAwLFxuICAgICAgICBub3RlczogYEF1dG9tYXRpc2NoIGFhbmdlbWFha3Qgdm9vciAke3llYXJ9LSR7bW9udGh9YFxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGE6IGNyZWF0ZWRSZWNvcmQsIGVycm9yOiBjcmVhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Zhc3RlX2RpZW5zdF9yZWNvcmRzJylcbiAgICAgICAgLmluc2VydChbbmV3UmVjb3JkXSlcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKVxuICAgICAgXG4gICAgICBpZiAoY3JlYXRlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgdmFzdGUgZGllbnN0IHJlY29yZDonLCBjcmVhdGVFcnJvcilcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBcbiAgICAgIHJlY29yZElkID0gY3JlYXRlZFJlY29yZC5pZFxuICAgIH1cbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgd29yayBkYXlzIGZvciB0aGlzIHRyaXBcbiAgICBjb25zdCB3b3JrRGF5cyA9IGNhbGN1bGF0ZVdvcmtEYXlzKFxuICAgICAgY29tcGxldGVkVHJpcC5zdGFydF9kYXR1bSwgXG4gICAgICBjb21wbGV0ZWRUcmlwLnN0YXJ0X3RpamQsIFxuICAgICAgY29tcGxldGVkVHJpcC5laW5kX2RhdHVtLCBcbiAgICAgIGNvbXBsZXRlZFRyaXAuZWluZF90aWpkXG4gICAgKVxuICAgIFxuICAgIC8vIEdldCBhbGwgY29tcGxldGVkIHRyaXBzIGZvciB0aGlzIG1vbnRoIHRvIGNhbGN1bGF0ZSB0b3RhbFxuICAgIGNvbnN0IHsgZGF0YTogYWxsVHJpcHMsIGVycm9yOiB0cmlwc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3RyaXBzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdhZmxvc3Nlcl9pZCcsIGNvbXBsZXRlZFRyaXAuYWZsb3NzZXJfaWQpXG4gICAgICAuZXEoJ3N0YXR1cycsICd2b2x0b29pZCcpXG4gICAgICAubm90KCdlaW5kX2RhdHVtJywgJ2lzJywgbnVsbClcbiAgICBcbiAgICBpZiAodHJpcHNFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdHJpcHM6JywgdHJpcHNFcnJvcilcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgdG90YWwgd29yayBkYXlzIGZvciB0aGUgbW9udGhcbiAgICBsZXQgdG90YWxXb3JrRGF5cyA9IDBcbiAgICBmb3IgKGNvbnN0IHRyaXAgb2YgYWxsVHJpcHMgfHwgW10pIHtcbiAgICAgIGNvbnN0IHRyaXBFbmREYXRlID0gcGFyc2VEYXRlKHRyaXAuZWluZF9kYXR1bSlcbiAgICAgIGlmICh0cmlwRW5kRGF0ZS5nZXRGdWxsWWVhcigpID09PSB5ZWFyICYmIHRyaXBFbmREYXRlLmdldE1vbnRoKCkgKyAxID09PSBtb250aCkge1xuICAgICAgICBjb25zdCB0cmlwV29ya0RheXMgPSBjYWxjdWxhdGVXb3JrRGF5cyh0cmlwLnN0YXJ0X2RhdHVtLCB0cmlwLnN0YXJ0X3RpamQsIHRyaXAuZWluZF9kYXR1bSwgdHJpcC5laW5kX3RpamQpXG4gICAgICAgIHRvdGFsV29ya0RheXMgKz0gdHJpcFdvcmtEYXlzXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSB0aGUgcmVjb3JkXG4gICAgY29uc3QgcmVxdWlyZWREYXlzID0gMTVcbiAgICBcbiAgICAvLyBDT1JSRUNURSBCRVJFS0VOSU5HOiBFaW5kc2FsZG8gPSBCZWdpbnNhbGRvICsgKEdld2Vya3QgLSAxNSlcbiAgICAvLyBWb29yIGVlcnN0ZSBtYWFuZDogQmVnaW5zYWxkbyA9IC0xNSArIHN0YXJ0c2FsZG9cbiAgICBsZXQgYmVnaW5zYWxkbyA9IDBcbiAgICBcbiAgICAvLyBQcm9iZWVyIHN0YXJ0c2FsZG8gdWl0IG5vdGVzIHRlIGhhbGVuIHZvb3IgbmlldXdlIGFmbG9zc2Vyc1xuICAgIGNvbnN0IHN0YXJ0c2FsZG9Ob3RlID0gYWZsb3NzZXIubm90ZXM/LmZpbmQoKG5vdGU6IGFueSkgPT4gXG4gICAgICBub3RlLnRleHQgJiYgKG5vdGUudGV4dC5pbmNsdWRlcygnc3RhcnRzYWxkbycpIHx8IG5vdGUudGV4dC5pbmNsdWRlcygnU3RhcnRzYWxkbycpKVxuICAgIClcbiAgICBpZiAoc3RhcnRzYWxkb05vdGUpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gc3RhcnRzYWxkb05vdGUudGV4dC5tYXRjaCgvKC0/XFxkKyg/OlxcLlxcZCspPykvKVxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0c2FsZG8gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKVxuICAgICAgICBiZWdpbnNhbGRvID0gLTE1ICsgc3RhcnRzYWxkb1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiBOaWV1d2UgYWZsb3NzZXI6IHN0YXJ0c2FsZG8gJHtzdGFydHNhbGRvfSwgYmVnaW5zYWxkbyAke2JlZ2luc2FsZG99YClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJlZ2luc2FsZG8gPT09IDApIGJlZ2luc2FsZG8gPSAtMTUgLy8gRmFsbGJhY2tcbiAgICBcbiAgICAvLyBWb29yIGRlIGVlcnN0ZSBtYWFuZDogdG9vbiBoZXQgYmVnaW5zYWxkbyBhbHMgaHVpZGlnIHNhbGRvXG4gICAgLy8gVm9vciB2b2xnZW5kZSBtYWFuZGVuOiBiZXJla2VuIGhldCBlaW5kc2FsZG9cbiAgICBsZXQgYmFsYW5jZURheXNcbiAgICBpZiAobW9udGggPT09IDEgJiYgYmVnaW5zYWxkbyAhPT0gLTE1KSB7XG4gICAgICAvLyBFZXJzdGUgbWFhbmQgbWV0IHN0YXJ0c2FsZG86IHRvb24gYmVnaW5zYWxkb1xuICAgICAgYmFsYW5jZURheXMgPSBiZWdpbnNhbGRvXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vcm1hbGUgYmVyZWtlbmluZzogYmVnaW5zYWxkbyArIChnZXdlcmt0IC0gMTUpXG4gICAgICBiYWxhbmNlRGF5cyA9IGJlZ2luc2FsZG8gKyAodG90YWxXb3JrRGF5cyAtIHJlcXVpcmVkRGF5cylcbiAgICB9XG4gICAgXG4gICAgLy8gQ2FwIHZhbHVlcyB0byBmaXQgaW4gREVDSU1BTCg0LDEpIC0gbWF4IDk5OS45XG4gICAgY29uc3QgY2FwcGVkQWN0dWFsRGF5cyA9IE1hdGgubWluKHRvdGFsV29ya0RheXMsIDk5OS45KVxuICAgIGNvbnN0IGNhcHBlZEJhbGFuY2VEYXlzID0gTWF0aC5taW4oTWF0aC5tYXgoYmFsYW5jZURheXMsIC05OTkuOSksIDk5OS45KVxuICAgIFxuICAgIGNvbnN0IHsgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3Zhc3RlX2RpZW5zdF9yZWNvcmRzJylcbiAgICAgIC51cGRhdGUoe1xuICAgICAgICBhY3R1YWxfZGF5czogY2FwcGVkQWN0dWFsRGF5cyxcbiAgICAgICAgYmFsYW5jZV9kYXlzOiBjYXBwZWRCYWxhbmNlRGF5c1xuICAgICAgfSlcbiAgICAgIC5lcSgnaWQnLCByZWNvcmRJZClcbiAgICBcbiAgICBpZiAodXBkYXRlRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciB1cGRhdGluZyB2YXN0ZSBkaWVuc3QgcmVjb3JkOicsIHVwZGF0ZUVycm9yKVxuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGRldGFpbHM6JywgSlNPTi5zdHJpbmdpZnkodXBkYXRlRXJyb3IsIG51bGwsIDIpKVxuICAgICAgY29uc29sZS5lcnJvcign4p2MIFJlY29yZCBkYXRhOicsIHsgaWQ6IHJlY29yZElkLCBhY3R1YWxfZGF5czogdG90YWxXb3JrRGF5cywgYmFsYW5jZV9kYXlzOiBiYWxhbmNlRGF5cyB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFVwZGF0ZWQgdmFzdGUgZGllbnN0IHJlY29yZCBmb3IgJHthZmxvc3Nlci5maXJzdF9uYW1lfTogJHt0b3RhbFdvcmtEYXlzfSBkYXlzIChiYWxhbmNlOiAke2JhbGFuY2VEYXlzfSlgKVxuICAgIH1cbiAgICBcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gYXV0by11cGRhdGUgdmFzdGUgZGllbnN0OicsIGVycilcbiAgfVxufVxuXG4vLyBGdW5jdGlvbiB0byBmb3JjZSByZWNhbGN1bGF0ZSBhbGwgdmFzdGUgZGllbnN0IHJlY29yZHMgd2l0aCBuZXcgbG9naWNcbmFzeW5jIGZ1bmN0aW9uIGZvcmNlUmVjYWxjdWxhdGVBbGxWYXN0ZURpZW5zdFJlY29yZHMoY3Jld0RhdGE6IGFueVtdLCB0cmlwc0RhdGE6IGFueVtdKSB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ/CflIQgRm9yY2UgcmVjYWxjdWxhdGluZyBhbGwgdmFzdGUgZGllbnN0IHJlY29yZHMuLi4nKVxuICAgIGNvbnNvbGUubG9nKGDwn5OKIENyZXcgZGF0YTogJHtjcmV3RGF0YS5sZW5ndGh9IG1lbWJlcnNgKVxuICAgIGNvbnNvbGUubG9nKGDwn5OKIFRyaXBzIGRhdGE6ICR7dHJpcHNEYXRhLmxlbmd0aH0gdHJpcHNgKVxuICAgIFxuICAgIC8vIEdldCBhbGwgdmFzdGUgZGllbnN0IHJlY29yZHNcbiAgICBjb25zdCB7IGRhdGE6IGFsbFJlY29yZHMsIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3Zhc3RlX2RpZW5zdF9yZWNvcmRzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgIFxuICAgIGlmIChmZXRjaEVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZmV0Y2hpbmcgdmFzdGUgZGllbnN0IHJlY29yZHM6JywgZmV0Y2hFcnJvcilcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBcbiAgICBpZiAoIWFsbFJlY29yZHMgfHwgYWxsUmVjb3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gTm8gdmFzdGUgZGllbnN0IHJlY29yZHMgZm91bmQgdG8gcmVjYWxjdWxhdGUnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn5OLIEZvdW5kICR7YWxsUmVjb3Jkcy5sZW5ndGh9IHJlY29yZHMgdG8gcmVjYWxjdWxhdGVgKVxuICAgIFxuICAgIC8vIFByb2Nlc3MgZWFjaCByZWNvcmRcbiAgICBmb3IgKGNvbnN0IHJlY29yZCBvZiBhbGxSZWNvcmRzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZyhgXFxu8J+UjSBQcm9jZXNzaW5nIHJlY29yZCAke3JlY29yZC5pZH0gZm9yIGFmbG9zc2VyICR7cmVjb3JkLmFmbG9zc2VyX2lkfWApXG4gICAgICAgIFxuICAgICAgICAvLyBGaW5kIHRoZSBhZmxvc3NlclxuICAgICAgICBjb25zdCBhZmxvc3NlciA9IGNyZXdEYXRhLmZpbmQoY3JldyA9PiBjcmV3LmlkID09PSByZWNvcmQuYWZsb3NzZXJfaWQpXG4gICAgICAgIGlmICghYWZsb3NzZXIpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pqg77iPIEFmbG9zc2VyIG5vdCBmb3VuZCBmb3IgcmVjb3JkICR7cmVjb3JkLmlkfWApXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYPCfkaQgRm91bmQgYWZsb3NzZXI6ICR7YWZsb3NzZXIuZmlyc3RfbmFtZX0gJHthZmxvc3Nlci5sYXN0X25hbWV9YClcbiAgICAgICAgXG4gICAgICAgIC8vIEdldCBhbGwgY29tcGxldGVkIHRyaXBzIGZvciB0aGlzIGFmbG9zc2VyXG4gICAgICAgIGNvbnN0IGFsbFRyaXBzID0gdHJpcHNEYXRhLmZpbHRlcigodHJpcDogYW55KSA9PiBcbiAgICAgICAgICB0cmlwLmFmbG9zc2VyX2lkID09PSByZWNvcmQuYWZsb3NzZXJfaWQgJiZcbiAgICAgICAgICB0cmlwLnN0YXR1cyA9PT0gJ3ZvbHRvb2lkJyAmJlxuICAgICAgICAgIHRyaXAuc3RhcnRfZGF0dW0gJiYgdHJpcC5laW5kX2RhdHVtICYmIHRyaXAuc3RhcnRfdGlqZCAmJiB0cmlwLmVpbmRfdGlqZFxuICAgICAgICApXG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhg8J+aoiBGb3VuZCAke2FsbFRyaXBzLmxlbmd0aH0gY29tcGxldGVkIHRyaXBzIGZvciB0aGlzIGFmbG9zc2VyYClcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0b3RhbCB3b3JrIGRheXMgd2l0aCBuZXcgbG9naWNcbiAgICAgICAgbGV0IHRvdGFsV29ya0RheXMgPSAwXG4gICAgICAgIGZvciAoY29uc3QgdHJpcCBvZiBhbGxUcmlwcykge1xuICAgICAgICAgIGNvbnN0IHdvcmtEYXlzID0gY2FsY3VsYXRlV29ya0RheXModHJpcC5zdGFydF9kYXR1bSwgdHJpcC5zdGFydF90aWpkLCB0cmlwLmVpbmRfZGF0dW0sIHRyaXAuZWluZF90aWpkKVxuICAgICAgICAgIGNvbnNvbGUubG9nKGAgIPCfk4UgVHJpcCAke3RyaXAuaWR9OiAke3RyaXAuc3RhcnRfZGF0dW19IHRvICR7dHJpcC5laW5kX2RhdHVtfSA9ICR7d29ya0RheXN9IGRheXNgKVxuICAgICAgICAgIHRvdGFsV29ya0RheXMgKz0gd29ya0RheXNcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYPCfk4ogVG90YWwgd29yayBkYXlzIGNhbGN1bGF0ZWQ6ICR7dG90YWxXb3JrRGF5c31gKVxuICAgICAgICBcbiAgICAgICAgLy8gQ2FwIHZhbHVlcyB0byBmaXQgaW4gREVDSU1BTCg0LDEpXG4gICAgICAgIGNvbnN0IHJlcXVpcmVkRGF5cyA9IDE1XG4gICAgICAgIFxuICAgICAgICAvLyBDT1JSRUNURSBCRVJFS0VOSU5HOiBFaW5kc2FsZG8gPSBCZWdpbnNhbGRvICsgKEdld2Vya3QgLSAxNSlcbiAgICAgICAgLy8gVm9vciBlZXJzdGUgbWFhbmQ6IEJlZ2luc2FsZG8gPSAtMTUgKyBzdGFydHNhbGRvXG4gICAgICAgIGxldCBiZWdpbnNhbGRvID0gcmVjb3JkLmJhbGFuY2VfZGF5cyB8fCAwXG4gICAgICAgIFxuICAgICAgICAvLyBBbHMgZGl0IGRlIGVlcnN0ZSBtYWFuZCBpcyBlbiBlciBpcyBnZWVuIGJlZ2luc2FsZG8sIGdlYnJ1aWsgLTE1ICsgc3RhcnRzYWxkb1xuICAgICAgICBpZiAoYmVnaW5zYWxkbyA9PT0gMCAmJiByZWNvcmQubW9udGggPT09IDEpIHtcbiAgICAgICAgICAvLyBQcm9iZWVyIHN0YXJ0c2FsZG8gdWl0IG5vdGVzIHRlIGhhbGVuXG4gICAgICAgICAgY29uc3Qgc3RhcnRzYWxkb05vdGUgPSBhZmxvc3Nlci5ub3Rlcz8uZmluZCgobm90ZTogYW55KSA9PiBcbiAgICAgICAgICAgIG5vdGUudGV4dCAmJiAobm90ZS50ZXh0LmluY2x1ZGVzKCdzdGFydHNhbGRvJykgfHwgbm90ZS50ZXh0LmluY2x1ZGVzKCdTdGFydHNhbGRvJykpXG4gICAgICAgICAgKVxuICAgICAgICAgIGlmIChzdGFydHNhbGRvTm90ZSkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBzdGFydHNhbGRvTm90ZS50ZXh0Lm1hdGNoKC8oLT9cXGQrKD86XFwuXFxkKyk/KS8pXG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3RhcnRzYWxkbyA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pXG4gICAgICAgICAgICAgIGJlZ2luc2FsZG8gPSAtMTUgKyBzdGFydHNhbGRvXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OKIEVlcnN0ZSBtYWFuZCBoZXJiZXJla2VuaW5nOiBzdGFydHNhbGRvICR7c3RhcnRzYWxkb30sIGJlZ2luc2FsZG8gJHtiZWdpbnNhbGRvfWApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiZWdpbnNhbGRvID09PSAwKSBiZWdpbnNhbGRvID0gLTE1IC8vIEZhbGxiYWNrXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFZvb3IgZGUgZWVyc3RlIG1hYW5kOiB0b29uIGhldCBiZWdpbnNhbGRvIGFscyBodWlkaWcgc2FsZG9cbiAgICAgICAgLy8gVm9vciB2b2xnZW5kZSBtYWFuZGVuOiBiZXJla2VuIGhldCBlaW5kc2FsZG9cbiAgICAgICAgbGV0IGJhbGFuY2VEYXlzXG4gICAgICAgIGlmIChyZWNvcmQubW9udGggPT09IDEgJiYgYmVnaW5zYWxkbyAhPT0gLTE1KSB7XG4gICAgICAgICAgLy8gRWVyc3RlIG1hYW5kIG1ldCBzdGFydHNhbGRvOiB0b29uIGJlZ2luc2FsZG9cbiAgICAgICAgICBiYWxhbmNlRGF5cyA9IGJlZ2luc2FsZG9cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOb3JtYWxlIGJlcmVrZW5pbmc6IGJlZ2luc2FsZG8gKyAoZ2V3ZXJrdCAtIDE1KVxuICAgICAgICAgIGJhbGFuY2VEYXlzID0gYmVnaW5zYWxkbyArICh0b3RhbFdvcmtEYXlzIC0gcmVxdWlyZWREYXlzKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhcHBlZEFjdHVhbERheXMgPSBNYXRoLm1pbih0b3RhbFdvcmtEYXlzLCA5OTkuOSlcbiAgICAgICAgY29uc3QgY2FwcGVkQmFsYW5jZURheXMgPSBNYXRoLm1pbihNYXRoLm1heChiYWxhbmNlRGF5cywgLTk5OS45KSwgOTk5LjkpXG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhg8J+SviBVcGRhdGluZyByZWNvcmQ6IGFjdHVhbD0ke2NhcHBlZEFjdHVhbERheXN9LCBiYWxhbmNlPSR7Y2FwcGVkQmFsYW5jZURheXN9YClcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVjb3JkXG4gICAgICAgIGNvbnN0IHsgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCd2YXN0ZV9kaWVuc3RfcmVjb3JkcycpXG4gICAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgICBhY3R1YWxfZGF5czogY2FwcGVkQWN0dWFsRGF5cyxcbiAgICAgICAgICAgIGJhbGFuY2VfZGF5czogY2FwcGVkQmFsYW5jZURheXNcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5lcSgnaWQnLCByZWNvcmQuaWQpXG4gICAgICAgIFxuICAgICAgICBpZiAodXBkYXRlRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGDinYwgRXJyb3IgdXBkYXRpbmcgcmVjb3JkICR7cmVjb3JkLmlkfTpgLCB1cGRhdGVFcnJvcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFN1Y2Nlc3NmdWxseSB1cGRhdGVkIHJlY29yZCBmb3IgJHthZmxvc3Nlci5maXJzdF9uYW1lfTogJHtjYXBwZWRBY3R1YWxEYXlzfSBkYXlzIChiYWxhbmNlOiAke2NhcHBlZEJhbGFuY2VEYXlzfSlgKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBFcnJvciBwcm9jZXNzaW5nIHJlY29yZCAke3JlY29yZC5pZH06YCwgZXJyKVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZygn8J+OiSBGb3JjZSByZWNhbGN1bGF0aW9uIGNvbXBsZXRlZCEnKVxuICAgIFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgaW4gZm9yY2UgcmVjYWxjdWxhdGU6JywgZXJyKVxuICB9XG59XG5cbi8vIEZ1bmN0aW9uIHRvIHJlc2V0IGFsbCB2YXN0ZSBkaWVuc3QgcmVjb3JkcyB0byAwXG5hc3luYyBmdW5jdGlvbiByZXNldEFsbFZhc3RlRGllbnN0UmVjb3JkcygpIHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygn8J+nuSBSZXNldHRpbmcgYWxsIHZhc3RlIGRpZW5zdCByZWNvcmRzIHRvIDAuLi4nKVxuICAgIFxuICAgIC8vIEdldCBhbGwgdmFzdGUgZGllbnN0IHJlY29yZHNcbiAgICBjb25zdCB7IGRhdGE6IGFsbFJlY29yZHMsIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3Zhc3RlX2RpZW5zdF9yZWNvcmRzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgIFxuICAgIGlmIChmZXRjaEVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB2YXN0ZSBkaWVuc3QgcmVjb3JkcyBmb3IgcmVzZXQ6JywgZmV0Y2hFcnJvcilcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBcbiAgICBpZiAoIWFsbFJlY29yZHMgfHwgYWxsUmVjb3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCdObyB2YXN0ZSBkaWVuc3QgcmVjb3JkcyBmb3VuZCB0byByZXNldCcpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYEZvdW5kICR7YWxsUmVjb3Jkcy5sZW5ndGh9IHJlY29yZHMgdG8gcmVzZXRgKVxuICAgIFxuICAgIC8vIFJlc2V0IGVhY2ggcmVjb3JkIHRvIDBcbiAgICBmb3IgKGNvbnN0IHJlY29yZCBvZiBhbGxSZWNvcmRzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgndmFzdGVfZGllbnN0X3JlY29yZHMnKVxuICAgICAgICAgIC51cGRhdGUoe1xuICAgICAgICAgICAgYWN0dWFsX2RheXM6IDAsXG4gICAgICAgICAgICBiYWxhbmNlX2RheXM6IC0xNSAvLyAtMTUgYmVjYXVzZSByZXF1aXJlZF9kYXlzIGlzIDE1XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZXEoJ2lkJywgcmVjb3JkLmlkKVxuICAgICAgICBcbiAgICAgICAgaWYgKHVwZGF0ZUVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihg4p2MIEVycm9yIHJlc2V0dGluZyByZWNvcmQgJHtyZWNvcmQuaWR9OmAsIHVwZGF0ZUVycm9yKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgUmVzZXQgcmVjb3JkICR7cmVjb3JkLmlkfSB0byAwYClcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciByZXNldHRpbmcgcmVjb3JkICR7cmVjb3JkLmlkfTpgLCBlcnIpXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCfwn46JIFJlc2V0IGNvbXBsZXRlZCEnKVxuICAgIFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiByZXNldCBhbGwgcmVjb3JkczonLCBlcnIpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVN1cGFiYXNlRGF0YSgpIHtcbiAgY29uc3QgW3NoaXBzLCBzZXRTaGlwc10gPSB1c2VTdGF0ZTxhbnlbXT4oW10pXG4gIGNvbnN0IFtjcmV3LCBzZXRDcmV3XSA9IHVzZVN0YXRlPGFueVtdPihbXSlcbiAgY29uc3QgW3NpY2tMZWF2ZSwgc2V0U2lja0xlYXZlXSA9IHVzZVN0YXRlPGFueVtdPihbXSlcbiAgY29uc3QgW3N0YW5kQmFja1JlY29yZHMsIHNldFN0YW5kQmFja1JlY29yZHNdID0gdXNlU3RhdGU8YW55W10+KFtdKVxuICBjb25zdCBbbG9hbnMsIHNldExvYW5zXSA9IHVzZVN0YXRlPGFueVtdPihbXSlcbiAgY29uc3QgW3RyaXBzLCBzZXRUcmlwc10gPSB1c2VTdGF0ZTxhbnlbXT4oW10pXG4gIGNvbnN0IFt2YXN0ZURpZW5zdFJlY29yZHMsIHNldFZhc3RlRGllbnN0UmVjb3Jkc10gPSB1c2VTdGF0ZTxhbnlbXT4oW10pXG4gIGNvbnN0IFt0YXNrcywgc2V0VGFza3NdID0gdXNlU3RhdGU8YW55W10+KFtdKVxuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKVxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpXG4gIGNvbnN0IFtjcmV3Q29sb3JUYWdzLCBzZXRDcmV3Q29sb3JUYWdzXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIHN0cmluZz4+KHt9KVxuXG4gIC8vIExvYWQgYWxsIGRhdGEgZnJvbSBTdXBhYmFzZVxuICBjb25zdCBsb2FkRGF0YSA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgc2V0TG9hZGluZyh0cnVlKVxuICAgICAgc2V0RXJyb3IobnVsbClcbiAgICAgIGNvbnNvbGUubG9nKCdMb2FkaW5nIGRhdGEgZnJvbSBTdXBhYmFzZS4uLicpXG5cbiAgICAgIC8vIENoZWNrIGlmIHVzZXIgaXMgYXV0aGVudGljYXRlZFxuICAgICAgY29uc3QgeyBkYXRhOiB7IHNlc3Npb24gfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRTZXNzaW9uKClcbiAgICAgIGNvbnNvbGUubG9nKCdDdXJyZW50IHNlc3Npb246Jywgc2Vzc2lvbiA/ICdVc2VyIGxvZ2dlZCBpbicgOiAnTm8gdXNlciBzZXNzaW9uJylcbiAgICAgIFxuICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignTm8gYWN0aXZlIHNlc3Npb24gLSB1c2VyIG5lZWRzIHRvIGxvZ2luJylcbiAgICAgICAgc2V0U2hpcHMoW10pXG4gICAgICAgIHNldENyZXcoW10pXG4gICAgICAgIHNldFNpY2tMZWF2ZShbXSlcbiAgICAgICAgc2V0U3RhbmRCYWNrUmVjb3JkcyhbXSlcbiAgICAgICAgc2V0TG9hbnMoW10pXG4gICAgICAgIHNldFRyaXBzKFtdKVxuICAgICAgICBzZXRWYXN0ZURpZW5zdFJlY29yZHMoW10pXG4gICAgICAgIHNldFRhc2tzKFtdKVxuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gVGVzdCBTdXBhYmFzZSBjb25uZWN0aW9uXG4gICAgICBjb25zb2xlLmxvZygnVGVzdGluZyBTdXBhYmFzZSBjb25uZWN0aW9uLi4uJylcbiAgICAgIGNvbnN0IHsgZGF0YTogdGVzdERhdGEsIGVycm9yOiB0ZXN0RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdzaWNrX2xlYXZlJylcbiAgICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgICAubGltaXQoMSlcbiAgICAgIFxuICAgICAgaWYgKHRlc3RFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBjb25uZWN0aW9uIHRlc3QgZmFpbGVkOicsIHRlc3RFcnJvcilcbiAgICAgICAgY29uc29sZS5lcnJvcignVGVzdCBlcnJvciBkZXRhaWxzOicsIEpTT04uc3RyaW5naWZ5KHRlc3RFcnJvciwgbnVsbCwgMikpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygn4pyFIFN1cGFiYXNlIGNvbm5lY3Rpb24gdGVzdCBzdWNjZXNzZnVsJylcbiAgICAgIH1cblxuICAgICAgLy8gTG9hZCBzaGlwc1xuICAgICAgY29uc29sZS5sb2coJ0xvYWRpbmcgc2hpcHMuLi4nKVxuICAgICAgY29uc3QgeyBkYXRhOiBzaGlwc0RhdGEsIGVycm9yOiBzaGlwc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnc2hpcHMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLm9yZGVyKCduYW1lJylcblxuICAgICAgaWYgKHNoaXBzRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBzaGlwczonLCBzaGlwc0Vycm9yKVxuICAgICAgICBjb25zb2xlLmVycm9yKCdTaGlwcyBlcnJvciBkZXRhaWxzOicsIEpTT04uc3RyaW5naWZ5KHNoaXBzRXJyb3IsIG51bGwsIDIpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1NoaXBzIGxvYWRlZDonLCBzaGlwc0RhdGE/Lmxlbmd0aCB8fCAwKVxuICAgICAgICBzZXRTaGlwcyhzaGlwc0RhdGEgfHwgW10pXG4gICAgICB9XG5cbiAgICAgIC8vIExvYWQgY3Jld1xuICAgICAgY29uc29sZS5sb2coJ0xvYWRpbmcgY3Jldy4uLicpXG4gICAgICBjb25zdCB7IGRhdGE6IGNyZXdEYXRhLCBlcnJvcjogY3Jld0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnY3JldycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAub3JkZXIoJ2ZpcnN0X25hbWUnKVxuXG4gICAgICBpZiAoY3Jld0Vycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgY3JldzonLCBjcmV3RXJyb3IpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NyZXcgZXJyb3IgZGV0YWlsczonLCBKU09OLnN0cmluZ2lmeShjcmV3RXJyb3IsIG51bGwsIDIpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0NyZXcgbG9hZGVkOicsIGNyZXdEYXRhPy5sZW5ndGggfHwgMClcbiAgICAgICAgXG4gICAgICAgIC8vIFRlbXBvcmFyaWx5IGRpc2FibGUgYXV0by1hY3RpdmF0aW9uIGFuZCByb3RhdGlvbiB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzXG4gICAgICAgIC8vIGF3YWl0IGF1dG9BY3RpdmF0ZUNyZXdNZW1iZXJzKGNyZXdEYXRhIHx8IFtdKVxuICAgICAgICAvLyBhd2FpdCBhdXRvUm90YXRlQ3Jld01lbWJlcnMoY3Jld0RhdGEgfHwgW10pXG4gICAgICAgIFxuICAgICAgICAvLyBTZXQgY3JldyBkYXRhIGRpcmVjdGx5IHdpdGhvdXQgcmVsb2FkaW5nXG4gICAgICAgIHNldENyZXcoY3Jld0RhdGEgfHwgW10pXG4gICAgICB9XG5cbiAgICAgIC8vIExvYWQgc2ljayBsZWF2ZVxuICAgICAgY29uc29sZS5sb2coJ0xvYWRpbmcgc2ljayBsZWF2ZS4uLicpXG4gICAgICBjb25zdCB7IGRhdGE6IHNpY2tMZWF2ZURhdGEsIGVycm9yOiBzaWNrTGVhdmVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3NpY2tfbGVhdmUnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLm9yZGVyKCdzdGFydF9kYXRlJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgICAgIGlmIChzaWNrTGVhdmVFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHNpY2sgbGVhdmU6Jywgc2lja0xlYXZlRXJyb3IpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnU2ljayBsZWF2ZSBsb2FkZWQ6Jywgc2lja0xlYXZlRGF0YT8ubGVuZ3RoIHx8IDApXG4gICAgICAgIHNldFNpY2tMZWF2ZShzaWNrTGVhdmVEYXRhIHx8IFtdKVxuICAgICAgfVxuXG4gICAgICAvLyBMb2FkIHN0YW5kIGJhY2sgcmVjb3Jkc1xuICAgICAgY29uc29sZS5sb2coJ0xvYWRpbmcgc3RhbmQgYmFjayByZWNvcmRzLi4uJylcbiAgICAgIGNvbnN0IHsgZGF0YTogc3RhbmRCYWNrRGF0YSwgZXJyb3I6IHN0YW5kQmFja0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnc3RhbmRfYmFja19yZWNvcmRzJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuXG4gICAgICBpZiAoc3RhbmRCYWNrRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBzdGFuZCBiYWNrIHJlY29yZHM6Jywgc3RhbmRCYWNrRXJyb3IpXG4gICAgICAgIHNldFN0YW5kQmFja1JlY29yZHMoW10pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnU3RhbmQgYmFjayByZWNvcmRzIGxvYWRlZDonLCBzdGFuZEJhY2tEYXRhPy5sZW5ndGggfHwgMClcbiAgICAgICAgc2V0U3RhbmRCYWNrUmVjb3JkcyhzdGFuZEJhY2tEYXRhIHx8IFtdKVxuICAgICAgfVxuXG4gICAgICAvLyBMb2FkIGxvYW5zXG4gICAgICBjb25zb2xlLmxvZygnTG9hZGluZyBsb2Fucy4uLicpXG4gICAgICBjb25zdCB7IGRhdGE6IGxvYW5zRGF0YSwgZXJyb3I6IGxvYW5zRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdsb2FucycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcblxuICAgICAgaWYgKGxvYW5zRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBsb2FuczonLCBsb2Fuc0Vycm9yKVxuICAgICAgICBzZXRMb2FucyhbXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdMb2FucyBsb2FkZWQ6JywgbG9hbnNEYXRhPy5sZW5ndGggfHwgMClcbiAgICAgICAgc2V0TG9hbnMobG9hbnNEYXRhIHx8IFtdKVxuICAgICAgfVxuXG4gICAgICAgICAgICAvLyBMb2FkIHRyaXBzXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTG9hZGluZyB0cmlwcy4uLicpXG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IHRyaXBzRGF0YSwgZXJyb3I6IHRyaXBzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgIC5mcm9tKCd0cmlwcycpXG4gICAgICAgICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcblxuICAgICAgICAgICAgaWYgKHRyaXBzRXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyB0cmlwczonLCB0cmlwc0Vycm9yKVxuICAgICAgICAgICAgICBzZXRUcmlwcyhbXSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUcmlwcyBsb2FkZWQ6JywgdHJpcHNEYXRhPy5sZW5ndGggfHwgMClcbiAgICAgICAgICAgICAgc2V0VHJpcHModHJpcHNEYXRhIHx8IFtdKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBMb2FkIHZhc3RlIGRpZW5zdCByZWNvcmRzXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTG9hZGluZyB2YXN0ZSBkaWVuc3QgcmVjb3Jkcy4uLicpXG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IHZhc3RlRGllbnN0RGF0YSwgZXJyb3I6IHZhc3RlRGllbnN0RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgIC5mcm9tKCd2YXN0ZV9kaWVuc3RfcmVjb3JkcycpXG4gICAgICAgICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAgICAgICAub3JkZXIoJ3llYXInLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgICAgICAgICAgICAgLm9yZGVyKCdtb250aCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuXG4gICAgICAgICAgICBpZiAodmFzdGVEaWVuc3RFcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHZhc3RlIGRpZW5zdCByZWNvcmRzOicsIHZhc3RlRGllbnN0RXJyb3IpXG4gICAgICAgICAgICAgIHNldFZhc3RlRGllbnN0UmVjb3JkcyhbXSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdWYXN0ZSBkaWVuc3QgcmVjb3JkcyBsb2FkZWQ6JywgdmFzdGVEaWVuc3REYXRhPy5sZW5ndGggfHwgMClcbiAgICAgICAgICAgICAgc2V0VmFzdGVEaWVuc3RSZWNvcmRzKHZhc3RlRGllbnN0RGF0YSB8fCBbXSlcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIEF1dG8tbWFuYWdlIHZhc3RlIGRpZW5zdCByZWNvcmRzIGFmdGVyIGxvYWRpbmcgYWxsIGRhdGFcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ/CflKcgQXV0by1tYW5hZ2luZyB2YXN0ZSBkaWVuc3QgcmVjb3Jkcy4uLicpXG4gICAgICAgICAgICAgIGF3YWl0IGF1dG9NYW5hZ2VWYXN0ZURpZW5zdFJlY29yZHMoY3Jld0RhdGEgfHwgW10sIHZhc3RlRGllbnN0RGF0YSB8fCBbXSwgdHJpcHNEYXRhIHx8IFtdKVxuICAgICAgICAgICAgfVxuXG4gICAgICAvLyBMb2FkIHRhc2tzXG4gICAgICBjb25zb2xlLmxvZygnTG9hZGluZyB0YXNrcy4uLicpXG4gICAgICBjb25zdCB7IGRhdGE6IHRhc2tzRGF0YSwgZXJyb3I6IHRhc2tzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd0YXNrcycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcblxuICAgICAgaWYgKHRhc2tzRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyB0YXNrczonLCB0YXNrc0Vycm9yKVxuICAgICAgICBzZXRUYXNrcyhbXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdUYXNrcyBsb2FkZWQ6JywgdGFza3NEYXRhPy5sZW5ndGggfHwgMClcbiAgICAgICAgc2V0VGFza3ModGFza3NEYXRhIHx8IFtdKVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnRGF0YSBsb2FkaW5nIGNvbXBsZXRlZCEnKVxuXG4gICAgICAvLyBMb2FkIGNyZXcgY29sb3IgdGFncyBsYXN0LCBub24tYmxvY2tpbmcgZm9yIG1haW4gZGF0YVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiBjb2xvclJvd3MsIGVycm9yOiBjb2xvckVyciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnY3Jld19jb2xvcl90YWdzJylcbiAgICAgICAgICAuc2VsZWN0KCdjcmV3X2lkLCBjb2xvcicpXG4gICAgICAgIGlmIChjb2xvckVycikge1xuICAgICAgICAgIGNvbnN0IG1zZyA9IChjb2xvckVyciBhcyBhbnkpPy5tZXNzYWdlIHx8IFN0cmluZyhjb2xvckVycilcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1NraXBwaW5nIGNyZXdfY29sb3JfdGFncyAodGFibGUgbWlzc2luZyBvciBubyBhY2Nlc3MpOicsIG1zZylcbiAgICAgICAgICBzZXRDcmV3Q29sb3JUYWdzKHt9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG1hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9XG4gICAgICAgICAgZm9yIChjb25zdCByb3cgb2YgY29sb3JSb3dzIHx8IFtdKSB7XG4gICAgICAgICAgICBpZiAocm93LmNyZXdfaWQgJiYgcm93LmNvbG9yKSBtYXBbcm93LmNyZXdfaWRdID0gcm93LmNvbG9yXG4gICAgICAgICAgfVxuICAgICAgICAgIHNldENyZXdDb2xvclRhZ3MobWFwKVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRXJyb3IgbG9hZGluZyBjcmV3X2NvbG9yX3RhZ3M6JywgKGUgYXMgYW55KT8ubWVzc2FnZSB8fCBlKVxuICAgICAgICBzZXRDcmV3Q29sb3JUYWdzKHt9KVxuICAgICAgfVxuXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBsb2FkRGF0YTonLCBlcnIpXG4gICAgICBzZXRFcnJvcihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InKVxuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKVxuICAgIH1cbiAgfVxuXG4gIC8vIExvYWQgZGF0YSBvbiBtb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxvYWREYXRhKClcbiAgICBcbiAgICAvLyBUZW1wb3JhcmlseSBkaXNhYmxlIGRhaWx5IGNoZWNrIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHNcbiAgICAvLyBjb25zdCBkYWlseUNoZWNrID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgIC8vICAgY29uc29sZS5sb2coJ1J1bm5pbmcgZGFpbHkgYXV0by1hY3RpdmF0aW9uIGNoZWNrLi4uJylcbiAgICAvLyAgIGxvYWREYXRhKCkgLy8gRGl0IHphbCBhdXRvQWN0aXZhdGVDcmV3TWVtYmVycyBhYW5yb2VwZW5cbiAgICAvLyB9LCAyNCAqIDYwICogNjAgKiAxMDAwKSAvLyAyNCB1dXJcbiAgICBcbiAgICAvLyByZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbChkYWlseUNoZWNrKVxuICB9LCBbXSlcblxuICAvLyBTdWJzY3JpYmUgdG8gcmVhbC10aW1lIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBTdWJzY3JpYmUgdG8gc2hpcHMgY2hhbmdlc1xuICAgIGNvbnN0IHNoaXBzU3Vic2NyaXB0aW9uID0gc3VwYWJhc2VcbiAgICAgIC5jaGFubmVsKCdzaGlwcy1jaGFuZ2VzJylcbiAgICAgIC5vbigncG9zdGdyZXNfY2hhbmdlcycsIHsgZXZlbnQ6ICcqJywgc2NoZW1hOiAncHVibGljJywgdGFibGU6ICdzaGlwcycgfSwgKCkgPT4ge1xuICAgICAgICBsb2FkRGF0YSgpXG4gICAgICB9KVxuICAgICAgLnN1YnNjcmliZSgpXG5cbiAgICAvLyBTdWJzY3JpYmUgdG8gY3JldyBjaGFuZ2VzXG4gICAgY29uc3QgY3Jld1N1YnNjcmlwdGlvbiA9IHN1cGFiYXNlXG4gICAgICAuY2hhbm5lbCgnY3Jldy1jaGFuZ2VzJylcbiAgICAgIC5vbigncG9zdGdyZXNfY2hhbmdlcycsIHsgZXZlbnQ6ICcqJywgc2NoZW1hOiAncHVibGljJywgdGFibGU6ICdjcmV3JyB9LCAoKSA9PiB7XG4gICAgICAgIGxvYWREYXRhKClcbiAgICAgIH0pXG4gICAgICAuc3Vic2NyaWJlKClcblxuICAgIC8vIFN1YnNjcmliZSB0byBzaWNrIGxlYXZlIGNoYW5nZXNcbiAgICBjb25zdCBzaWNrTGVhdmVTdWJzY3JpcHRpb24gPSBzdXBhYmFzZVxuICAgICAgLmNoYW5uZWwoJ3NpY2stbGVhdmUtY2hhbmdlcycpXG4gICAgICAub24oJ3Bvc3RncmVzX2NoYW5nZXMnLCB7IGV2ZW50OiAnKicsIHNjaGVtYTogJ3B1YmxpYycsIHRhYmxlOiAnc2lja19sZWF2ZScgfSwgKCkgPT4ge1xuICAgICAgICBsb2FkRGF0YSgpXG4gICAgICB9KVxuICAgICAgLnN1YnNjcmliZSgpXG5cbiAgICAvLyBTdWJzY3JpYmUgdG8gc3RhbmQgYmFjayByZWNvcmRzIGNoYW5nZXNcbiAgICBjb25zdCBzdGFuZEJhY2tTdWJzY3JpcHRpb24gPSBzdXBhYmFzZVxuICAgICAgLmNoYW5uZWwoJ3N0YW5kLWJhY2stY2hhbmdlcycpXG4gICAgICAub24oJ3Bvc3RncmVzX2NoYW5nZXMnLCB7IGV2ZW50OiAnKicsIHNjaGVtYTogJ3B1YmxpYycsIHRhYmxlOiAnc3RhbmRfYmFja19yZWNvcmRzJyB9LCAoKSA9PiB7XG4gICAgICAgIGxvYWREYXRhKClcbiAgICAgIH0pXG4gICAgICAuc3Vic2NyaWJlKClcblxuICAgIC8vIFN1YnNjcmliZSB0byBsb2FucyBjaGFuZ2VzXG4gICAgY29uc3QgbG9hbnNTdWJzY3JpcHRpb24gPSBzdXBhYmFzZVxuICAgICAgLmNoYW5uZWwoJ2xvYW5zLWNoYW5nZXMnKVxuICAgICAgLm9uKCdwb3N0Z3Jlc19jaGFuZ2VzJywgeyBldmVudDogJyonLCBzY2hlbWE6ICdwdWJsaWMnLCB0YWJsZTogJ2xvYW5zJyB9LCAoKSA9PiB7XG4gICAgICAgIGxvYWREYXRhKClcbiAgICAgIH0pXG4gICAgICAuc3Vic2NyaWJlKClcblxuICAgIC8vIFN1YnNjcmliZSB0byB0cmlwcyBjaGFuZ2VzXG4gICAgY29uc3QgdHJpcHNTdWJzY3JpcHRpb24gPSBzdXBhYmFzZVxuICAgICAgLmNoYW5uZWwoJ3RyaXBzLWNoYW5nZXMnKVxuICAgICAgLm9uKCdwb3N0Z3Jlc19jaGFuZ2VzJywgeyBldmVudDogJyonLCBzY2hlbWE6ICdwdWJsaWMnLCB0YWJsZTogJ3RyaXBzJyB9LCAoKSA9PiB7XG4gICAgICAgIGxvYWREYXRhKClcbiAgICAgIH0pXG4gICAgICAuc3Vic2NyaWJlKClcblxuICAgIC8vIFN1YnNjcmliZSB0byB0YXNrcyBjaGFuZ2VzXG4gICAgY29uc3QgdGFza3NTdWJzY3JpcHRpb24gPSBzdXBhYmFzZVxuICAgICAgLmNoYW5uZWwoJ3Rhc2tzLWNoYW5nZXMnKVxuICAgICAgLm9uKCdwb3N0Z3Jlc19jaGFuZ2VzJywgeyBldmVudDogJyonLCBzY2hlbWE6ICdwdWJsaWMnLCB0YWJsZTogJ3Rhc2tzJyB9LCAoKSA9PiB7XG4gICAgICAgIGxvYWREYXRhKClcbiAgICAgIH0pXG4gICAgICAuc3Vic2NyaWJlKClcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzaGlwc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpXG4gICAgICBjcmV3U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKClcbiAgICAgIHNpY2tMZWF2ZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpXG4gICAgICBzdGFuZEJhY2tTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKVxuICAgICAgbG9hbnNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKVxuICAgICAgdHJpcHNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKVxuICAgICAgdGFza3NTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgLy8gQWRkIGNyZXcgbWVtYmVyXG4gIGNvbnN0IGFkZENyZXcgPSBhc3luYyAoY3Jld0RhdGE6IGFueSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnQWRkaW5nIGNyZXcgbWVtYmVyIHRvIFN1cGFiYXNlOicsIGNyZXdEYXRhKVxuICAgICAgY29uc29sZS5sb2coJ0NyZXcgZGF0YSBkZXRhaWxzOicsIEpTT04uc3RyaW5naWZ5KGNyZXdEYXRhLCBudWxsLCAyKSlcbiAgICAgIFxuICAgICAgLy8gVmFsaWRhdGUgcmVxdWlyZWQgZmllbGRzXG4gICAgICBjb25zdCByZXF1aXJlZEZpZWxkcyA9IFsnaWQnLCAnZmlyc3RfbmFtZScsICdsYXN0X25hbWUnLCAnbmF0aW9uYWxpdHknLCAncG9zaXRpb24nXVxuICAgICAgY29uc3QgbWlzc2luZ0ZpZWxkcyA9IHJlcXVpcmVkRmllbGRzLmZpbHRlcihmaWVsZCA9PiAhY3Jld0RhdGFbZmllbGRdKVxuICAgICAgXG4gICAgICBpZiAobWlzc2luZ0ZpZWxkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBNaXNzaW5nIHJlcXVpcmVkIGZpZWxkczogJHttaXNzaW5nRmllbGRzLmpvaW4oJywgJyl9YClcbiAgICAgICAgY29uc29sZS5lcnJvcignVmFsaWRhdGlvbiBlcnJvcjonLCBlcnJvcilcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIGR1cGxpY2F0ZSBjcmV3IG1lbWJlclxuICAgICAgY29uc3QgeyBkYXRhOiBleGlzdGluZ0NyZXcsIGVycm9yOiBjaGVja0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnY3JldycpXG4gICAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgICAgLmVxKCdmaXJzdF9uYW1lJywgY3Jld0RhdGEuZmlyc3RfbmFtZSlcbiAgICAgICAgLmVxKCdsYXN0X25hbWUnLCBjcmV3RGF0YS5sYXN0X25hbWUpXG4gICAgICAgIC5lcSgnbmF0aW9uYWxpdHknLCBjcmV3RGF0YS5uYXRpb25hbGl0eSlcbiAgICAgICAgLnNpbmdsZSgpXG4gICAgICBcbiAgICAgIGlmIChleGlzdGluZ0NyZXcgJiYgIWNoZWNrRXJyb3IpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYENyZXcgbWVtYmVyIHdpdGggbmFtZSAke2NyZXdEYXRhLmZpcnN0X25hbWV9ICR7Y3Jld0RhdGEubGFzdF9uYW1lfSBhbHJlYWR5IGV4aXN0c2ApXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0R1cGxpY2F0ZSBjcmV3IG1lbWJlcjonLCBlcnJvcilcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2NyZXcnKVxuICAgICAgICAuaW5zZXJ0KFtjcmV3RGF0YV0pXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N1cGFiYXNlIGVycm9yIGFkZGluZyBjcmV3OicsIGVycm9yKVxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZXRhaWxzOicsIEpTT04uc3RyaW5naWZ5KGVycm9yLCBudWxsLCAyKSlcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY29kZTonLCBlcnJvci5jb2RlKVxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBtZXNzYWdlOicsIGVycm9yLm1lc3NhZ2UpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGhpbnQ6JywgZXJyb3IuaGludClcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ0NyZXcgbWVtYmVyIGFkZGVkIHN1Y2Nlc3NmdWxseTonLCBkYXRhKVxuICAgICAgYXdhaXQgbG9hZERhdGEoKVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBjcmV3OicsIGVycilcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFpbHM6JywgSlNPTi5zdHJpbmdpZnkoZXJyLCBudWxsLCAyKSlcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZSBjcmV3IG1lbWJlclxuICBjb25zdCB1cGRhdGVDcmV3ID0gYXN5bmMgKGlkOiBzdHJpbmcsIHVwZGF0ZXM6IGFueSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnVXBkYXRpbmcgY3JldyBtZW1iZXIgaW4gU3VwYWJhc2U6JywgaWQsIHVwZGF0ZXMpXG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdjcmV3JylcbiAgICAgICAgLnVwZGF0ZSh1cGRhdGVzKVxuICAgICAgICAuZXEoJ2lkJywgaWQpXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N1cGFiYXNlIGVycm9yIHVwZGF0aW5nIGNyZXc6JywgZXJyb3IpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdDcmV3IG1lbWJlciB1cGRhdGVkIHN1Y2Nlc3NmdWxseScpXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgY3JldzonLCBlcnIpXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICAvLyBEZWxldGUgY3JldyBtZW1iZXJcbiAgY29uc3QgZGVsZXRlQ3JldyA9IGFzeW5jIChpZDogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdjcmV3JylcbiAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgIC5lcSgnaWQnLCBpZClcbiAgICAgIFxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgICAgXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpIC8vIFJlbG9hZCBhbGwgZGF0YVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgY3JldzonLCBlcnIpXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgc2hpcFxuICBjb25zdCBhZGRTaGlwID0gYXN5bmMgKHNoaXBEYXRhOiBhbnkpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ0FkZGluZyBzaGlwIHRvIFN1cGFiYXNlOicsIHNoaXBEYXRhKVxuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnc2hpcHMnKVxuICAgICAgICAuaW5zZXJ0KFtzaGlwRGF0YV0pXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N1cGFiYXNlIGVycm9yIGFkZGluZyBzaGlwOicsIGVycm9yKVxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZXRhaWxzOicsIEpTT04uc3RyaW5naWZ5KGVycm9yLCBudWxsLCAyKSlcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ1NoaXAgYWRkZWQgc3VjY2Vzc2Z1bGx5OicsIGRhdGEpXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIHNoaXA6JywgZXJyKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRlIHNoaXBcbiAgY29uc3QgdXBkYXRlU2hpcCA9IGFzeW5jIChpZDogc3RyaW5nLCB1cGRhdGVzOiBhbnkpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3NoaXBzJylcbiAgICAgICAgLnVwZGF0ZSh1cGRhdGVzKVxuICAgICAgICAuZXEoJ2lkJywgaWQpXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKClcbiAgICAgIFxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgICAgXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpIC8vIFJlbG9hZCBhbGwgZGF0YVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHNoaXA6JywgZXJyKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgLy8gRGVsZXRlIHNoaXBcbiAgY29uc3QgZGVsZXRlU2hpcCA9IGFzeW5jIChpZDogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdzaGlwcycpXG4gICAgICAgIC5kZWxldGUoKVxuICAgICAgICAuZXEoJ2lkJywgaWQpXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgYXdhaXQgbG9hZERhdGEoKSAvLyBSZWxvYWQgYWxsIGRhdGFcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIHNoaXA6JywgZXJyKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHNpY2sgbGVhdmVcbiAgY29uc3QgYWRkU2lja0xlYXZlID0gYXN5bmMgKHNpY2tMZWF2ZURhdGE6IGFueSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnQWRkaW5nIHNpY2sgbGVhdmUgdG8gU3VwYWJhc2U6Jywgc2lja0xlYXZlRGF0YSlcbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIG5vdGVzIGlzIG5vdCBudWxsXG4gICAgICBpZiAoc2lja0xlYXZlRGF0YS5ub3RlcyA9PT0gbnVsbCB8fCBzaWNrTGVhdmVEYXRhLm5vdGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2lja0xlYXZlRGF0YS5ub3RlcyA9IFwiXCJcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3NpY2tfbGVhdmUnKVxuICAgICAgICAuaW5zZXJ0KFtzaWNrTGVhdmVEYXRhXSlcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignU3VwYWJhc2UgZXJyb3IgYWRkaW5nIHNpY2sgbGVhdmU6JywgZXJyb3IpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFpbHM6JywgSlNPTi5zdHJpbmdpZnkoZXJyb3IsIG51bGwsIDIpKVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnU2ljayBsZWF2ZSBhZGRlZCBzdWNjZXNzZnVsbHk6JywgZGF0YSlcbiAgICAgIGF3YWl0IGxvYWREYXRhKCkgLy8gUmVsb2FkIGFsbCBkYXRhXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIHNpY2sgbGVhdmU6JywgZXJyKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRlIHNpY2sgbGVhdmVcbiAgY29uc3QgdXBkYXRlU2lja0xlYXZlID0gYXN5bmMgKGlkOiBzdHJpbmcsIHVwZGF0ZXM6IGFueSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnVXBkYXRpbmcgc2ljayBsZWF2ZSBpbiBTdXBhYmFzZTonLCBpZCwgdXBkYXRlcylcbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIG5vdGVzIGlzIG5vdCBudWxsXG4gICAgICBpZiAodXBkYXRlcy5ub3RlcyA9PT0gbnVsbCB8fCB1cGRhdGVzLm5vdGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXBkYXRlcy5ub3RlcyA9IFwiXCJcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3NpY2tfbGVhdmUnKVxuICAgICAgICAudXBkYXRlKHVwZGF0ZXMpXG4gICAgICAgIC5lcSgnaWQnLCBpZClcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignU3VwYWJhc2UgZXJyb3IgdXBkYXRpbmcgc2ljayBsZWF2ZTonLCBlcnJvcilcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGV0YWlsczonLCBKU09OLnN0cmluZ2lmeShlcnJvciwgbnVsbCwgMikpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdTaWNrIGxlYXZlIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5OicsIGRhdGEpXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpIC8vIFJlbG9hZCBhbGwgZGF0YVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHNpY2sgbGVhdmU6JywgZXJyKVxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGV0YWlsczonLCBKU09OLnN0cmluZ2lmeShlcnIsIG51bGwsIDIpKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgY29uc3QgYWRkU3RhbmRCYWNrUmVjb3JkID0gYXN5bmMgKHJlY29yZERhdGE6IGFueSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnPT09IEFERElORyBTVEFORCBCQUNLIFJFQ09SRCA9PT0nKVxuICAgICAgY29uc29sZS5sb2coJ09yaWdpbmFsIHJlY29yZCBkYXRhOicsIHJlY29yZERhdGEpXG4gICAgICBcbiAgICAgIC8vIEdlbmVyYXRlIGEgVVVJRCBmb3IgdGhlIGlkIGZpZWxkXG4gICAgICBjb25zdCB1dWlkID0gY3J5cHRvLnJhbmRvbVVVSUQoKVxuICAgICAgY29uc29sZS5sb2coJ0dlbmVyYXRlZCBVVUlEOicsIHV1aWQpXG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBpZCBpZiBpdCBleGlzdHMgYW5kIGFkZCBvdXIgZ2VuZXJhdGVkIFVVSURcbiAgICAgIGNvbnN0IHsgaWQsIC4uLmRhdGFXaXRob3V0SWQgfSA9IHJlY29yZERhdGFcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgc2FmZSBkYXRhIG9iamVjdCB3aXRoIG9ubHkga25vd24gZGF0YWJhc2UgY29sdW1uc1xuICAgICAgY29uc3QgZGF0YVRvSW5zZXJ0ID0ge1xuICAgICAgICBpZDogdXVpZCxcbiAgICAgICAgY3Jld19tZW1iZXJfaWQ6IGRhdGFXaXRob3V0SWQuY3Jld19tZW1iZXJfaWQsXG4gICAgICAgIHN0YXJ0X2RhdGU6IGRhdGFXaXRob3V0SWQuc3RhcnRfZGF0ZSxcbiAgICAgICAgZW5kX2RhdGU6IGRhdGFXaXRob3V0SWQuZW5kX2RhdGUsXG4gICAgICAgIGRheXNfY291bnQ6IGRhdGFXaXRob3V0SWQuZGF5c19jb3VudCxcbiAgICAgICAgZGVzY3JpcHRpb246IGRhdGFXaXRob3V0SWQuZGVzY3JpcHRpb24sXG4gICAgICAgIHN0YW5kX2JhY2tfZGF5c19yZXF1aXJlZDogZGF0YVdpdGhvdXRJZC5zdGFuZF9iYWNrX2RheXNfcmVxdWlyZWQsXG4gICAgICAgIHN0YW5kX2JhY2tfZGF5c19jb21wbGV0ZWQ6IGRhdGFXaXRob3V0SWQuc3RhbmRfYmFja19kYXlzX2NvbXBsZXRlZCxcbiAgICAgICAgc3RhbmRfYmFja19kYXlzX3JlbWFpbmluZzogZGF0YVdpdGhvdXRJZC5zdGFuZF9iYWNrX2RheXNfcmVtYWluaW5nLFxuICAgICAgICBzdGFuZF9iYWNrX3N0YXR1czogZGF0YVdpdGhvdXRJZC5zdGFuZF9iYWNrX3N0YXR1cyxcbiAgICAgICAgc3RhbmRfYmFja19oaXN0b3J5OiBkYXRhV2l0aG91dElkLnN0YW5kX2JhY2tfaGlzdG9yeSB8fCBbXVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBZGQgb3B0aW9uYWwgZmllbGRzIGlmIHRoZXkgZXhpc3QgKGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KVxuICAgICAgaWYgKGRhdGFXaXRob3V0SWQucmVhc29uKSB7XG4gICAgICAgIChkYXRhVG9JbnNlcnQgYXMgYW55KS5yZWFzb24gPSBkYXRhV2l0aG91dElkLnJlYXNvblxuICAgICAgfVxuICAgICAgaWYgKGRhdGFXaXRob3V0SWQubm90ZXMpIHtcbiAgICAgICAgKGRhdGFUb0luc2VydCBhcyBhbnkpLm5vdGVzID0gZGF0YVdpdGhvdXRJZC5ub3Rlc1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnRGF0YSB0byBpbnNlcnQgKHdpdGggZ2VuZXJhdGVkIFVVSUQpOicsIGRhdGFUb0luc2VydClcbiAgICAgIGNvbnNvbGUubG9nKCdEYXRhIHRvIGluc2VydCBKU09OOicsIEpTT04uc3RyaW5naWZ5KGRhdGFUb0luc2VydCwgbnVsbCwgMikpXG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIHJlcXVpcmVkIGZpZWxkc1xuICAgICAgY29uc3QgcmVxdWlyZWRGaWVsZHMgPSBbJ2lkJywgJ2NyZXdfbWVtYmVyX2lkJywgJ3N0YXJ0X2RhdGUnLCAnZW5kX2RhdGUnLCAnZGF5c19jb3VudCcsICdzdGFuZF9iYWNrX2RheXNfcmVxdWlyZWQnLCAnc3RhbmRfYmFja19kYXlzX2NvbXBsZXRlZCcsICdzdGFuZF9iYWNrX2RheXNfcmVtYWluaW5nJywgJ3N0YW5kX2JhY2tfc3RhdHVzJ11cbiAgICAgIGNvbnN0IG1pc3NpbmdGaWVsZHMgPSByZXF1aXJlZEZpZWxkcy5maWx0ZXIoZmllbGQgPT4gIShkYXRhVG9JbnNlcnQgYXMgYW55KVtmaWVsZF0gJiYgKGRhdGFUb0luc2VydCBhcyBhbnkpW2ZpZWxkXSAhPT0gMClcbiAgICAgIFxuICAgICAgaWYgKG1pc3NpbmdGaWVsZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGZpZWxkczonLCBtaXNzaW5nRmllbGRzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgcmVxdWlyZWQgZmllbGRzOiAke21pc3NpbmdGaWVsZHMuam9pbignLCAnKX1gKVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnQWxsIHJlcXVpcmVkIGZpZWxkcyBwcmVzZW50LCBpbnNlcnRpbmcgdG8gZGF0YWJhc2UuLi4nKVxuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnc3RhbmRfYmFja19yZWNvcmRzJylcbiAgICAgICAgLmluc2VydChbZGF0YVRvSW5zZXJ0XSlcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICBcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgU3VwYWJhc2UgZXJyb3IgYWRkaW5nIHN0YW5kIGJhY2sgcmVjb3JkOicsIGVycm9yKVxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZGV0YWlsczonLCBKU09OLnN0cmluZ2lmeShlcnJvciwgbnVsbCwgMikpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBjb2RlOicsIGVycm9yLmNvZGUpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBtZXNzYWdlOicsIGVycm9yLm1lc3NhZ2UpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBoaW50OicsIGVycm9yLmhpbnQpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgU3RhbmQgYmFjayByZWNvcmQgYWRkZWQgc3VjY2Vzc2Z1bGx5OicsIGRhdGEpXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpIC8vIFJlbG9hZCBhbGwgZGF0YVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBhZGRpbmcgc3RhbmQgYmFjayByZWNvcmQ6JywgZXJyKVxuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGRldGFpbHM6JywgSlNPTi5zdHJpbmdpZnkoZXJyLCBudWxsLCAyKSlcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZVN0YW5kQmFja1JlY29yZCA9IGFzeW5jIChyZWNvcmRJZDogc3RyaW5nLCB1cGRhdGVzOiBhbnkpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ1VwZGF0aW5nIHN0YW5kIGJhY2sgcmVjb3JkIGluIFN1cGFiYXNlOicsIHJlY29yZElkLCB1cGRhdGVzKVxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3N0YW5kX2JhY2tfcmVjb3JkcycpXG4gICAgICAgIC51cGRhdGUodXBkYXRlcylcbiAgICAgICAgLmVxKCdpZCcsIHJlY29yZElkKVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgIFxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N1cGFiYXNlIGVycm9yIHVwZGF0aW5nIHN0YW5kIGJhY2sgcmVjb3JkOicsIGVycm9yKVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnU3RhbmQgYmFjayByZWNvcmQgdXBkYXRlZCBzdWNjZXNzZnVsbHk6JywgZGF0YSlcbiAgICAgIGF3YWl0IGxvYWREYXRhKCkgLy8gUmVsb2FkIGFsbCBkYXRhXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgc3RhbmQgYmFjayByZWNvcmQ6JywgZXJyKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgY29uc3QgYWRkTG9hbiA9IGFzeW5jIChsb2FuRGF0YTogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgbG9hbiB0byBTdXBhYmFzZTonLCBsb2FuRGF0YSlcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdsb2FucycpXG4gICAgICAgIC5pbnNlcnQoW2xvYW5EYXRhXSlcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICBcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBlcnJvciBhZGRpbmcgbG9hbjonLCBlcnJvcilcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ0xvYW4gYWRkZWQgc3VjY2Vzc2Z1bGx5OicsIGRhdGEpXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpIC8vIFJlbG9hZCBhbGwgZGF0YVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBsb2FuOicsIGVycilcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNvbXBsZXRlTG9hbiA9IGFzeW5jIChsb2FuSWQ6IHN0cmluZywgbm90ZXM/OiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ0NvbXBsZXRpbmcgbG9hbiBpbiBTdXBhYmFzZTonLCBsb2FuSWQpXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnbG9hbnMnKVxuICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICBzdGF0dXM6ICd2b2x0b29pZCcsXG4gICAgICAgICAgY29tcGxldGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgbm90ZXM6IG5vdGVzIHx8IFwiXCJcbiAgICAgICAgfSlcbiAgICAgICAgLmVxKCdpZCcsIGxvYW5JZClcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICBcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBlcnJvciBjb21wbGV0aW5nIGxvYW46JywgZXJyb3IpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdMb2FuIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHk6JywgZGF0YSlcbiAgICAgIGF3YWl0IGxvYWREYXRhKCkgLy8gUmVsb2FkIGFsbCBkYXRhXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY29tcGxldGluZyBsb2FuOicsIGVycilcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG1ha2VQYXltZW50ID0gYXN5bmMgKGxvYW5JZDogc3RyaW5nLCBwYXltZW50QW1vdW50OiBudW1iZXIsIG5vdGU/OiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ01ha2luZyBwYXltZW50IGZvciBsb2FuOicsIGxvYW5JZCwgcGF5bWVudEFtb3VudClcbiAgICAgIFxuICAgICAgLy8gRmlyc3QsIGdldCB0aGUgY3VycmVudCBsb2FuXG4gICAgICBjb25zdCB7IGRhdGE6IGxvYW4sIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnbG9hbnMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCdpZCcsIGxvYW5JZClcbiAgICAgICAgLnNpbmdsZSgpXG4gICAgICBcbiAgICAgIGlmIChmZXRjaEVycm9yIHx8ICFsb2FuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTG9hbiBub3QgZm91bmQnKVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgbmV3IHZhbHVlc1xuICAgICAgY29uc3QgbmV3UGFpZCA9IChsb2FuLmFtb3VudF9wYWlkIHx8IDApICsgcGF5bWVudEFtb3VudFxuICAgICAgY29uc3QgbmV3UmVtYWluaW5nID0gbG9hbi5hbW91bnQgLSBuZXdQYWlkXG4gICAgICBjb25zdCBuZXdTdGF0dXMgPSBuZXdSZW1haW5pbmcgPD0gMCA/ICd2b2x0b29pZCcgOiAnb3BlbidcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIHBheW1lbnQgaGlzdG9yeSBlbnRyeVxuICAgICAgY29uc3QgcGF5bWVudEVudHJ5ID0ge1xuICAgICAgICBkYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGFtb3VudDogcGF5bWVudEFtb3VudCxcbiAgICAgICAgbm90ZTogbm90ZSB8fCAnQmV0YWxpbmcgYWZnZXRla2VuZCcsXG4gICAgICAgIHBhaWRCeTogJ1VzZXInXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBsb2FuXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnbG9hbnMnKVxuICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICBhbW91bnRfcGFpZDogbmV3UGFpZCxcbiAgICAgICAgICBhbW91bnRfcmVtYWluaW5nOiBuZXdSZW1haW5pbmcsXG4gICAgICAgICAgc3RhdHVzOiBuZXdTdGF0dXMsXG4gICAgICAgICAgY29tcGxldGVkX2F0OiBuZXdTdGF0dXMgPT09ICd2b2x0b29pZCcgPyBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgOiBudWxsLFxuICAgICAgICAgIHBheW1lbnRfaGlzdG9yeTogWy4uLihsb2FuLnBheW1lbnRfaGlzdG9yeSB8fCBbXSksIHBheW1lbnRFbnRyeV1cbiAgICAgICAgfSlcbiAgICAgICAgLmVxKCdpZCcsIGxvYW5JZClcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICBcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBlcnJvciBtYWtpbmcgcGF5bWVudDonLCBlcnJvcilcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1BheW1lbnQgbWFkZSBzdWNjZXNzZnVsbHk6JywgZGF0YSlcbiAgICAgIGF3YWl0IGxvYWREYXRhKCkgLy8gUmVsb2FkIGFsbCBkYXRhXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbWFraW5nIHBheW1lbnQ6JywgZXJyKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgLy8gVHJpcCBmdW5jdGlvbnNcbiAgY29uc3QgYWRkVHJpcCA9IGFzeW5jICh0cmlwRGF0YTogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgdHJpcDonLCB0cmlwRGF0YSlcbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3RyaXBzJylcbiAgICAgICAgLmluc2VydChbdHJpcERhdGFdKVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgIFxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyB0cmlwOicsIGVycm9yKVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnVHJpcCBhZGRlZCBzdWNjZXNzZnVsbHk6JywgZGF0YSlcbiAgICAgIGF3YWl0IGxvYWREYXRhKCkgLy8gUmVsb2FkIGFsbCBkYXRhXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIHRyaXA6JywgZXJyKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgY29uc3QgdXBkYXRlVHJpcCA9IGFzeW5jICh0cmlwSWQ6IHN0cmluZywgdXBkYXRlczogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdVcGRhdGluZyB0cmlwOicsIHRyaXBJZCwgdXBkYXRlcylcbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3RyaXBzJylcbiAgICAgICAgLnVwZGF0ZSh7IC4uLnVwZGF0ZXMsIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9KVxuICAgICAgICAuZXEoJ2lkJywgdHJpcElkKVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpXG4gICAgICBcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyB0cmlwOicsIGVycm9yKVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnVHJpcCB1cGRhdGVkIHN1Y2Nlc3NmdWxseTonLCBkYXRhKVxuICAgICAgXG4gICAgICAvLyBJZiB0cmlwIGlzIGNvbXBsZXRlZCwgYXV0by11cGRhdGUgdmFzdGUgZGllbnN0IHJlY29yZHNcbiAgICAgIGlmICh1cGRhdGVzLnN0YXR1cyA9PT0gJ3ZvbHRvb2lkJyAmJiBkYXRhLmFmbG9zc2VyX2lkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5qAIFRyaXAgY29tcGxldGVkIC0gYXV0by11cGRhdGluZyB2YXN0ZSBkaWVuc3QgcmVjb3JkcycpXG4gICAgICAgIGF3YWl0IGF1dG9VcGRhdGVWYXN0ZURpZW5zdEZyb21UcmlwKGRhdGEpXG4gICAgICB9XG4gICAgICBcbiAgICAgIGF3YWl0IGxvYWREYXRhKCkgLy8gUmVsb2FkIGFsbCBkYXRhXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgdHJpcDonLCBlcnIpXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuXG4gIC8vIFZhc3RlIGRpZW5zdCBmdW5jdGlvbnNcbiAgY29uc3QgYWRkVmFzdGVEaWVuc3RSZWNvcmQgPSBhc3luYyAocmVjb3JkRGF0YTogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgdmFzdGUgZGllbnN0IHJlY29yZDonLCByZWNvcmREYXRhKVxuICAgICAgY29uc29sZS5sb2coJ1JlY29yZCBkYXRhIGRldGFpbHM6JywgSlNPTi5zdHJpbmdpZnkocmVjb3JkRGF0YSwgbnVsbCwgMikpXG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIHJlcXVpcmVkIGZpZWxkc1xuICAgICAgY29uc3QgcmVxdWlyZWRGaWVsZHMgPSBbJ2FmbG9zc2VyX2lkJywgJ3llYXInLCAnbW9udGgnLCAncmVxdWlyZWRfZGF5cycsICdhY3R1YWxfZGF5cycsICdiYWxhbmNlX2RheXMnXVxuICAgICAgY29uc3QgbWlzc2luZ0ZpZWxkcyA9IHJlcXVpcmVkRmllbGRzLmZpbHRlcihmaWVsZCA9PiByZWNvcmREYXRhW2ZpZWxkXSA9PT0gdW5kZWZpbmVkIHx8IHJlY29yZERhdGFbZmllbGRdID09PSBudWxsKVxuICAgICAgXG4gICAgICBpZiAobWlzc2luZ0ZpZWxkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBNaXNzaW5nIHJlcXVpcmVkIGZpZWxkczogJHttaXNzaW5nRmllbGRzLmpvaW4oJywgJyl9YClcbiAgICAgICAgY29uc29sZS5lcnJvcignVmFsaWRhdGlvbiBlcnJvcjonLCBlcnJvcilcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgcmVjb3JkIGFscmVhZHkgZXhpc3RzIGZvciB0aGlzIGFmbG9zc2VyL3llYXIvbW9udGggY29tYmluYXRpb25cbiAgICAgIGNvbnN0IHsgZGF0YTogZXhpc3RpbmdSZWNvcmQsIGVycm9yOiBjaGVja0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndmFzdGVfZGllbnN0X3JlY29yZHMnKVxuICAgICAgICAuc2VsZWN0KCdpZCcpXG4gICAgICAgIC5lcSgnYWZsb3NzZXJfaWQnLCByZWNvcmREYXRhLmFmbG9zc2VyX2lkKVxuICAgICAgICAuZXEoJ3llYXInLCByZWNvcmREYXRhLnllYXIpXG4gICAgICAgIC5lcSgnbW9udGgnLCByZWNvcmREYXRhLm1vbnRoKVxuICAgICAgICAuc2luZ2xlKClcbiAgICAgIFxuICAgICAgaWYgKGV4aXN0aW5nUmVjb3JkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdSZWNvcmQgYWxyZWFkeSBleGlzdHMgZm9yIHRoaXMgYWZsb3NzZXIveWVhci9tb250aCBjb21iaW5hdGlvbiwgdXBkYXRpbmcgaW5zdGVhZCcpXG4gICAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyByZWNvcmQgaW5zdGVhZCBvZiBjcmVhdGluZyBuZXcgb25lXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ3Zhc3RlX2RpZW5zdF9yZWNvcmRzJylcbiAgICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICAgIHJlcXVpcmVkX2RheXM6IHJlY29yZERhdGEucmVxdWlyZWRfZGF5cyxcbiAgICAgICAgICAgIGFjdHVhbF9kYXlzOiByZWNvcmREYXRhLmFjdHVhbF9kYXlzLFxuICAgICAgICAgICAgYmFsYW5jZV9kYXlzOiByZWNvcmREYXRhLmJhbGFuY2VfZGF5cyxcbiAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmVxKCdpZCcsIGV4aXN0aW5nUmVjb3JkLmlkKVxuICAgICAgICAgIC5zZWxlY3QoKVxuICAgICAgICBcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgZXhpc3RpbmcgdmFzdGUgZGllbnN0IHJlY29yZDonLCBlcnJvcilcbiAgICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZygnVmFzdGUgZGllbnN0IHJlY29yZCB1cGRhdGVkIHN1Y2Nlc3NmdWxseTonLCBkYXRhKVxuICAgICAgICBhd2FpdCBsb2FkRGF0YSgpIC8vIFJlbG9hZCBhbGwgZGF0YVxuICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiBubyBleGlzdGluZyByZWNvcmQsIGNyZWF0ZSBuZXcgb25lXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndmFzdGVfZGllbnN0X3JlY29yZHMnKVxuICAgICAgICAuaW5zZXJ0KFtyZWNvcmREYXRhXSlcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICBcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBlcnJvciBhZGRpbmcgdmFzdGUgZGllbnN0IHJlY29yZDonLCBlcnJvcilcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGV0YWlsczonLCBKU09OLnN0cmluZ2lmeShlcnJvciwgbnVsbCwgMikpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNvZGU6JywgZXJyb3IuY29kZSlcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbWVzc2FnZTonLCBlcnJvci5tZXNzYWdlKVxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBoaW50OicsIGVycm9yLmhpbnQpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdWYXN0ZSBkaWVuc3QgcmVjb3JkIGFkZGVkIHN1Y2Nlc3NmdWxseTonLCBkYXRhKVxuICAgICAgYXdhaXQgbG9hZERhdGEoKSAvLyBSZWxvYWQgYWxsIGRhdGFcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgdmFzdGUgZGllbnN0IHJlY29yZDonLCBlcnIpXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZXRhaWxzOicsIEpTT04uc3RyaW5naWZ5KGVyciwgbnVsbCwgMikpXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICBjb25zdCB1cGRhdGVWYXN0ZURpZW5zdFJlY29yZCA9IGFzeW5jIChyZWNvcmRJZDogc3RyaW5nLCB1cGRhdGVzOiBhbnkpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ1VwZGF0aW5nIHZhc3RlIGRpZW5zdCByZWNvcmQ6JywgcmVjb3JkSWQsIHVwZGF0ZXMpXG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd2YXN0ZV9kaWVuc3RfcmVjb3JkcycpXG4gICAgICAgIC51cGRhdGUoeyAuLi51cGRhdGVzLCB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSlcbiAgICAgICAgLmVxKCdpZCcsIHJlY29yZElkKVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpXG4gICAgICBcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyB2YXN0ZSBkaWVuc3QgcmVjb3JkOicsIGVycm9yKVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnVmFzdGUgZGllbnN0IHJlY29yZCB1cGRhdGVkIHN1Y2Nlc3NmdWxseTonLCBkYXRhKVxuICAgICAgYXdhaXQgbG9hZERhdGEoKSAvLyBSZWxvYWQgYWxsIGRhdGFcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyB2YXN0ZSBkaWVuc3QgcmVjb3JkOicsIGVycilcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRlbGV0ZVZhc3RlRGllbnN0UmVjb3JkID0gYXN5bmMgKHJlY29yZElkOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ0RlbGV0aW5nIHZhc3RlIGRpZW5zdCByZWNvcmQ6JywgcmVjb3JkSWQpXG4gICAgICBcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd2YXN0ZV9kaWVuc3RfcmVjb3JkcycpXG4gICAgICAgIC5kZWxldGUoKVxuICAgICAgICAuZXEoJ2lkJywgcmVjb3JkSWQpXG4gICAgICBcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyB2YXN0ZSBkaWVuc3QgcmVjb3JkOicsIGVycm9yKVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnVmFzdGUgZGllbnN0IHJlY29yZCBkZWxldGVkIHN1Y2Nlc3NmdWxseScpXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpIC8vIFJlbG9hZCBhbGwgZGF0YVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgdmFzdGUgZGllbnN0IHJlY29yZDonLCBlcnIpXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICAvLyBEZWxldGUgdHJpcCBwZXJtYW5lbnRseVxuICBjb25zdCBkZWxldGVUcmlwID0gYXN5bmMgKHRyaXBJZDogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd0cmlwcycpXG4gICAgICAgIC5kZWxldGUoKVxuICAgICAgICAuZXEoJ2lkJywgdHJpcElkKVxuICAgICAgXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignU3VwYWJhc2UgZXJyb3IgZGVsZXRpbmcgdHJpcDonLCBlcnJvcilcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1RyaXAgZGVsZXRlZCBzdWNjZXNzZnVsbHknKVxuICAgICAgYXdhaXQgbG9hZERhdGEoKSAvLyBSZWxvYWQgYWxsIGRhdGFcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIHRyaXA6JywgZXJyKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgLy8gRGVsZXRlIGFmbG9zc2VyIHBlcm1hbmVudGx5XG4gIGNvbnN0IGRlbGV0ZUFmbG9zc2VyID0gYXN5bmMgKGFmbG9zc2VySWQ6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBGaXJzdCBkZWxldGUgYWxsIHJlbGF0ZWQgcmVjb3Jkc1xuICAgICAgYXdhaXQgc3VwYWJhc2UuZnJvbSgndmFzdGVfZGllbnN0X3JlY29yZHMnKS5kZWxldGUoKS5lcSgnYWZsb3NzZXJfaWQnLCBhZmxvc3NlcklkKVxuICAgICAgYXdhaXQgc3VwYWJhc2UuZnJvbSgndHJpcHMnKS5kZWxldGUoKS5lcSgnYWZsb3NzZXJfaWQnLCBhZmxvc3NlcklkKVxuICAgICAgXG4gICAgICAvLyBUaGVuIGRlbGV0ZSB0aGUgYWZsb3NzZXJcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdjcmV3JylcbiAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgIC5lcSgnaWQnLCBhZmxvc3NlcklkKVxuICAgICAgXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignU3VwYWJhc2UgZXJyb3IgZGVsZXRpbmcgYWZsb3NzZXI6JywgZXJyb3IpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdBZmxvc3NlciBkZWxldGVkIHN1Y2Nlc3NmdWxseScpXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpIC8vIFJlbG9hZCBhbGwgZGF0YVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgYWZsb3NzZXI6JywgZXJyKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgLy8gTm90ZXMgZnVuY3Rpb25zXG4gIGNvbnN0IGFkZE5vdGVUb0NyZXcgPSBhc3luYyAoY3Jld0lkOiBzdHJpbmcsIG5vdGU6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgY3VycmVudCBjcmV3IG1lbWJlciBkYXRhXG4gICAgICBjb25zdCB7IGRhdGE6IGNyZXdEYXRhLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2NyZXcnKVxuICAgICAgICAuc2VsZWN0KCdhY3RpdmVfbm90ZXMnKVxuICAgICAgICAuZXEoJ2lkJywgY3Jld0lkKVxuICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgIGlmIChmZXRjaEVycm9yKSB0aHJvdyBmZXRjaEVycm9yO1xuXG4gICAgICAvLyBQYXJzZSBleGlzdGluZyBub3RlcyBvciBpbml0aWFsaXplIGVtcHR5IGFycmF5XG4gICAgICBjb25zdCBjdXJyZW50Tm90ZXMgPSBjcmV3RGF0YT8uYWN0aXZlX25vdGVzIHx8IFtdO1xuICAgICAgXG4gICAgICAvLyBBZGQgbmV3IG5vdGUgd2l0aCB0aW1lc3RhbXBcbiAgICAgIGNvbnN0IG5ld05vdGUgPSB7XG4gICAgICAgIGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksIC8vIFNpbXBsZSBJRCBnZW5lcmF0aW9uXG4gICAgICAgIGNvbnRlbnQ6IG5vdGUsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBjcmVhdGVkQnk6ICd1c2VyJyAvLyBZb3UgY291bGQgZ2V0IHRoaXMgZnJvbSBhdXRoIGNvbnRleHRcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHVwZGF0ZWROb3RlcyA9IFsuLi5jdXJyZW50Tm90ZXMsIG5ld05vdGVdO1xuXG4gICAgICAvLyBVcGRhdGUgY3JldyBtZW1iZXIgd2l0aCBuZXcgbm90ZXNcbiAgICAgIGNvbnN0IHsgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnY3JldycpXG4gICAgICAgIC51cGRhdGUoeyBhY3RpdmVfbm90ZXM6IHVwZGF0ZWROb3RlcyB9KVxuICAgICAgICAuZXEoJ2lkJywgY3Jld0lkKTtcblxuICAgICAgaWYgKHVwZGF0ZUVycm9yKSB0aHJvdyB1cGRhdGVFcnJvcjtcblxuICAgICAgY29uc29sZS5sb2coJ05vdGUgYWRkZWQgc3VjY2Vzc2Z1bGx5JylcbiAgICAgIGF3YWl0IGxvYWREYXRhKCk7IC8vIFJlbG9hZCBkYXRhXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBub3RlOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCByZW1vdmVOb3RlRnJvbUNyZXcgPSBhc3luYyAoY3Jld0lkOiBzdHJpbmcsIG5vdGVJZDogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBjdXJyZW50IGNyZXcgbWVtYmVyIGRhdGFcbiAgICAgIGNvbnN0IHsgZGF0YTogY3Jld0RhdGEsIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnY3JldycpXG4gICAgICAgIC5zZWxlY3QoJ2FjdGl2ZV9ub3RlcywgYXJjaGl2ZWRfbm90ZXMnKVxuICAgICAgICAuZXEoJ2lkJywgY3Jld0lkKVxuICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgIGlmIChmZXRjaEVycm9yKSB0aHJvdyBmZXRjaEVycm9yO1xuXG4gICAgICBjb25zdCBjdXJyZW50QWN0aXZlTm90ZXMgPSBjcmV3RGF0YT8uYWN0aXZlX25vdGVzIHx8IFtdO1xuICAgICAgY29uc3QgY3VycmVudEFyY2hpdmVkTm90ZXMgPSBjcmV3RGF0YT8uYXJjaGl2ZWRfbm90ZXMgfHwgW107XG5cbiAgICAgIC8vIEZpbmQgdGhlIG5vdGUgdG8gcmVtb3ZlXG4gICAgICBjb25zdCBub3RlVG9BcmNoaXZlID0gY3VycmVudEFjdGl2ZU5vdGVzLmZpbmQoKG5vdGU6IGFueSkgPT4gbm90ZS5pZCA9PT0gbm90ZUlkKTtcbiAgICAgIGlmICghbm90ZVRvQXJjaGl2ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdGUgbm90IGZvdW5kJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBmcm9tIGFjdGl2ZSBub3Rlc1xuICAgICAgY29uc3QgdXBkYXRlZEFjdGl2ZU5vdGVzID0gY3VycmVudEFjdGl2ZU5vdGVzLmZpbHRlcigobm90ZTogYW55KSA9PiBub3RlLmlkICE9PSBub3RlSWQpO1xuXG4gICAgICAvLyBBZGQgdG8gYXJjaGl2ZWQgbm90ZXMgd2l0aCBhcmNoaXZlIHRpbWVzdGFtcFxuICAgICAgY29uc3QgYXJjaGl2ZWROb3RlID0ge1xuICAgICAgICAuLi5ub3RlVG9BcmNoaXZlLFxuICAgICAgICBhcmNoaXZlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH07XG4gICAgICBjb25zdCB1cGRhdGVkQXJjaGl2ZWROb3RlcyA9IFsuLi5jdXJyZW50QXJjaGl2ZWROb3RlcywgYXJjaGl2ZWROb3RlXTtcblxuICAgICAgLy8gVXBkYXRlIGNyZXcgbWVtYmVyXG4gICAgICBjb25zdCB7IGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2NyZXcnKVxuICAgICAgICAudXBkYXRlKHsgXG4gICAgICAgICAgYWN0aXZlX25vdGVzOiB1cGRhdGVkQWN0aXZlTm90ZXMsXG4gICAgICAgICAgYXJjaGl2ZWRfbm90ZXM6IHVwZGF0ZWRBcmNoaXZlZE5vdGVzXG4gICAgICAgIH0pXG4gICAgICAgIC5lcSgnaWQnLCBjcmV3SWQpO1xuXG4gICAgICBpZiAodXBkYXRlRXJyb3IpIHRocm93IHVwZGF0ZUVycm9yO1xuXG4gICAgICBjb25zb2xlLmxvZygnTm90ZSBhcmNoaXZlZCBzdWNjZXNzZnVsbHknKVxuICAgICAgYXdhaXQgbG9hZERhdGEoKTsgLy8gUmVsb2FkIGRhdGFcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVtb3Zpbmcgbm90ZTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG5cbiAgLy8gQWRkIHRhc2tcbiAgY29uc3QgYWRkVGFzayA9IGFzeW5jICh0YXNrRGF0YTogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OdIEFkZGluZyB0YXNrIHdpdGggZGF0YTonLCBKU09OLnN0cmluZ2lmeSh0YXNrRGF0YSwgbnVsbCwgMikpXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndGFza3MnKVxuICAgICAgICAuaW5zZXJ0KFt0YXNrRGF0YV0pXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKClcbiAgICAgIFxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBTdXBhYmFzZSBlcnJvciBhZGRpbmcgdGFzazonLCBlcnJvcilcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGNvZGU6JywgZXJyb3IuY29kZSlcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIG1lc3NhZ2U6JywgZXJyb3IubWVzc2FnZSlcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGRldGFpbHM6JywgZXJyb3IuZGV0YWlscylcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGhpbnQ6JywgZXJyb3IuaGludClcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIGF3YWl0IGxvYWREYXRhKClcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyB0YXNrOicsIGVycilcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFpbHM6JywgSlNPTi5zdHJpbmdpZnkoZXJyLCBudWxsLCAyKSlcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZSB0YXNrXG4gIGNvbnN0IHVwZGF0ZVRhc2sgPSBhc3luYyAodGFza0lkOiBzdHJpbmcsIHVwZGF0ZXM6IGFueSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndGFza3MnKVxuICAgICAgICAudXBkYXRlKHVwZGF0ZXMpXG4gICAgICAgIC5lcSgnaWQnLCB0YXNrSWQpXG4gICAgICBcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICAgIGF3YWl0IGxvYWREYXRhKClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHRhc2s6JywgZXJyKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgLy8gRGVsZXRlIHRhc2tcbiAgY29uc3QgZGVsZXRlVGFzayA9IGFzeW5jICh0YXNrSWQ6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndGFza3MnKVxuICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgLmVxKCdpZCcsIHRhc2tJZClcbiAgICAgIFxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgICAgYXdhaXQgbG9hZERhdGEoKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgdGFzazonLCBlcnIpXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICAvLyBDb21wbGV0ZSB0YXNrXG4gIGNvbnN0IGNvbXBsZXRlVGFzayA9IGFzeW5jICh0YXNrSWQ6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBIYWFsIGVlcnN0IGRlIGdlcmVsYXRlZXJkZSBzaGlwX3Zpc2l0IG9wIChhbHMgZGllIGJlc3RhYXQpXG4gICAgICBjb25zdCB7IGRhdGE6IHRhc2tEYXRhLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Rhc2tzJylcbiAgICAgICAgLnNlbGVjdCgnaWQsIHJlbGF0ZWRfc2hpcF92aXNpdF9pZCcpXG4gICAgICAgIC5lcSgnaWQnLCB0YXNrSWQpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAoZmV0Y2hFcnJvcikgdGhyb3cgZmV0Y2hFcnJvclxuXG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndGFza3MnKVxuICAgICAgICAudXBkYXRlKHsgXG4gICAgICAgICAgY29tcGxldGVkOiB0cnVlLFxuICAgICAgICAgIGNvbXBsZXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH0pXG4gICAgICAgIC5lcSgnaWQnLCB0YXNrSWQpXG4gICAgICBcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgLy8gQWxzIGRlemUgdGFhayBnZWtvcHBlbGQgaXMgYWFuIGVlbiBzY2hlZXBzYmV6b2VrLCB6ZXQgZGFhciBkZSBmb2xsb3ctdXAgdWl0XG4gICAgICBpZiAodGFza0RhdGE/LnJlbGF0ZWRfc2hpcF92aXNpdF9pZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHsgZXJyb3I6IHZpc2l0RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAuZnJvbSgnc2hpcF92aXNpdHMnKVxuICAgICAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgICAgIGZvbGxvd191cF9uZWVkZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBmb2xsb3dfdXBfbm90ZXM6IG51bGxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZXEoJ2lkJywgdGFza0RhdGEucmVsYXRlZF9zaGlwX3Zpc2l0X2lkKVxuXG4gICAgICAgICAgaWYgKHZpc2l0RXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHJlbGF0ZWQgc2hpcF92aXNpdCBhZnRlciBjb21wbGV0aW5nIHRhc2s6JywgdmlzaXRFcnJvcilcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGlubmVyRXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5leHBlY3RlZCBlcnJvciB1cGRhdGluZyBzaGlwX3Zpc2l0IGZvciBjb21wbGV0ZWQgdGFzazonLCBpbm5lckVycilcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhd2FpdCBsb2FkRGF0YSgpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjb21wbGV0aW5nIHRhc2s6JywgZXJyKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzaGlwcyxcbiAgICBjcmV3LFxuICAgIHNpY2tMZWF2ZSxcbiAgICBzdGFuZEJhY2tSZWNvcmRzLFxuICAgIGxvYW5zLFxuICAgIHRyaXBzLFxuICAgIHRhc2tzLFxuICAgIGxvYWRpbmcsXG4gICAgZXJyb3IsXG4gICAgbG9hZERhdGEsXG4gICAgY3Jld0NvbG9yVGFncyxcbiAgICBhc3luYyBzZXRDcmV3Q29sb3JUYWcoY3Jld0lkOiBzdHJpbmcsIGNvbG9yOiBzdHJpbmcgfCBudWxsKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWNyZXdJZCkgcmV0dXJuXG4gICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgIC8vIHVwc2VydCBjb2xvclxuICAgICAgICAgIGNvbnN0IHsgZXJyb3I6IHVwc2VydEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgLmZyb20oJ2NyZXdfY29sb3JfdGFncycpXG4gICAgICAgICAgICAudXBzZXJ0KHsgY3Jld19pZDogY3Jld0lkLCBjb2xvciB9LCB7IG9uQ29uZmxpY3Q6ICdjcmV3X2lkJyB9KVxuICAgICAgICAgIGlmICh1cHNlcnRFcnJvcikgdGhyb3cgdXBzZXJ0RXJyb3JcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZWxldGUgY29sb3JcbiAgICAgICAgICBjb25zdCB7IGVycm9yOiBkZWxFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5mcm9tKCdjcmV3X2NvbG9yX3RhZ3MnKVxuICAgICAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgICAgICAuZXEoJ2NyZXdfaWQnLCBjcmV3SWQpXG4gICAgICAgICAgaWYgKGRlbEVycm9yKSB0aHJvdyBkZWxFcnJvclxuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBsb2NhbCBzdGF0ZVxuICAgICAgICBzZXRDcmV3Q29sb3JUYWdzKChwcmV2KSA9PiB7XG4gICAgICAgICAgY29uc3QgbmV4dCA9IHsgLi4ucHJldiB9XG4gICAgICAgICAgaWYgKGNvbG9yKSBuZXh0W2NyZXdJZF0gPSBjb2xvclxuICAgICAgICAgIGVsc2UgZGVsZXRlIG5leHRbY3Jld0lkXVxuICAgICAgICAgIHJldHVybiBuZXh0XG4gICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGVycjogYW55ID0gZVxuICAgICAgICBjb25zdCBtc2cgPSBlcnI/Lm1lc3NhZ2UgfHwgKHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnID8gZXJyIDogSlNPTi5zdHJpbmdpZnkoZXJyKSlcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2V0dGluZyBjcmV3IGNvbG9yIHRhZzonLCBtc2cpXG4gICAgICAgIC8vIElmIHRhYmxlIG1pc3NpbmcsIHN1cmZhY2UgYSBjbGVhciBoaW50IG9uY2VcbiAgICAgICAgaWYgKG1zZz8uaW5jbHVkZXMoJ3JlbGF0aW9uJykgJiYgbXNnPy5pbmNsdWRlcygnY3Jld19jb2xvcl90YWdzJykpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0hpbnQ6IGNyZWF0ZSB0YWJsZSBjcmV3X2NvbG9yX3RhZ3MgKGNyZXdfaWQgdXVpZCBwcmltYXJ5IGtleSByZWZlcmVuY2VzIGNyZXcoaWQpLCBjb2xvciB0ZXh0IG5vdCBudWxsKScpXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZVxuICAgICAgfVxuICAgIH0sXG4gICAgYWRkQ3JldyxcbiAgICB1cGRhdGVDcmV3LFxuICAgIGRlbGV0ZUNyZXcsXG4gICAgYWRkU2hpcCxcbiAgICB1cGRhdGVTaGlwLFxuICAgIGRlbGV0ZVNoaXAsXG4gICAgYWRkU2lja0xlYXZlLFxuICAgIHVwZGF0ZVNpY2tMZWF2ZSxcbiAgICBhZGRTdGFuZEJhY2tSZWNvcmQsXG4gICAgdXBkYXRlU3RhbmRCYWNrUmVjb3JkLFxuICAgIGFkZExvYW4sXG4gICAgY29tcGxldGVMb2FuLFxuICAgIG1ha2VQYXltZW50LFxuICAgIGFkZFRyaXAsXG4gICAgdXBkYXRlVHJpcCxcbiAgICBkZWxldGVUcmlwLFxuICAgIGRlbGV0ZUFmbG9zc2VyLFxuICAgIHZhc3RlRGllbnN0UmVjb3JkcyxcbiAgICBhZGRWYXN0ZURpZW5zdFJlY29yZCxcbiAgICB1cGRhdGVWYXN0ZURpZW5zdFJlY29yZCxcbiAgICBkZWxldGVWYXN0ZURpZW5zdFJlY29yZCxcbiAgICBhZGROb3RlVG9DcmV3LFxuICAgIHJlbW92ZU5vdGVGcm9tQ3JldyxcbiAgICBhZGRUYXNrLFxuICAgIHVwZGF0ZVRhc2ssXG4gICAgZGVsZXRlVGFzayxcbiAgICBjb21wbGV0ZVRhc2tcbiAgfVxufSBcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInN1cGFiYXNlIiwiY2FsY3VsYXRlV29ya0RheXNWYXN0ZURpZW5zdCIsInN0YXJ0RGF0ZSIsInN0YXJ0VGltZSIsImVuZERhdGUiLCJlbmRUaW1lIiwicGFyc2VEYXRlIiwiZGF0ZVN0ciIsImNvbnNvbGUiLCJlcnJvciIsIkRhdGUiLCJpbmNsdWRlcyIsInRlc3QiLCJkYXRlIiwiaXNOYU4iLCJnZXRUaW1lIiwicGFydHMiLCJzcGxpdCIsImxlbmd0aCIsImRheSIsInBhcnNlSW50IiwibW9udGgiLCJ5ZWFyIiwicGFyc2VUaW1lIiwidGltZVN0ciIsInRpbWVQYXJ0cyIsImhvdXJzIiwibWludXRlcyIsInN0YXJ0IiwiZW5kIiwic3RhcnRUaW1lSG91cnMiLCJlbmRUaW1lSG91cnMiLCJzdGFydERhdGVUaW1lIiwic2V0SG91cnMiLCJNYXRoIiwiZmxvb3IiLCJlbmREYXRlVGltZSIsInRpbWVEaWZmTXMiLCJ0b3RhbEhvdXJzIiwiZGF5Q3JlZGl0cyIsImNlaWwiLCJhdXRvQWN0aXZhdGVDcmV3TWVtYmVycyIsImNyZXdEYXRhIiwidG9kYXkiLCJtZW1iZXIiLCJzdGF0dXMiLCJleHBlY3RlZF9zdGFydF9kYXRlIiwic2hpcF9pZCIsInJlZ2ltZSIsImxvZyIsImZpcnN0X25hbWUiLCJsYXN0X25hbWUiLCJmcm9tIiwidXBkYXRlIiwib25fYm9hcmRfc2luY2UiLCJ0aHVpc19zaW5kcyIsInN1Yl9zdGF0dXMiLCJlcSIsImlkIiwiZXJyIiwiYXV0b1JvdGF0ZUNyZXdNZW1iZXJzIiwicmVnaW1lV2Vla3MiLCJyZWdpbWVEYXlzIiwib25Cb2FyZERhdGUiLCJkYXlzU2luY2VPbkJvYXJkIiwidGh1aXNTaW5kcyIsInNldERhdGUiLCJnZXREYXRlIiwidG9JU09TdHJpbmciLCJ0aHVpc0RhdGUiLCJkYXlzU2luY2VUaHVpcyIsIm9uQm9hcmRTaW5jZSIsImF1dG9NYW5hZ2VWYXN0ZURpZW5zdFJlY29yZHMiLCJ2YXN0ZURpZW5zdFJlY29yZHMiLCJ0cmlwc0RhdGEiLCJjdXJyZW50WWVhciIsImdldEZ1bGxZZWFyIiwiY3VycmVudE1vbnRoIiwiZ2V0TW9udGgiLCJ2YXN0ZURpZW5zdEFmbG9zc2VycyIsImZpbHRlciIsInZhc3RlX2RpZW5zdCIsImFmbG9zc2VyIiwiZXhpc3RpbmdSZWNvcmQiLCJmaW5kIiwicmVjb3JkIiwiYWZsb3NzZXJfaWQiLCJuZXdSZWNvcmQiLCJyZXF1aXJlZF9kYXlzIiwiYWN0dWFsX2RheXMiLCJiYWxhbmNlX2RheXMiLCJub3RlcyIsImRhdGEiLCJpbnNlcnQiLCJzZWxlY3QiLCJzaW5nbGUiLCJjdXJyZW50TW9udGhUcmlwcyIsInRyaXAiLCJlaW5kX2RhdHVtIiwidG90YWxXb3JrRGF5cyIsIndvcmtEYXlzIiwiY2FsY3VsYXRlV29ya0RheXMiLCJzdGFydF9kYXR1bSIsInN0YXJ0X3RpamQiLCJlaW5kX3RpamQiLCJyZXF1aXJlZERheXMiLCJiZWdpbnNhbGRvIiwic3RhcnRzYWxkb05vdGUiLCJub3RlIiwidGV4dCIsIm1hdGNoIiwic3RhcnRzYWxkbyIsInBhcnNlRmxvYXQiLCJiYWxhbmNlRGF5cyIsImNhcHBlZEFjdHVhbERheXMiLCJtaW4iLCJjYXBwZWRCYWxhbmNlRGF5cyIsIm1heCIsIkpTT04iLCJzdHJpbmdpZnkiLCJpc29EYXRlIiwicGFkU3RhcnQiLCJ0aW1lRGlmZiIsImRheXNEaWZmIiwiYXV0b1VwZGF0ZVZhc3RlRGllbnN0RnJvbVRyaXAiLCJjb21wbGV0ZWRUcmlwIiwiYWZsb3NzZXJFcnJvciIsInJlY29yZEVycm9yIiwiY29kZSIsInJlY29yZElkIiwiY3JlYXRlZFJlY29yZCIsImNyZWF0ZUVycm9yIiwiYWxsVHJpcHMiLCJ0cmlwc0Vycm9yIiwibm90IiwidHJpcEVuZERhdGUiLCJ0cmlwV29ya0RheXMiLCJ1cGRhdGVFcnJvciIsImZvcmNlUmVjYWxjdWxhdGVBbGxWYXN0ZURpZW5zdFJlY29yZHMiLCJhbGxSZWNvcmRzIiwiZmV0Y2hFcnJvciIsImNyZXciLCJyZXNldEFsbFZhc3RlRGllbnN0UmVjb3JkcyIsInVzZVN1cGFiYXNlRGF0YSIsInNoaXBzIiwic2V0U2hpcHMiLCJzZXRDcmV3Iiwic2lja0xlYXZlIiwic2V0U2lja0xlYXZlIiwic3RhbmRCYWNrUmVjb3JkcyIsInNldFN0YW5kQmFja1JlY29yZHMiLCJsb2FucyIsInNldExvYW5zIiwidHJpcHMiLCJzZXRUcmlwcyIsInNldFZhc3RlRGllbnN0UmVjb3JkcyIsInRhc2tzIiwic2V0VGFza3MiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsInNldEVycm9yIiwiY3Jld0NvbG9yVGFncyIsInNldENyZXdDb2xvclRhZ3MiLCJsb2FkRGF0YSIsInNlc3Npb24iLCJhdXRoIiwiZ2V0U2Vzc2lvbiIsIndhcm4iLCJ0ZXN0RGF0YSIsInRlc3RFcnJvciIsImxpbWl0Iiwic2hpcHNEYXRhIiwic2hpcHNFcnJvciIsIm9yZGVyIiwiY3Jld0Vycm9yIiwic2lja0xlYXZlRGF0YSIsInNpY2tMZWF2ZUVycm9yIiwiYXNjZW5kaW5nIiwic3RhbmRCYWNrRGF0YSIsInN0YW5kQmFja0Vycm9yIiwibG9hbnNEYXRhIiwibG9hbnNFcnJvciIsInZhc3RlRGllbnN0RGF0YSIsInZhc3RlRGllbnN0RXJyb3IiLCJ0YXNrc0RhdGEiLCJ0YXNrc0Vycm9yIiwiY29sb3JSb3dzIiwiY29sb3JFcnIiLCJtc2ciLCJtZXNzYWdlIiwiU3RyaW5nIiwibWFwIiwicm93IiwiY3Jld19pZCIsImNvbG9yIiwiZSIsIkVycm9yIiwic2hpcHNTdWJzY3JpcHRpb24iLCJjaGFubmVsIiwib24iLCJldmVudCIsInNjaGVtYSIsInRhYmxlIiwic3Vic2NyaWJlIiwiY3Jld1N1YnNjcmlwdGlvbiIsInNpY2tMZWF2ZVN1YnNjcmlwdGlvbiIsInN0YW5kQmFja1N1YnNjcmlwdGlvbiIsImxvYW5zU3Vic2NyaXB0aW9uIiwidHJpcHNTdWJzY3JpcHRpb24iLCJ0YXNrc1N1YnNjcmlwdGlvbiIsInVuc3Vic2NyaWJlIiwiYWRkQ3JldyIsInJlcXVpcmVkRmllbGRzIiwibWlzc2luZ0ZpZWxkcyIsImZpZWxkIiwiam9pbiIsImV4aXN0aW5nQ3JldyIsImNoZWNrRXJyb3IiLCJuYXRpb25hbGl0eSIsImhpbnQiLCJ1cGRhdGVDcmV3IiwidXBkYXRlcyIsImRlbGV0ZUNyZXciLCJkZWxldGUiLCJhZGRTaGlwIiwic2hpcERhdGEiLCJ1cGRhdGVTaGlwIiwiZGVsZXRlU2hpcCIsImFkZFNpY2tMZWF2ZSIsInVuZGVmaW5lZCIsInVwZGF0ZVNpY2tMZWF2ZSIsImFkZFN0YW5kQmFja1JlY29yZCIsInJlY29yZERhdGEiLCJ1dWlkIiwiY3J5cHRvIiwicmFuZG9tVVVJRCIsImRhdGFXaXRob3V0SWQiLCJkYXRhVG9JbnNlcnQiLCJjcmV3X21lbWJlcl9pZCIsInN0YXJ0X2RhdGUiLCJlbmRfZGF0ZSIsImRheXNfY291bnQiLCJkZXNjcmlwdGlvbiIsInN0YW5kX2JhY2tfZGF5c19yZXF1aXJlZCIsInN0YW5kX2JhY2tfZGF5c19jb21wbGV0ZWQiLCJzdGFuZF9iYWNrX2RheXNfcmVtYWluaW5nIiwic3RhbmRfYmFja19zdGF0dXMiLCJzdGFuZF9iYWNrX2hpc3RvcnkiLCJyZWFzb24iLCJ1cGRhdGVTdGFuZEJhY2tSZWNvcmQiLCJhZGRMb2FuIiwibG9hbkRhdGEiLCJjb21wbGV0ZUxvYW4iLCJsb2FuSWQiLCJjb21wbGV0ZWRfYXQiLCJtYWtlUGF5bWVudCIsInBheW1lbnRBbW91bnQiLCJsb2FuIiwibmV3UGFpZCIsImFtb3VudF9wYWlkIiwibmV3UmVtYWluaW5nIiwiYW1vdW50IiwibmV3U3RhdHVzIiwicGF5bWVudEVudHJ5IiwicGFpZEJ5IiwiYW1vdW50X3JlbWFpbmluZyIsInBheW1lbnRfaGlzdG9yeSIsImFkZFRyaXAiLCJ0cmlwRGF0YSIsInVwZGF0ZVRyaXAiLCJ0cmlwSWQiLCJ1cGRhdGVkX2F0IiwiYWRkVmFzdGVEaWVuc3RSZWNvcmQiLCJ1cGRhdGVWYXN0ZURpZW5zdFJlY29yZCIsImRlbGV0ZVZhc3RlRGllbnN0UmVjb3JkIiwiZGVsZXRlVHJpcCIsImRlbGV0ZUFmbG9zc2VyIiwiYWZsb3NzZXJJZCIsImFkZE5vdGVUb0NyZXciLCJjcmV3SWQiLCJjdXJyZW50Tm90ZXMiLCJhY3RpdmVfbm90ZXMiLCJuZXdOb3RlIiwibm93IiwidG9TdHJpbmciLCJjb250ZW50IiwiY3JlYXRlZEF0IiwiY3JlYXRlZEJ5IiwidXBkYXRlZE5vdGVzIiwicmVtb3ZlTm90ZUZyb21DcmV3Iiwibm90ZUlkIiwiY3VycmVudEFjdGl2ZU5vdGVzIiwiY3VycmVudEFyY2hpdmVkTm90ZXMiLCJhcmNoaXZlZF9ub3RlcyIsIm5vdGVUb0FyY2hpdmUiLCJ1cGRhdGVkQWN0aXZlTm90ZXMiLCJhcmNoaXZlZE5vdGUiLCJhcmNoaXZlZEF0IiwidXBkYXRlZEFyY2hpdmVkTm90ZXMiLCJhZGRUYXNrIiwidGFza0RhdGEiLCJkZXRhaWxzIiwidXBkYXRlVGFzayIsInRhc2tJZCIsImRlbGV0ZVRhc2siLCJjb21wbGV0ZVRhc2siLCJjb21wbGV0ZWQiLCJyZWxhdGVkX3NoaXBfdmlzaXRfaWQiLCJ2aXNpdEVycm9yIiwiZm9sbG93X3VwX25lZWRlZCIsImZvbGxvd191cF9ub3RlcyIsImlubmVyRXJyIiwic2V0Q3Jld0NvbG9yVGFnIiwidXBzZXJ0RXJyb3IiLCJ1cHNlcnQiLCJvbkNvbmZsaWN0IiwiZGVsRXJyb3IiLCJwcmV2IiwibmV4dCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/use-supabase-data.ts\n"));

/***/ })

});