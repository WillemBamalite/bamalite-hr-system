"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/bemanning/aflossers/page",{

/***/ "(app-pages-browser)/./hooks/use-aflosser-availability.ts":
/*!********************************************!*\
  !*** ./hooks/use-aflosser-availability.ts ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAflosserAvailability: () => (/* binding */ useAflosserAvailability),\n/* harmony export */   useAllAflosserAvailability: () => (/* binding */ useAllAflosserAvailability)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n/* harmony import */ var _barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=isAfter,isBefore,isWithinInterval,parseISO!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/parseISO.js\");\n/* harmony import */ var _barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=isAfter,isBefore,isWithinInterval,parseISO!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/isAfter.js\");\n/* harmony import */ var _barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=isAfter,isBefore,isWithinInterval,parseISO!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/isWithinInterval.js\");\n/* harmony import */ var _barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=isAfter,isBefore,isWithinInterval,parseISO!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/isBefore.js\");\n\n\n\n// Hook to fetch all availability periods for all aflossers\nfunction useAllAflosserAvailability() {\n    const [allPeriods, setAllPeriods] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchAllPeriods = async ()=>{\n        try {\n            setLoading(true);\n            setError(null);\n            const { data, error: fetchError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('aflosser_availability_periods').select('*').order('start_date', {\n                ascending: true\n            });\n            if (fetchError) {\n                var _fetchError_message;\n                // If table doesn't exist yet, just return empty array\n                if (fetchError.code === '42P01' || ((_fetchError_message = fetchError.message) === null || _fetchError_message === void 0 ? void 0 : _fetchError_message.includes('does not exist'))) {\n                    console.warn('Availability periods table does not exist yet. Please run the SQL script.');\n                    setAllPeriods([]);\n                    return;\n                }\n                throw fetchError;\n            }\n            setAllPeriods(data || []);\n        } catch (err) {\n            var _err_message;\n            console.error('Error fetching all availability periods:', err);\n            // If table doesn't exist, just set empty array instead of error\n            if (err.code === '42P01' || ((_err_message = err.message) === null || _err_message === void 0 ? void 0 : _err_message.includes('does not exist'))) {\n                setAllPeriods([]);\n                setError(null);\n            } else {\n                setError(err.message || 'Failed to fetch availability periods');\n            }\n        } finally{\n            setLoading(false);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAllAflosserAvailability.useEffect\": ()=>{\n            fetchAllPeriods();\n        }\n    }[\"useAllAflosserAvailability.useEffect\"], []);\n    // Get availability status for a specific aflosser\n    const getAvailabilityStatus = (crewId)=>{\n        const today = new Date();\n        today.setHours(0, 0, 0, 0);\n        const aflosserPeriods = allPeriods.filter((p)=>p.crew_id === crewId);\n        if (aflosserPeriods.length === 0) {\n            return {\n                status: 'onbekend',\n                nextPeriod: null\n            };\n        }\n        // Find periods that are currently active or upcoming\n        const activeOrUpcoming = aflosserPeriods.filter((p)=>{\n            const periodStart = (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(p.start_date);\n            const periodEnd = p.end_date ? (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(p.end_date) : new Date('2099-12-31');\n            return (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_3__.isAfter)(periodEnd, today) || (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_4__.isWithinInterval)(today, {\n                start: periodStart,\n                end: periodEnd\n            });\n        }).sort((a, b)=>(0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(a.start_date).getTime() - (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(b.start_date).getTime());\n        if (activeOrUpcoming.length === 0) {\n            return {\n                status: 'onbekend',\n                nextPeriod: null\n            };\n        }\n        // Check if currently in a period\n        const currentPeriod = activeOrUpcoming.find((p)=>{\n            const periodStart = (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(p.start_date);\n            const periodEnd = p.end_date ? (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(p.end_date) : new Date('2099-12-31');\n            return (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_4__.isWithinInterval)(today, {\n                start: periodStart,\n                end: periodEnd\n            });\n        });\n        if (currentPeriod) {\n            return {\n                status: currentPeriod.type,\n                nextPeriod: currentPeriod\n            };\n        }\n        // Not in any period, return the next upcoming period\n        const nextPeriod = activeOrUpcoming[0];\n        return {\n            status: 'onbekend',\n            nextPeriod\n        };\n    };\n    return {\n        allPeriods,\n        loading,\n        error,\n        getAvailabilityStatus,\n        refresh: fetchAllPeriods\n    };\n}\nfunction useAflosserAvailability(crewId) {\n    const [periods, setPeriods] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Fetch all periods for a specific aflosser\n    const fetchPeriods = async ()=>{\n        if (!crewId) {\n            setPeriods([]);\n            setLoading(false);\n            return;\n        }\n        try {\n            setLoading(true);\n            setError(null);\n            const { data, error: fetchError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('aflosser_availability_periods').select('*').eq('crew_id', crewId).order('start_date', {\n                ascending: true\n            });\n            if (fetchError) {\n                var _fetchError_message;\n                // If table doesn't exist yet, just return empty array\n                if (fetchError.code === '42P01' || ((_fetchError_message = fetchError.message) === null || _fetchError_message === void 0 ? void 0 : _fetchError_message.includes('does not exist'))) {\n                    console.warn('Availability periods table does not exist yet. Please run the SQL script.');\n                    setPeriods([]);\n                    return;\n                }\n                throw fetchError;\n            }\n            setPeriods(data || []);\n        } catch (err) {\n            var _err_message;\n            console.error('Error fetching availability periods:', err);\n            // If table doesn't exist, just set empty array instead of error\n            if (err.code === '42P01' || ((_err_message = err.message) === null || _err_message === void 0 ? void 0 : _err_message.includes('does not exist'))) {\n                setPeriods([]);\n                setError(null);\n            } else {\n                setError(err.message || 'Failed to fetch availability periods');\n            }\n        } finally{\n            setLoading(false);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAflosserAvailability.useEffect\": ()=>{\n            fetchPeriods();\n        }\n    }[\"useAflosserAvailability.useEffect\"], [\n        crewId\n    ]);\n    // Add new period\n    const addPeriod = async (period)=>{\n        try {\n            const { data, error: insertError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('aflosser_availability_periods').insert(period).select().single();\n            if (insertError) throw insertError;\n            await fetchPeriods();\n            return {\n                data,\n                error: null\n            };\n        } catch (err) {\n            console.error('Error adding availability period:', err);\n            return {\n                data: null,\n                error: err.message || 'Failed to add availability period'\n            };\n        }\n    };\n    // Update period\n    const updatePeriod = async (id, updates)=>{\n        try {\n            const { data, error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('aflosser_availability_periods').update(updates).eq('id', id).select().single();\n            if (updateError) throw updateError;\n            await fetchPeriods();\n            return {\n                data,\n                error: null\n            };\n        } catch (err) {\n            console.error('Error updating availability period:', err);\n            return {\n                data: null,\n                error: err.message || 'Failed to update availability period'\n            };\n        }\n    };\n    // Delete period\n    const deletePeriod = async (id)=>{\n        try {\n            const { error: deleteError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('aflosser_availability_periods').delete().eq('id', id);\n            if (deleteError) throw deleteError;\n            await fetchPeriods();\n            return {\n                error: null\n            };\n        } catch (err) {\n            console.error('Error deleting availability period:', err);\n            return {\n                error: err.message || 'Failed to delete availability period'\n            };\n        }\n    };\n    // Check if aflosser is absent during a date range\n    const isAbsentDuringPeriod = (startDate, endDate)=>{\n        if (!startDate) return {\n            isAbsent: false,\n            period: null\n        };\n        const tripStart = (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(startDate);\n        const tripEnd = endDate ? (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(endDate) : tripStart;\n        // Check all absence periods\n        const absencePeriods = periods.filter((p)=>p.type === 'afwezig');\n        for (const period of absencePeriods){\n            const periodStart = (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(period.start_date);\n            const periodEnd = period.end_date ? (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(period.end_date) : new Date('2099-12-31') // Open end = far future\n            ;\n            // Check if trip overlaps with absence period\n            if ((0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_4__.isWithinInterval)(tripStart, {\n                start: periodStart,\n                end: periodEnd\n            }) || (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_4__.isWithinInterval)(tripEnd, {\n                start: periodStart,\n                end: periodEnd\n            }) || (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_5__.isBefore)(tripStart, periodStart) && (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_3__.isAfter)(tripEnd, periodEnd)) {\n                return {\n                    isAbsent: true,\n                    period\n                };\n            }\n        }\n        return {\n            isAbsent: false,\n            period: null\n        };\n    };\n    // Get current availability status (for display in cards)\n    const getCurrentAvailabilityStatus = ()=>{\n        const today = new Date();\n        today.setHours(0, 0, 0, 0);\n        // Find periods that are currently active or upcoming\n        const activeOrUpcoming = periods.filter((p)=>{\n            const periodStart = (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(p.start_date);\n            const periodEnd = p.end_date ? (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(p.end_date) : new Date('2099-12-31');\n            return (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_3__.isAfter)(periodEnd, today) || (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_4__.isWithinInterval)(today, {\n                start: periodStart,\n                end: periodEnd\n            });\n        }).sort((a, b)=>(0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(a.start_date).getTime() - (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(b.start_date).getTime());\n        if (activeOrUpcoming.length === 0) {\n            return {\n                status: 'onbekend',\n                nextPeriod: null\n            };\n        }\n        // Check if currently in a period\n        const currentPeriod = activeOrUpcoming.find((p)=>{\n            const periodStart = (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(p.start_date);\n            const periodEnd = p.end_date ? (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(p.end_date) : new Date('2099-12-31');\n            return (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_4__.isWithinInterval)(today, {\n                start: periodStart,\n                end: periodEnd\n            });\n        });\n        if (currentPeriod) {\n            return {\n                status: currentPeriod.type,\n                nextPeriod: currentPeriod\n            };\n        }\n        // Not in any period, return the next upcoming period\n        const nextPeriod = activeOrUpcoming[0];\n        return {\n            status: 'onbekend',\n            nextPeriod\n        };\n    };\n    return {\n        periods,\n        loading,\n        error,\n        addPeriod,\n        updatePeriod,\n        deletePeriod,\n        isAbsentDuringPeriod,\n        getCurrentAvailabilityStatus,\n        refresh: fetchPeriods\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZS1hZmxvc3Nlci1hdmFpbGFiaWxpdHkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQTJDO0FBQ0Y7QUFFdUM7QUFNaEYsMkRBQTJEO0FBQ3BELFNBQVNPO0lBQ2QsTUFBTSxDQUFDQyxZQUFZQyxjQUFjLEdBQUdULCtDQUFRQSxDQUF1QixFQUFFO0lBQ3JFLE1BQU0sQ0FBQ1UsU0FBU0MsV0FBVyxHQUFHWCwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNZLE9BQU9DLFNBQVMsR0FBR2IsK0NBQVFBLENBQWdCO0lBRWxELE1BQU1jLGtCQUFrQjtRQUN0QixJQUFJO1lBQ0ZILFdBQVc7WUFDWEUsU0FBUztZQUVULE1BQU0sRUFBRUUsSUFBSSxFQUFFSCxPQUFPSSxVQUFVLEVBQUUsR0FBRyxNQUFNZCxtREFBUUEsQ0FDL0NlLElBQUksQ0FBQyxpQ0FDTEMsTUFBTSxDQUFDLEtBQ1BDLEtBQUssQ0FBQyxjQUFjO2dCQUFFQyxXQUFXO1lBQUs7WUFFekMsSUFBSUosWUFBWTtvQkFFcUJBO2dCQURuQyxzREFBc0Q7Z0JBQ3RELElBQUlBLFdBQVdLLElBQUksS0FBSyxhQUFXTCxzQkFBQUEsV0FBV00sT0FBTyxjQUFsQk4sMENBQUFBLG9CQUFvQk8sUUFBUSxDQUFDLG9CQUFtQjtvQkFDakZDLFFBQVFDLElBQUksQ0FBQztvQkFDYmhCLGNBQWMsRUFBRTtvQkFDaEI7Z0JBQ0Y7Z0JBQ0EsTUFBTU87WUFDUjtZQUVBUCxjQUFjTSxRQUFRLEVBQUU7UUFDMUIsRUFBRSxPQUFPVyxLQUFVO2dCQUdXQTtZQUY1QkYsUUFBUVosS0FBSyxDQUFDLDRDQUE0Q2M7WUFDMUQsZ0VBQWdFO1lBQ2hFLElBQUlBLElBQUlMLElBQUksS0FBSyxhQUFXSyxlQUFBQSxJQUFJSixPQUFPLGNBQVhJLG1DQUFBQSxhQUFhSCxRQUFRLENBQUMsb0JBQW1CO2dCQUNuRWQsY0FBYyxFQUFFO2dCQUNoQkksU0FBUztZQUNYLE9BQU87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LENBQUM0QyxFQUFFTixVQUFVLEVBQUVRLE9BQU8sS0FBSzlDLG9IQUFRQSxDQUFDNkMsRUFBRVAsVUFBVSxFQUFFUSxPQUFPO1FBRW5GLElBQUlWLGlCQUFpQkgsTUFBTSxLQUFLLEdBQUc7WUFDakMsT0FBTztnQkFBRUMsUUFBUTtnQkFBWUMsWUFBWTtZQUFLO1FBQ2hEO1FBRUEsaUNBQWlDO1FBQ2pDLE1BQU1ZLGdCQUFnQlgsaUJBQWlCWSxJQUFJLENBQUNqQixDQUFBQTtZQUMxQyxNQUFNTSxjQUFjckMsb0hBQVFBLENBQUMrQixFQUFFTyxVQUFVO1lBQ3pDLE1BQU1DLFlBQVlSLEVBQUVTLFFBQVEsR0FBR3hDLG9IQUFRQSxDQUFDK0IsRUFBRVMsUUFBUSxJQUFJLElBQUliLEtBQUs7WUFDL0QsT0FBTzFCLDRIQUFnQkEsQ0FBQ3lCLE9BQU87Z0JBQUVlLE9BQU9KO2dCQUFhSyxLQUFLSDtZQUFVO1FBQ3RFO1FBRUEsSUFBSVEsZUFBZTtZQUNqQixPQUFPO2dCQUFFYixRQUFRYSxjQUFjRSxJQUFJO2dCQUFFZCxZQUFZWTtZQUFjO1FBQ2pFO1FBRUEscURBQXFEO1FBQ3JELE1BQU1aLGFBQWFDLGdCQUFnQixDQUFDLEVBQUU7UUFDdEMsT0FBTztZQUFFRixRQUFRO1lBQVlDO1FBQVc7SUFDMUM7SUFFQSxPQUFPO1FBQ0xpQjtRQUNBN0M7UUFDQUU7UUFDQStDO1FBQ0FLO1FBQ0FLO1FBQ0FHO1FBQ0FPO1FBQ0ExQixTQUFTSTtJQUNYO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxEZXZcXGJhbWFsaXRlLWhyLXN5c3RlbSBCZW1hbm5pbmdzbGlqc3RcXGhvb2tzXFx1c2UtYWZsb3NzZXItYXZhaWxhYmlsaXR5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHsgc3VwYWJhc2UgfSBmcm9tICdAL2xpYi9zdXBhYmFzZSdcclxuaW1wb3J0IHR5cGUgeyBEYXRhYmFzZSB9IGZyb20gJ0AvdHlwZXMvZGF0YWJhc2UnXHJcbmltcG9ydCB7IHBhcnNlSVNPLCBmb3JtYXQsIGlzV2l0aGluSW50ZXJ2YWwsIGlzQWZ0ZXIsIGlzQmVmb3JlIH0gZnJvbSAnZGF0ZS1mbnMnXHJcblxyXG50eXBlIEF2YWlsYWJpbGl0eVBlcmlvZCA9IERhdGFiYXNlWydwdWJsaWMnXVsnVGFibGVzJ11bJ2FmbG9zc2VyX2F2YWlsYWJpbGl0eV9wZXJpb2RzJ11bJ1JvdyddXHJcbnR5cGUgQXZhaWxhYmlsaXR5UGVyaW9kSW5zZXJ0ID0gRGF0YWJhc2VbJ3B1YmxpYyddWydUYWJsZXMnXVsnYWZsb3NzZXJfYXZhaWxhYmlsaXR5X3BlcmlvZHMnXVsnSW5zZXJ0J11cclxudHlwZSBBdmFpbGFiaWxpdHlQZXJpb2RVcGRhdGUgPSBEYXRhYmFzZVsncHVibGljJ11bJ1RhYmxlcyddWydhZmxvc3Nlcl9hdmFpbGFiaWxpdHlfcGVyaW9kcyddWydVcGRhdGUnXVxyXG5cclxuLy8gSG9vayB0byBmZXRjaCBhbGwgYXZhaWxhYmlsaXR5IHBlcmlvZHMgZm9yIGFsbCBhZmxvc3NlcnNcclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFsbEFmbG9zc2VyQXZhaWxhYmlsaXR5KCkge1xyXG4gIGNvbnN0IFthbGxQZXJpb2RzLCBzZXRBbGxQZXJpb2RzXSA9IHVzZVN0YXRlPEF2YWlsYWJpbGl0eVBlcmlvZFtdPihbXSlcclxuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKVxyXG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbClcclxuXHJcbiAgY29uc3QgZmV0Y2hBbGxQZXJpb2RzID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgc2V0TG9hZGluZyh0cnVlKVxyXG4gICAgICBzZXRFcnJvcihudWxsKVxyXG4gICAgICBcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnYWZsb3NzZXJfYXZhaWxhYmlsaXR5X3BlcmlvZHMnKVxyXG4gICAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAgIC5vcmRlcignc3RhcnRfZGF0ZScsIHsgYXNjZW5kaW5nOiB0cnVlIH0pXHJcbiAgICAgIFxyXG4gICAgICBpZiAoZmV0Y2hFcnJvcikge1xyXG4gICAgICAgIC8vIElmIHRhYmxlIGRvZXNuJ3QgZXhpc3QgeWV0LCBqdXN0IHJldHVybiBlbXB0eSBhcnJheVxyXG4gICAgICAgIGlmIChmZXRjaEVycm9yLmNvZGUgPT09ICc0MlAwMScgfHwgZmV0Y2hFcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnZG9lcyBub3QgZXhpc3QnKSkge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCdBdmFpbGFiaWxpdHkgcGVyaW9kcyB0YWJsZSBkb2VzIG5vdCBleGlzdCB5ZXQuIFBsZWFzZSBydW4gdGhlIFNRTCBzY3JpcHQuJylcclxuICAgICAgICAgIHNldEFsbFBlcmlvZHMoW10pXHJcbiAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgZmV0Y2hFcnJvclxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBzZXRBbGxQZXJpb2RzKGRhdGEgfHwgW10pXHJcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBhbGwgYXZhaWxhYmlsaXR5IHBlcmlvZHM6JywgZXJyKVxyXG4gICAgICAvLyBJZiB0YWJsZSBkb2Vzbid0IGV4aXN0LCBqdXN0IHNldCBlbXB0eSBhcnJheSBpbnN0ZWFkIG9mIGVycm9yXHJcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJzQyUDAxJyB8fCBlcnIubWVzc2FnZT8uaW5jbHVkZXMoJ2RvZXMgbm90IGV4aXN0JykpIHtcclxuICAgICAgICBzZXRBbGxQZXJpb2RzKFtdKVxyXG4gICAgICAgIHNldEVycm9yKG51bGwpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBmZXRjaCBhdmFpbGFiaWxpdHkgcGVyaW9kcycpXHJcbiAgICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgZmV0Y2hBbGxQZXJpb2RzKClcclxuICB9LCBbXSlcclxuXHJcbiAgLy8gR2V0IGF2YWlsYWJpbGl0eSBzdGF0dXMgZm9yIGEgc3BlY2lmaWMgYWZsb3NzZXJcclxuICBjb25zdCBnZXRBdmFpbGFiaWxpdHlTdGF0dXMgPSAoY3Jld0lkOiBzdHJpbmcpOiB7IHN0YXR1czogJ2Jlc2NoaWtiYWFyJyB8ICdhZndlemlnJyB8ICdvbmJla2VuZCc7IG5leHRQZXJpb2Q6IEF2YWlsYWJpbGl0eVBlcmlvZCB8IG51bGwgfSA9PiB7XHJcbiAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKClcclxuICAgIHRvZGF5LnNldEhvdXJzKDAsIDAsIDAsIDApXHJcblxyXG4gICAgY29uc3QgYWZsb3NzZXJQZXJpb2RzID0gYWxsUGVyaW9kcy5maWx0ZXIocCA9PiBwLmNyZXdfaWQgPT09IGNyZXdJZClcclxuICAgIFxyXG4gICAgaWYgKGFmbG9zc2VyUGVyaW9kcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnb25iZWtlbmQnLCBuZXh0UGVyaW9kOiBudWxsIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBGaW5kIHBlcmlvZHMgdGhhdCBhcmUgY3VycmVudGx5IGFjdGl2ZSBvciB1cGNvbWluZ1xyXG4gICAgY29uc3QgYWN0aXZlT3JVcGNvbWluZyA9IGFmbG9zc2VyUGVyaW9kc1xyXG4gICAgICAuZmlsdGVyKHAgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBlcmlvZFN0YXJ0ID0gcGFyc2VJU08ocC5zdGFydF9kYXRlKVxyXG4gICAgICAgIGNvbnN0IHBlcmlvZEVuZCA9IHAuZW5kX2RhdGUgPyBwYXJzZUlTTyhwLmVuZF9kYXRlKSA6IG5ldyBEYXRlKCcyMDk5LTEyLTMxJylcclxuICAgICAgICByZXR1cm4gaXNBZnRlcihwZXJpb2RFbmQsIHRvZGF5KSB8fCBpc1dpdGhpbkludGVydmFsKHRvZGF5LCB7IHN0YXJ0OiBwZXJpb2RTdGFydCwgZW5kOiBwZXJpb2RFbmQgfSlcclxuICAgICAgfSlcclxuICAgICAgLnNvcnQoKGEsIGIpID0+IHBhcnNlSVNPKGEuc3RhcnRfZGF0ZSkuZ2V0VGltZSgpIC0gcGFyc2VJU08oYi5zdGFydF9kYXRlKS5nZXRUaW1lKCkpXHJcblxyXG4gICAgaWYgKGFjdGl2ZU9yVXBjb21pbmcubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiB7IHN0YXR1czogJ29uYmVrZW5kJywgbmV4dFBlcmlvZDogbnVsbCB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgY3VycmVudGx5IGluIGEgcGVyaW9kXHJcbiAgICBjb25zdCBjdXJyZW50UGVyaW9kID0gYWN0aXZlT3JVcGNvbWluZy5maW5kKHAgPT4ge1xyXG4gICAgICBjb25zdCBwZXJpb2RTdGFydCA9IHBhcnNlSVNPKHAuc3RhcnRfZGF0ZSlcclxuICAgICAgY29uc3QgcGVyaW9kRW5kID0gcC5lbmRfZGF0ZSA/IHBhcnNlSVNPKHAuZW5kX2RhdGUpIDogbmV3IERhdGUoJzIwOTktMTItMzEnKVxyXG4gICAgICByZXR1cm4gaXNXaXRoaW5JbnRlcnZhbCh0b2RheSwgeyBzdGFydDogcGVyaW9kU3RhcnQsIGVuZDogcGVyaW9kRW5kIH0pXHJcbiAgICB9KVxyXG5cclxuICAgIGlmIChjdXJyZW50UGVyaW9kKSB7XHJcbiAgICAgIHJldHVybiB7IHN0YXR1czogY3VycmVudFBlcmlvZC50eXBlLCBuZXh0UGVyaW9kOiBjdXJyZW50UGVyaW9kIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBOb3QgaW4gYW55IHBlcmlvZCwgcmV0dXJuIHRoZSBuZXh0IHVwY29taW5nIHBlcmlvZFxyXG4gICAgY29uc3QgbmV4dFBlcmlvZCA9IGFjdGl2ZU9yVXBjb21pbmdbMF1cclxuICAgIHJldHVybiB7IHN0YXR1czogJ29uYmVrZW5kJywgbmV4dFBlcmlvZCB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgYWxsUGVyaW9kcyxcclxuICAgIGxvYWRpbmcsXHJcbiAgICBlcnJvcixcclxuICAgIGdldEF2YWlsYWJpbGl0eVN0YXR1cyxcclxuICAgIHJlZnJlc2g6IGZldGNoQWxsUGVyaW9kc1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFmbG9zc2VyQXZhaWxhYmlsaXR5KGNyZXdJZD86IHN0cmluZykge1xyXG4gIGNvbnN0IFtwZXJpb2RzLCBzZXRQZXJpb2RzXSA9IHVzZVN0YXRlPEF2YWlsYWJpbGl0eVBlcmlvZFtdPihbXSlcclxuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKVxyXG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbClcclxuXHJcbiAgLy8gRmV0Y2ggYWxsIHBlcmlvZHMgZm9yIGEgc3BlY2lmaWMgYWZsb3NzZXJcclxuICBjb25zdCBmZXRjaFBlcmlvZHMgPSBhc3luYyAoKSA9PiB7XHJcbiAgICBpZiAoIWNyZXdJZCkge1xyXG4gICAgICBzZXRQZXJpb2RzKFtdKVxyXG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBzZXRMb2FkaW5nKHRydWUpXHJcbiAgICAgIHNldEVycm9yKG51bGwpXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdhZmxvc3Nlcl9hdmFpbGFiaWxpdHlfcGVyaW9kcycpXHJcbiAgICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgICAgLmVxKCdjcmV3X2lkJywgY3Jld0lkKVxyXG4gICAgICAgIC5vcmRlcignc3RhcnRfZGF0ZScsIHsgYXNjZW5kaW5nOiB0cnVlIH0pXHJcbiAgICAgIFxyXG4gICAgICBpZiAoZmV0Y2hFcnJvcikge1xyXG4gICAgICAgIC8vIElmIHRhYmxlIGRvZXNuJ3QgZXhpc3QgeWV0LCBqdXN0IHJldHVybiBlbXB0eSBhcnJheVxyXG4gICAgICAgIGlmIChmZXRjaEVycm9yLmNvZGUgPT09ICc0MlAwMScgfHwgZmV0Y2hFcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnZG9lcyBub3QgZXhpc3QnKSkge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCdBdmFpbGFiaWxpdHkgcGVyaW9kcyB0YWJsZSBkb2VzIG5vdCBleGlzdCB5ZXQuIFBsZWFzZSBydW4gdGhlIFNRTCBzY3JpcHQuJylcclxuICAgICAgICAgIHNldFBlcmlvZHMoW10pXHJcbiAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgZmV0Y2hFcnJvclxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBzZXRQZXJpb2RzKGRhdGEgfHwgW10pXHJcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBhdmFpbGFiaWxpdHkgcGVyaW9kczonLCBlcnIpXHJcbiAgICAgIC8vIElmIHRhYmxlIGRvZXNuJ3QgZXhpc3QsIGp1c3Qgc2V0IGVtcHR5IGFycmF5IGluc3RlYWQgb2YgZXJyb3JcclxuICAgICAgaWYgKGVyci5jb2RlID09PSAnNDJQMDEnIHx8IGVyci5tZXNzYWdlPy5pbmNsdWRlcygnZG9lcyBub3QgZXhpc3QnKSkge1xyXG4gICAgICAgIHNldFBlcmlvZHMoW10pXHJcbiAgICAgICAgc2V0RXJyb3IobnVsbClcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZXRFcnJvcihlcnIubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGZldGNoIGF2YWlsYWJpbGl0eSBwZXJpb2RzJylcclxuICAgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0TG9hZGluZyhmYWxzZSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBmZXRjaFBlcmlvZHMoKVxyXG4gIH0sIFtjcmV3SWRdKVxyXG5cclxuICAvLyBBZGQgbmV3IHBlcmlvZFxyXG4gIGNvbnN0IGFkZFBlcmlvZCA9IGFzeW5jIChwZXJpb2Q6IEF2YWlsYWJpbGl0eVBlcmlvZEluc2VydCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvcjogaW5zZXJ0RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ2FmbG9zc2VyX2F2YWlsYWJpbGl0eV9wZXJpb2RzJylcclxuICAgICAgICAuaW5zZXJ0KHBlcmlvZClcclxuICAgICAgICAuc2VsZWN0KClcclxuICAgICAgICAuc2luZ2xlKClcclxuICAgICAgXHJcbiAgICAgIGlmIChpbnNlcnRFcnJvcikgdGhyb3cgaW5zZXJ0RXJyb3JcclxuICAgICAgXHJcbiAgICAgIGF3YWl0IGZldGNoUGVyaW9kcygpXHJcbiAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cclxuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBhdmFpbGFiaWxpdHkgcGVyaW9kOicsIGVycilcclxuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IGVyci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gYWRkIGF2YWlsYWJpbGl0eSBwZXJpb2QnIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFVwZGF0ZSBwZXJpb2RcclxuICBjb25zdCB1cGRhdGVQZXJpb2QgPSBhc3luYyAoaWQ6IHN0cmluZywgdXBkYXRlczogQXZhaWxhYmlsaXR5UGVyaW9kVXBkYXRlKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnYWZsb3NzZXJfYXZhaWxhYmlsaXR5X3BlcmlvZHMnKVxyXG4gICAgICAgIC51cGRhdGUodXBkYXRlcylcclxuICAgICAgICAuZXEoJ2lkJywgaWQpXHJcbiAgICAgICAgLnNlbGVjdCgpXHJcbiAgICAgICAgLnNpbmdsZSgpXHJcbiAgICAgIFxyXG4gICAgICBpZiAodXBkYXRlRXJyb3IpIHRocm93IHVwZGF0ZUVycm9yXHJcbiAgICAgIFxyXG4gICAgICBhd2FpdCBmZXRjaFBlcmlvZHMoKVxyXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XHJcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBhdmFpbGFiaWxpdHkgcGVyaW9kOicsIGVycilcclxuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IGVyci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gdXBkYXRlIGF2YWlsYWJpbGl0eSBwZXJpb2QnIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIERlbGV0ZSBwZXJpb2RcclxuICBjb25zdCBkZWxldGVQZXJpb2QgPSBhc3luYyAoaWQ6IHN0cmluZykgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyBlcnJvcjogZGVsZXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ2FmbG9zc2VyX2F2YWlsYWJpbGl0eV9wZXJpb2RzJylcclxuICAgICAgICAuZGVsZXRlKClcclxuICAgICAgICAuZXEoJ2lkJywgaWQpXHJcbiAgICAgIFxyXG4gICAgICBpZiAoZGVsZXRlRXJyb3IpIHRocm93IGRlbGV0ZUVycm9yXHJcbiAgICAgIFxyXG4gICAgICBhd2FpdCBmZXRjaFBlcmlvZHMoKVxyXG4gICAgICByZXR1cm4geyBlcnJvcjogbnVsbCB9XHJcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBhdmFpbGFiaWxpdHkgcGVyaW9kOicsIGVycilcclxuICAgICAgcmV0dXJuIHsgZXJyb3I6IGVyci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gZGVsZXRlIGF2YWlsYWJpbGl0eSBwZXJpb2QnIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENoZWNrIGlmIGFmbG9zc2VyIGlzIGFic2VudCBkdXJpbmcgYSBkYXRlIHJhbmdlXHJcbiAgY29uc3QgaXNBYnNlbnREdXJpbmdQZXJpb2QgPSAoc3RhcnREYXRlOiBzdHJpbmcsIGVuZERhdGU/OiBzdHJpbmcgfCBudWxsKTogeyBpc0Fic2VudDogYm9vbGVhbjsgcGVyaW9kOiBBdmFpbGFiaWxpdHlQZXJpb2QgfCBudWxsIH0gPT4ge1xyXG4gICAgaWYgKCFzdGFydERhdGUpIHJldHVybiB7IGlzQWJzZW50OiBmYWxzZSwgcGVyaW9kOiBudWxsIH1cclxuXHJcbiAgICBjb25zdCB0cmlwU3RhcnQgPSBwYXJzZUlTTyhzdGFydERhdGUpXHJcbiAgICBjb25zdCB0cmlwRW5kID0gZW5kRGF0ZSA/IHBhcnNlSVNPKGVuZERhdGUpIDogdHJpcFN0YXJ0XHJcblxyXG4gICAgLy8gQ2hlY2sgYWxsIGFic2VuY2UgcGVyaW9kc1xyXG4gICAgY29uc3QgYWJzZW5jZVBlcmlvZHMgPSBwZXJpb2RzLmZpbHRlcihwID0+IHAudHlwZSA9PT0gJ2Fmd2V6aWcnKVxyXG4gICAgXHJcbiAgICBmb3IgKGNvbnN0IHBlcmlvZCBvZiBhYnNlbmNlUGVyaW9kcykge1xyXG4gICAgICBjb25zdCBwZXJpb2RTdGFydCA9IHBhcnNlSVNPKHBlcmlvZC5zdGFydF9kYXRlKVxyXG4gICAgICBjb25zdCBwZXJpb2RFbmQgPSBwZXJpb2QuZW5kX2RhdGUgPyBwYXJzZUlTTyhwZXJpb2QuZW5kX2RhdGUpIDogbmV3IERhdGUoJzIwOTktMTItMzEnKSAvLyBPcGVuIGVuZCA9IGZhciBmdXR1cmVcclxuICAgICAgXHJcbiAgICAgIC8vIENoZWNrIGlmIHRyaXAgb3ZlcmxhcHMgd2l0aCBhYnNlbmNlIHBlcmlvZFxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgKGlzV2l0aGluSW50ZXJ2YWwodHJpcFN0YXJ0LCB7IHN0YXJ0OiBwZXJpb2RTdGFydCwgZW5kOiBwZXJpb2RFbmQgfSkgfHxcclxuICAgICAgICAgaXNXaXRoaW5JbnRlcnZhbCh0cmlwRW5kLCB7IHN0YXJ0OiBwZXJpb2RTdGFydCwgZW5kOiBwZXJpb2RFbmQgfSkgfHxcclxuICAgICAgICAgKGlzQmVmb3JlKHRyaXBTdGFydCwgcGVyaW9kU3RhcnQpICYmIGlzQWZ0ZXIodHJpcEVuZCwgcGVyaW9kRW5kKSkpXHJcbiAgICAgICkge1xyXG4gICAgICAgIHJldHVybiB7IGlzQWJzZW50OiB0cnVlLCBwZXJpb2QgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHsgaXNBYnNlbnQ6IGZhbHNlLCBwZXJpb2Q6IG51bGwgfVxyXG4gIH1cclxuXHJcbiAgLy8gR2V0IGN1cnJlbnQgYXZhaWxhYmlsaXR5IHN0YXR1cyAoZm9yIGRpc3BsYXkgaW4gY2FyZHMpXHJcbiAgY29uc3QgZ2V0Q3VycmVudEF2YWlsYWJpbGl0eVN0YXR1cyA9ICgpOiB7IHN0YXR1czogJ2Jlc2NoaWtiYWFyJyB8ICdhZndlemlnJyB8ICdvbmJla2VuZCc7IG5leHRQZXJpb2Q6IEF2YWlsYWJpbGl0eVBlcmlvZCB8IG51bGwgfSA9PiB7XHJcbiAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKClcclxuICAgIHRvZGF5LnNldEhvdXJzKDAsIDAsIDAsIDApXHJcblxyXG4gICAgLy8gRmluZCBwZXJpb2RzIHRoYXQgYXJlIGN1cnJlbnRseSBhY3RpdmUgb3IgdXBjb21pbmdcclxuICAgIGNvbnN0IGFjdGl2ZU9yVXBjb21pbmcgPSBwZXJpb2RzXHJcbiAgICAgIC5maWx0ZXIocCA9PiB7XHJcbiAgICAgICAgY29uc3QgcGVyaW9kU3RhcnQgPSBwYXJzZUlTTyhwLnN0YXJ0X2RhdGUpXHJcbiAgICAgICAgY29uc3QgcGVyaW9kRW5kID0gcC5lbmRfZGF0ZSA/IHBhcnNlSVNPKHAuZW5kX2RhdGUpIDogbmV3IERhdGUoJzIwOTktMTItMzEnKVxyXG4gICAgICAgIHJldHVybiBpc0FmdGVyKHBlcmlvZEVuZCwgdG9kYXkpIHx8IGlzV2l0aGluSW50ZXJ2YWwodG9kYXksIHsgc3RhcnQ6IHBlcmlvZFN0YXJ0LCBlbmQ6IHBlcmlvZEVuZCB9KVxyXG4gICAgICB9KVxyXG4gICAgICAuc29ydCgoYSwgYikgPT4gcGFyc2VJU08oYS5zdGFydF9kYXRlKS5nZXRUaW1lKCkgLSBwYXJzZUlTTyhiLnN0YXJ0X2RhdGUpLmdldFRpbWUoKSlcclxuXHJcbiAgICBpZiAoYWN0aXZlT3JVcGNvbWluZy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnb25iZWtlbmQnLCBuZXh0UGVyaW9kOiBudWxsIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBpZiBjdXJyZW50bHkgaW4gYSBwZXJpb2RcclxuICAgIGNvbnN0IGN1cnJlbnRQZXJpb2QgPSBhY3RpdmVPclVwY29taW5nLmZpbmQocCA9PiB7XHJcbiAgICAgIGNvbnN0IHBlcmlvZFN0YXJ0ID0gcGFyc2VJU08ocC5zdGFydF9kYXRlKVxyXG4gICAgICBjb25zdCBwZXJpb2RFbmQgPSBwLmVuZF9kYXRlID8gcGFyc2VJU08ocC5lbmRfZGF0ZSkgOiBuZXcgRGF0ZSgnMjA5OS0xMi0zMScpXHJcbiAgICAgIHJldHVybiBpc1dpdGhpbkludGVydmFsKHRvZGF5LCB7IHN0YXJ0OiBwZXJpb2RTdGFydCwgZW5kOiBwZXJpb2RFbmQgfSlcclxuICAgIH0pXHJcblxyXG4gICAgaWYgKGN1cnJlbnRQZXJpb2QpIHtcclxuICAgICAgcmV0dXJuIHsgc3RhdHVzOiBjdXJyZW50UGVyaW9kLnR5cGUsIG5leHRQZXJpb2Q6IGN1cnJlbnRQZXJpb2QgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vdCBpbiBhbnkgcGVyaW9kLCByZXR1cm4gdGhlIG5leHQgdXBjb21pbmcgcGVyaW9kXHJcbiAgICBjb25zdCBuZXh0UGVyaW9kID0gYWN0aXZlT3JVcGNvbWluZ1swXVxyXG4gICAgcmV0dXJuIHsgc3RhdHVzOiAnb25iZWtlbmQnLCBuZXh0UGVyaW9kIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBwZXJpb2RzLFxyXG4gICAgbG9hZGluZyxcclxuICAgIGVycm9yLFxyXG4gICAgYWRkUGVyaW9kLFxyXG4gICAgdXBkYXRlUGVyaW9kLFxyXG4gICAgZGVsZXRlUGVyaW9kLFxyXG4gICAgaXNBYnNlbnREdXJpbmdQZXJpb2QsXHJcbiAgICBnZXRDdXJyZW50QXZhaWxhYmlsaXR5U3RhdHVzLFxyXG4gICAgcmVmcmVzaDogZmV0Y2hQZXJpb2RzXHJcbiAgfVxyXG59XHJcblxyXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJzdXBhYmFzZSIsInBhcnNlSVNPIiwiaXNXaXRoaW5JbnRlcnZhbCIsImlzQWZ0ZXIiLCJpc0JlZm9yZSIsInVzZUFsbEFmbG9zc2VyQXZhaWxhYmlsaXR5IiwiYWxsUGVyaW9kcyIsInNldEFsbFBlcmlvZHMiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJmZXRjaEFsbFBlcmlvZHMiLCJkYXRhIiwiZmV0Y2hFcnJvciIsImZyb20iLCJzZWxlY3QiLCJvcmRlciIsImFzY2VuZGluZyIsImNvZGUiLCJtZXNzYWdlIiwiaW5jbHVkZXMiLCJjb25zb2xlIiwid2FybiIsImVyciIsImdldEF2YWlsYWJpbGl0eVN0YXR1cyIsImNyZXdJZCIsInRvZGF5IiwiRGF0ZSIsInNldEhvdXJzIiwiYWZsb3NzZXJQZXJpb2RzIiwiZmlsdGVyIiwicCIsImNyZXdfaWQiLCJsZW5ndGgiLCJzdGF0dXMiLCJuZXh0UGVyaW9kIiwiYWN0aXZlT3JVcGNvbWluZyIsInBlcmlvZFN0YXJ0Iiwic3RhcnRfZGF0ZSIsInBlcmlvZEVuZCIsImVuZF9kYXRlIiwic3RhcnQiLCJlbmQiLCJzb3J0IiwiYSIsImIiLCJnZXRUaW1lIiwiY3VycmVudFBlcmlvZCIsImZpbmQiLCJ0eXBlIiwicmVmcmVzaCIsInVzZUFmbG9zc2VyQXZhaWxhYmlsaXR5IiwicGVyaW9kcyIsInNldFBlcmlvZHMiLCJmZXRjaFBlcmlvZHMiLCJlcSIsImFkZFBlcmlvZCIsInBlcmlvZCIsImluc2VydEVycm9yIiwiaW5zZXJ0Iiwic2luZ2xlIiwidXBkYXRlUGVyaW9kIiwiaWQiLCJ1cGRhdGVzIiwidXBkYXRlRXJyb3IiLCJ1cGRhdGUiLCJkZWxldGVQZXJpb2QiLCJkZWxldGVFcnJvciIsImRlbGV0ZSIsImlzQWJzZW50RHVyaW5nUGVyaW9kIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsImlzQWJzZW50IiwidHJpcFN0YXJ0IiwidHJpcEVuZCIsImFic2VuY2VQZXJpb2RzIiwiZ2V0Q3VycmVudEF2YWlsYWJpbGl0eVN0YXR1cyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/use-aflosser-availability.ts\n"));

/***/ })

});