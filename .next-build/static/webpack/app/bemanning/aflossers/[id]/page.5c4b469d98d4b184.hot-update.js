"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/bemanning/aflossers/[id]/page",{

/***/ "(app-pages-browser)/./hooks/use-aflosser-availability.ts":
/*!********************************************!*\
  !*** ./hooks/use-aflosser-availability.ts ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAflosserAvailability: () => (/* binding */ useAflosserAvailability),\n/* harmony export */   useAllAflosserAvailability: () => (/* binding */ useAllAflosserAvailability)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n/* harmony import */ var _barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=isAfter,isBefore,isWithinInterval,parseISO!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/parseISO.js\");\n/* harmony import */ var _barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=isAfter,isBefore,isWithinInterval,parseISO!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/isAfter.js\");\n/* harmony import */ var _barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=isAfter,isBefore,isWithinInterval,parseISO!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/isWithinInterval.js\");\n/* harmony import */ var _barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=isAfter,isBefore,isWithinInterval,parseISO!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/isBefore.js\");\n\n\n\n// Hook to fetch all availability periods for all aflossers\nfunction useAllAflosserAvailability() {\n    const [allPeriods, setAllPeriods] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchAllPeriods = async ()=>{\n        try {\n            setLoading(true);\n            setError(null);\n            const { data, error: fetchError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('aflosser_availability_periods').select('*').order('start_date', {\n                ascending: true\n            });\n            if (fetchError) throw fetchError;\n            setAllPeriods(data || []);\n        } catch (err) {\n            console.error('Error fetching all availability periods:', err);\n            setError(err.message || 'Failed to fetch availability periods');\n        } finally{\n            setLoading(false);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAllAflosserAvailability.useEffect\": ()=>{\n            fetchAllPeriods();\n        }\n    }[\"useAllAflosserAvailability.useEffect\"], []);\n    // Get availability status for a specific aflosser\n    const getAvailabilityStatus = (crewId)=>{\n        const today = new Date();\n        today.setHours(0, 0, 0, 0);\n        const aflosserPeriods = allPeriods.filter((p)=>p.crew_id === crewId);\n        if (aflosserPeriods.length === 0) {\n            return {\n                status: 'onbekend',\n                nextPeriod: null\n            };\n        }\n        // Find periods that are currently active or upcoming\n        const activeOrUpcoming = aflosserPeriods.filter((p)=>{\n            const periodStart = (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(p.start_date);\n            const periodEnd = p.end_date ? (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(p.end_date) : new Date('2099-12-31');\n            return (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_3__.isAfter)(periodEnd, today) || (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_4__.isWithinInterval)(today, {\n                start: periodStart,\n                end: periodEnd\n            });\n        }).sort((a, b)=>(0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(a.start_date).getTime() - (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(b.start_date).getTime());\n        if (activeOrUpcoming.length === 0) {\n            return {\n                status: 'onbekend',\n                nextPeriod: null\n            };\n        }\n        // Check if currently in a period\n        const currentPeriod = activeOrUpcoming.find((p)=>{\n            const periodStart = (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(p.start_date);\n            const periodEnd = p.end_date ? (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(p.end_date) : new Date('2099-12-31');\n            return (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_4__.isWithinInterval)(today, {\n                start: periodStart,\n                end: periodEnd\n            });\n        });\n        if (currentPeriod) {\n            return {\n                status: currentPeriod.type,\n                nextPeriod: currentPeriod\n            };\n        }\n        // Not in any period, return the next upcoming period\n        const nextPeriod = activeOrUpcoming[0];\n        return {\n            status: 'onbekend',\n            nextPeriod\n        };\n    };\n    return {\n        allPeriods,\n        loading,\n        error,\n        getAvailabilityStatus,\n        refresh: fetchAllPeriods\n    };\n}\nfunction useAflosserAvailability(crewId) {\n    const [periods, setPeriods] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Fetch all periods for a specific aflosser\n    const fetchPeriods = async ()=>{\n        if (!crewId) {\n            setPeriods([]);\n            setLoading(false);\n            return;\n        }\n        try {\n            setLoading(true);\n            setError(null);\n            const { data, error: fetchError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('aflosser_availability_periods').select('*').eq('crew_id', crewId).order('start_date', {\n                ascending: true\n            });\n            if (fetchError) {\n                var _fetchError_message;\n                // If table doesn't exist yet, just return empty array\n                if (fetchError.code === '42P01' || ((_fetchError_message = fetchError.message) === null || _fetchError_message === void 0 ? void 0 : _fetchError_message.includes('does not exist'))) {\n                    console.warn('Availability periods table does not exist yet. Please run the SQL script.');\n                    setPeriods([]);\n                    return;\n                }\n                throw fetchError;\n            }\n            setPeriods(data || []);\n        } catch (err) {\n            var _err_message;\n            console.error('Error fetching availability periods:', err);\n            // If table doesn't exist, just set empty array instead of error\n            if (err.code === '42P01' || ((_err_message = err.message) === null || _err_message === void 0 ? void 0 : _err_message.includes('does not exist'))) {\n                setPeriods([]);\n                setError(null);\n            } else {\n                setError(err.message || 'Failed to fetch availability periods');\n            }\n        } finally{\n            setLoading(false);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAflosserAvailability.useEffect\": ()=>{\n            fetchPeriods();\n        }\n    }[\"useAflosserAvailability.useEffect\"], [\n        crewId\n    ]);\n    // Add new period\n    const addPeriod = async (period)=>{\n        try {\n            const { data, error: insertError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('aflosser_availability_periods').insert(period).select().single();\n            if (insertError) throw insertError;\n            await fetchPeriods();\n            return {\n                data,\n                error: null\n            };\n        } catch (err) {\n            console.error('Error adding availability period:', err);\n            return {\n                data: null,\n                error: err.message || 'Failed to add availability period'\n            };\n        }\n    };\n    // Update period\n    const updatePeriod = async (id, updates)=>{\n        try {\n            const { data, error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('aflosser_availability_periods').update(updates).eq('id', id).select().single();\n            if (updateError) throw updateError;\n            await fetchPeriods();\n            return {\n                data,\n                error: null\n            };\n        } catch (err) {\n            console.error('Error updating availability period:', err);\n            return {\n                data: null,\n                error: err.message || 'Failed to update availability period'\n            };\n        }\n    };\n    // Delete period\n    const deletePeriod = async (id)=>{\n        try {\n            const { error: deleteError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from('aflosser_availability_periods').delete().eq('id', id);\n            if (deleteError) throw deleteError;\n            await fetchPeriods();\n            return {\n                error: null\n            };\n        } catch (err) {\n            console.error('Error deleting availability period:', err);\n            return {\n                error: err.message || 'Failed to delete availability period'\n            };\n        }\n    };\n    // Check if aflosser is absent during a date range\n    const isAbsentDuringPeriod = (startDate, endDate)=>{\n        if (!startDate) return {\n            isAbsent: false,\n            period: null\n        };\n        const tripStart = (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(startDate);\n        const tripEnd = endDate ? (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(endDate) : tripStart;\n        // Check all absence periods\n        const absencePeriods = periods.filter((p)=>p.type === 'afwezig');\n        for (const period of absencePeriods){\n            const periodStart = (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(period.start_date);\n            const periodEnd = period.end_date ? (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(period.end_date) : new Date('2099-12-31') // Open end = far future\n            ;\n            // Check if trip overlaps with absence period\n            if ((0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_4__.isWithinInterval)(tripStart, {\n                start: periodStart,\n                end: periodEnd\n            }) || (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_4__.isWithinInterval)(tripEnd, {\n                start: periodStart,\n                end: periodEnd\n            }) || (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_5__.isBefore)(tripStart, periodStart) && (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_3__.isAfter)(tripEnd, periodEnd)) {\n                return {\n                    isAbsent: true,\n                    period\n                };\n            }\n        }\n        return {\n            isAbsent: false,\n            period: null\n        };\n    };\n    // Get current availability status (for display in cards)\n    const getCurrentAvailabilityStatus = ()=>{\n        const today = new Date();\n        today.setHours(0, 0, 0, 0);\n        // Find periods that are currently active or upcoming\n        const activeOrUpcoming = periods.filter((p)=>{\n            const periodStart = (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(p.start_date);\n            const periodEnd = p.end_date ? (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(p.end_date) : new Date('2099-12-31');\n            return (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_3__.isAfter)(periodEnd, today) || (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_4__.isWithinInterval)(today, {\n                start: periodStart,\n                end: periodEnd\n            });\n        }).sort((a, b)=>(0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(a.start_date).getTime() - (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(b.start_date).getTime());\n        if (activeOrUpcoming.length === 0) {\n            return {\n                status: 'onbekend',\n                nextPeriod: null\n            };\n        }\n        // Check if currently in a period\n        const currentPeriod = activeOrUpcoming.find((p)=>{\n            const periodStart = (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(p.start_date);\n            const periodEnd = p.end_date ? (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_2__.parseISO)(p.end_date) : new Date('2099-12-31');\n            return (0,_barrel_optimize_names_isAfter_isBefore_isWithinInterval_parseISO_date_fns__WEBPACK_IMPORTED_MODULE_4__.isWithinInterval)(today, {\n                start: periodStart,\n                end: periodEnd\n            });\n        });\n        if (currentPeriod) {\n            return {\n                status: currentPeriod.type,\n                nextPeriod: currentPeriod\n            };\n        }\n        // Not in any period, return the next upcoming period\n        const nextPeriod = activeOrUpcoming[0];\n        return {\n            status: 'onbekend',\n            nextPeriod\n        };\n    };\n    return {\n        periods,\n        loading,\n        error,\n        addPeriod,\n        updatePeriod,\n        deletePeriod,\n        isAbsentDuringPeriod,\n        getCurrentAvailabilityStatus,\n        refresh: fetchPeriods\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZS1hZmxvc3Nlci1hdmFpbGFiaWxpdHkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQTJDO0FBQ0Y7QUFFdUM7QUFNaEYsMkRBQTJEO0FBQ3BELFNBQVNPO0lBQ2QsTUFBTSxDQUFDQyxZQUFZQyxjQUFjLEdBQUdULCtDQUFRQSxDQUF1QixFQUFFO0lBQ3JFLE1BQU0sQ0FBQ1UsU0FBU0MsV0FBVyxHQUFHWCwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNZLE9BQU9DLFNBQVMsR0FBR2IsK0NBQVFBLENBQWdCO0lBRWxELE1BQU1jLGtCQUFrQjtRQUN0QixJQUFJO1lBQ0ZILFdBQVc7WUFDWEUsU0FBUztZQUVULE1BQU0sRUFBRUUsSUFBSSxFQUFFSCxPQUFPSSxVQUFVLEVBQUUsR0FBRyxNQUFNZCxtREFBUUEsQ0FDL0NlLElBQUksQ0FBQyxpQ0FDTEMsTUFBTSxDQUFDLEtBQ1BDLEtBQUssQ0FBQyxjQUFjO2dCQUFFQyxXQUFXO1lBQUs7WUFFekMsSUFBSUosWUFBWSxNQUFNQTtZQUV0QlAsY0FBY00sUUFBUSxFQUFFO1FBQzFCLEVBQUUsT0FBT00sS0FBVTtZQUNqQkMsUUFBUVYsS0FBSyxDQUFDLDRDQUE0Q1M7WUFDMURSLFNBQVNRLElBQUlFLE9BQU8sSUFBSTtRQUMxQixTQUFVO1lBQ1JaLFdBQVc7UUFDYjtJQUNGO0lBRUFWLGdEQUFTQTtnREFBQztZQUNSYTtRQUNGOytDQUFHLEVBQUU7SUFFTCxrREFBa0Q7SUFDbEQsTUFBTVUsd0JBQXdCLENBQUNDO1FBQzdCLE1BQU1DLFFBQVEsSUFBSUM7UUFDbEJELE1BQU1FLFFBQVEsQ0FBQyxHQUFHLEdBQUcsR0FBRztRQUV4QixNQUFNQyxrQkFBa0JyQixXQUFXc0IsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxPQUFPLEtBQUtQO1FBRTdELElBQUlJLGdCQUFnQkksTUFBTSxLQUFLLEdBQUc7WUFDaEMsT0FBTztnQkFBRUMsUUFBUTtn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QUliLEtBQUs7WUFDL0QsT0FBT3ZCLDRIQUFnQkEsQ0FBQ3NCLE9BQU87Z0JBQUVlLE9BQU9KO2dCQUFhSyxLQUFLSDtZQUFVO1FBQ3RFO1FBRUEsSUFBSVEsZUFBZTtZQUNqQixPQUFPO2dCQUFFYixRQUFRYSxjQUFjRSxJQUFJO2dCQUFFZCxZQUFZWTtZQUFjO1FBQ2pFO1FBRUEscURBQXFEO1FBQ3JELE1BQU1aLGFBQWFDLGdCQUFnQixDQUFDLEVBQUU7UUFDdEMsT0FBTztZQUFFRixRQUFRO1lBQVlDO1FBQVc7SUFDMUM7SUFFQSxPQUFPO1FBQ0xpQjtRQUNBMUM7UUFDQUU7UUFDQStDO1FBQ0FLO1FBQ0FLO1FBQ0FHO1FBQ0FPO1FBQ0E3QixTQUFTSTtJQUNYO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxEZXZcXGJhbWFsaXRlLWhyLXN5c3RlbSBCZW1hbm5pbmdzbGlqc3RcXGhvb2tzXFx1c2UtYWZsb3NzZXItYXZhaWxhYmlsaXR5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHsgc3VwYWJhc2UgfSBmcm9tICdAL2xpYi9zdXBhYmFzZSdcclxuaW1wb3J0IHR5cGUgeyBEYXRhYmFzZSB9IGZyb20gJ0AvdHlwZXMvZGF0YWJhc2UnXHJcbmltcG9ydCB7IHBhcnNlSVNPLCBmb3JtYXQsIGlzV2l0aGluSW50ZXJ2YWwsIGlzQWZ0ZXIsIGlzQmVmb3JlIH0gZnJvbSAnZGF0ZS1mbnMnXHJcblxyXG50eXBlIEF2YWlsYWJpbGl0eVBlcmlvZCA9IERhdGFiYXNlWydwdWJsaWMnXVsnVGFibGVzJ11bJ2FmbG9zc2VyX2F2YWlsYWJpbGl0eV9wZXJpb2RzJ11bJ1JvdyddXHJcbnR5cGUgQXZhaWxhYmlsaXR5UGVyaW9kSW5zZXJ0ID0gRGF0YWJhc2VbJ3B1YmxpYyddWydUYWJsZXMnXVsnYWZsb3NzZXJfYXZhaWxhYmlsaXR5X3BlcmlvZHMnXVsnSW5zZXJ0J11cclxudHlwZSBBdmFpbGFiaWxpdHlQZXJpb2RVcGRhdGUgPSBEYXRhYmFzZVsncHVibGljJ11bJ1RhYmxlcyddWydhZmxvc3Nlcl9hdmFpbGFiaWxpdHlfcGVyaW9kcyddWydVcGRhdGUnXVxyXG5cclxuLy8gSG9vayB0byBmZXRjaCBhbGwgYXZhaWxhYmlsaXR5IHBlcmlvZHMgZm9yIGFsbCBhZmxvc3NlcnNcclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFsbEFmbG9zc2VyQXZhaWxhYmlsaXR5KCkge1xyXG4gIGNvbnN0IFthbGxQZXJpb2RzLCBzZXRBbGxQZXJpb2RzXSA9IHVzZVN0YXRlPEF2YWlsYWJpbGl0eVBlcmlvZFtdPihbXSlcclxuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKVxyXG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbClcclxuXHJcbiAgY29uc3QgZmV0Y2hBbGxQZXJpb2RzID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgc2V0TG9hZGluZyh0cnVlKVxyXG4gICAgICBzZXRFcnJvcihudWxsKVxyXG4gICAgICBcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnYWZsb3NzZXJfYXZhaWxhYmlsaXR5X3BlcmlvZHMnKVxyXG4gICAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAgIC5vcmRlcignc3RhcnRfZGF0ZScsIHsgYXNjZW5kaW5nOiB0cnVlIH0pXHJcbiAgICAgIFxyXG4gICAgICBpZiAoZmV0Y2hFcnJvcikgdGhyb3cgZmV0Y2hFcnJvclxyXG4gICAgICBcclxuICAgICAgc2V0QWxsUGVyaW9kcyhkYXRhIHx8IFtdKVxyXG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgYWxsIGF2YWlsYWJpbGl0eSBwZXJpb2RzOicsIGVycilcclxuICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBmZXRjaCBhdmFpbGFiaWxpdHkgcGVyaW9kcycpXHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGZldGNoQWxsUGVyaW9kcygpXHJcbiAgfSwgW10pXHJcblxyXG4gIC8vIEdldCBhdmFpbGFiaWxpdHkgc3RhdHVzIGZvciBhIHNwZWNpZmljIGFmbG9zc2VyXHJcbiAgY29uc3QgZ2V0QXZhaWxhYmlsaXR5U3RhdHVzID0gKGNyZXdJZDogc3RyaW5nKTogeyBzdGF0dXM6ICdiZXNjaGlrYmFhcicgfCAnYWZ3ZXppZycgfCAnb25iZWtlbmQnOyBuZXh0UGVyaW9kOiBBdmFpbGFiaWxpdHlQZXJpb2QgfCBudWxsIH0gPT4ge1xyXG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpXHJcbiAgICB0b2RheS5zZXRIb3VycygwLCAwLCAwLCAwKVxyXG5cclxuICAgIGNvbnN0IGFmbG9zc2VyUGVyaW9kcyA9IGFsbFBlcmlvZHMuZmlsdGVyKHAgPT4gcC5jcmV3X2lkID09PSBjcmV3SWQpXHJcbiAgICBcclxuICAgIGlmIChhZmxvc3NlclBlcmlvZHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiB7IHN0YXR1czogJ29uYmVrZW5kJywgbmV4dFBlcmlvZDogbnVsbCB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmluZCBwZXJpb2RzIHRoYXQgYXJlIGN1cnJlbnRseSBhY3RpdmUgb3IgdXBjb21pbmdcclxuICAgIGNvbnN0IGFjdGl2ZU9yVXBjb21pbmcgPSBhZmxvc3NlclBlcmlvZHNcclxuICAgICAgLmZpbHRlcihwID0+IHtcclxuICAgICAgICBjb25zdCBwZXJpb2RTdGFydCA9IHBhcnNlSVNPKHAuc3RhcnRfZGF0ZSlcclxuICAgICAgICBjb25zdCBwZXJpb2RFbmQgPSBwLmVuZF9kYXRlID8gcGFyc2VJU08ocC5lbmRfZGF0ZSkgOiBuZXcgRGF0ZSgnMjA5OS0xMi0zMScpXHJcbiAgICAgICAgcmV0dXJuIGlzQWZ0ZXIocGVyaW9kRW5kLCB0b2RheSkgfHwgaXNXaXRoaW5JbnRlcnZhbCh0b2RheSwgeyBzdGFydDogcGVyaW9kU3RhcnQsIGVuZDogcGVyaW9kRW5kIH0pXHJcbiAgICAgIH0pXHJcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBwYXJzZUlTTyhhLnN0YXJ0X2RhdGUpLmdldFRpbWUoKSAtIHBhcnNlSVNPKGIuc3RhcnRfZGF0ZSkuZ2V0VGltZSgpKVxyXG5cclxuICAgIGlmIChhY3RpdmVPclVwY29taW5nLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4geyBzdGF0dXM6ICdvbmJla2VuZCcsIG5leHRQZXJpb2Q6IG51bGwgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIGlmIGN1cnJlbnRseSBpbiBhIHBlcmlvZFxyXG4gICAgY29uc3QgY3VycmVudFBlcmlvZCA9IGFjdGl2ZU9yVXBjb21pbmcuZmluZChwID0+IHtcclxuICAgICAgY29uc3QgcGVyaW9kU3RhcnQgPSBwYXJzZUlTTyhwLnN0YXJ0X2RhdGUpXHJcbiAgICAgIGNvbnN0IHBlcmlvZEVuZCA9IHAuZW5kX2RhdGUgPyBwYXJzZUlTTyhwLmVuZF9kYXRlKSA6IG5ldyBEYXRlKCcyMDk5LTEyLTMxJylcclxuICAgICAgcmV0dXJuIGlzV2l0aGluSW50ZXJ2YWwodG9kYXksIHsgc3RhcnQ6IHBlcmlvZFN0YXJ0LCBlbmQ6IHBlcmlvZEVuZCB9KVxyXG4gICAgfSlcclxuXHJcbiAgICBpZiAoY3VycmVudFBlcmlvZCkge1xyXG4gICAgICByZXR1cm4geyBzdGF0dXM6IGN1cnJlbnRQZXJpb2QudHlwZSwgbmV4dFBlcmlvZDogY3VycmVudFBlcmlvZCB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm90IGluIGFueSBwZXJpb2QsIHJldHVybiB0aGUgbmV4dCB1cGNvbWluZyBwZXJpb2RcclxuICAgIGNvbnN0IG5leHRQZXJpb2QgPSBhY3RpdmVPclVwY29taW5nWzBdXHJcbiAgICByZXR1cm4geyBzdGF0dXM6ICdvbmJla2VuZCcsIG5leHRQZXJpb2QgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGFsbFBlcmlvZHMsXHJcbiAgICBsb2FkaW5nLFxyXG4gICAgZXJyb3IsXHJcbiAgICBnZXRBdmFpbGFiaWxpdHlTdGF0dXMsXHJcbiAgICByZWZyZXNoOiBmZXRjaEFsbFBlcmlvZHNcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBZmxvc3NlckF2YWlsYWJpbGl0eShjcmV3SWQ/OiBzdHJpbmcpIHtcclxuICBjb25zdCBbcGVyaW9kcywgc2V0UGVyaW9kc10gPSB1c2VTdGF0ZTxBdmFpbGFiaWxpdHlQZXJpb2RbXT4oW10pXHJcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSlcclxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpXHJcblxyXG4gIC8vIEZldGNoIGFsbCBwZXJpb2RzIGZvciBhIHNwZWNpZmljIGFmbG9zc2VyXHJcbiAgY29uc3QgZmV0Y2hQZXJpb2RzID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgaWYgKCFjcmV3SWQpIHtcclxuICAgICAgc2V0UGVyaW9kcyhbXSlcclxuICAgICAgc2V0TG9hZGluZyhmYWxzZSlcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgc2V0TG9hZGluZyh0cnVlKVxyXG4gICAgICBzZXRFcnJvcihudWxsKVxyXG4gICAgICBcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnYWZsb3NzZXJfYXZhaWxhYmlsaXR5X3BlcmlvZHMnKVxyXG4gICAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAgIC5lcSgnY3Jld19pZCcsIGNyZXdJZClcclxuICAgICAgICAub3JkZXIoJ3N0YXJ0X2RhdGUnLCB7IGFzY2VuZGluZzogdHJ1ZSB9KVxyXG4gICAgICBcclxuICAgICAgaWYgKGZldGNoRXJyb3IpIHtcclxuICAgICAgICAvLyBJZiB0YWJsZSBkb2Vzbid0IGV4aXN0IHlldCwganVzdCByZXR1cm4gZW1wdHkgYXJyYXlcclxuICAgICAgICBpZiAoZmV0Y2hFcnJvci5jb2RlID09PSAnNDJQMDEnIHx8IGZldGNoRXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ2RvZXMgbm90IGV4aXN0JykpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybignQXZhaWxhYmlsaXR5IHBlcmlvZHMgdGFibGUgZG9lcyBub3QgZXhpc3QgeWV0LiBQbGVhc2UgcnVuIHRoZSBTUUwgc2NyaXB0LicpXHJcbiAgICAgICAgICBzZXRQZXJpb2RzKFtdKVxyXG4gICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IGZldGNoRXJyb3JcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgc2V0UGVyaW9kcyhkYXRhIHx8IFtdKVxyXG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgYXZhaWxhYmlsaXR5IHBlcmlvZHM6JywgZXJyKVxyXG4gICAgICAvLyBJZiB0YWJsZSBkb2Vzbid0IGV4aXN0LCBqdXN0IHNldCBlbXB0eSBhcnJheSBpbnN0ZWFkIG9mIGVycm9yXHJcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJzQyUDAxJyB8fCBlcnIubWVzc2FnZT8uaW5jbHVkZXMoJ2RvZXMgbm90IGV4aXN0JykpIHtcclxuICAgICAgICBzZXRQZXJpb2RzKFtdKVxyXG4gICAgICAgIHNldEVycm9yKG51bGwpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBmZXRjaCBhdmFpbGFiaWxpdHkgcGVyaW9kcycpXHJcbiAgICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgZmV0Y2hQZXJpb2RzKClcclxuICB9LCBbY3Jld0lkXSlcclxuXHJcbiAgLy8gQWRkIG5ldyBwZXJpb2RcclxuICBjb25zdCBhZGRQZXJpb2QgPSBhc3luYyAocGVyaW9kOiBBdmFpbGFiaWxpdHlQZXJpb2RJbnNlcnQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3I6IGluc2VydEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdhZmxvc3Nlcl9hdmFpbGFiaWxpdHlfcGVyaW9kcycpXHJcbiAgICAgICAgLmluc2VydChwZXJpb2QpXHJcbiAgICAgICAgLnNlbGVjdCgpXHJcbiAgICAgICAgLnNpbmdsZSgpXHJcbiAgICAgIFxyXG4gICAgICBpZiAoaW5zZXJ0RXJyb3IpIHRocm93IGluc2VydEVycm9yXHJcbiAgICAgIFxyXG4gICAgICBhd2FpdCBmZXRjaFBlcmlvZHMoKVxyXG4gICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9XHJcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgYXZhaWxhYmlsaXR5IHBlcmlvZDonLCBlcnIpXHJcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBlcnIubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGFkZCBhdmFpbGFiaWxpdHkgcGVyaW9kJyB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBVcGRhdGUgcGVyaW9kXHJcbiAgY29uc3QgdXBkYXRlUGVyaW9kID0gYXN5bmMgKGlkOiBzdHJpbmcsIHVwZGF0ZXM6IEF2YWlsYWJpbGl0eVBlcmlvZFVwZGF0ZSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ2FmbG9zc2VyX2F2YWlsYWJpbGl0eV9wZXJpb2RzJylcclxuICAgICAgICAudXBkYXRlKHVwZGF0ZXMpXHJcbiAgICAgICAgLmVxKCdpZCcsIGlkKVxyXG4gICAgICAgIC5zZWxlY3QoKVxyXG4gICAgICAgIC5zaW5nbGUoKVxyXG4gICAgICBcclxuICAgICAgaWYgKHVwZGF0ZUVycm9yKSB0aHJvdyB1cGRhdGVFcnJvclxyXG4gICAgICBcclxuICAgICAgYXdhaXQgZmV0Y2hQZXJpb2RzKClcclxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxyXG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgYXZhaWxhYmlsaXR5IHBlcmlvZDonLCBlcnIpXHJcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBlcnIubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHVwZGF0ZSBhdmFpbGFiaWxpdHkgcGVyaW9kJyB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBEZWxldGUgcGVyaW9kXHJcbiAgY29uc3QgZGVsZXRlUGVyaW9kID0gYXN5bmMgKGlkOiBzdHJpbmcpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgZXJyb3I6IGRlbGV0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdhZmxvc3Nlcl9hdmFpbGFiaWxpdHlfcGVyaW9kcycpXHJcbiAgICAgICAgLmRlbGV0ZSgpXHJcbiAgICAgICAgLmVxKCdpZCcsIGlkKVxyXG4gICAgICBcclxuICAgICAgaWYgKGRlbGV0ZUVycm9yKSB0aHJvdyBkZWxldGVFcnJvclxyXG4gICAgICBcclxuICAgICAgYXdhaXQgZmV0Y2hQZXJpb2RzKClcclxuICAgICAgcmV0dXJuIHsgZXJyb3I6IG51bGwgfVxyXG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgYXZhaWxhYmlsaXR5IHBlcmlvZDonLCBlcnIpXHJcbiAgICAgIHJldHVybiB7IGVycm9yOiBlcnIubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGRlbGV0ZSBhdmFpbGFiaWxpdHkgcGVyaW9kJyB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDaGVjayBpZiBhZmxvc3NlciBpcyBhYnNlbnQgZHVyaW5nIGEgZGF0ZSByYW5nZVxyXG4gIGNvbnN0IGlzQWJzZW50RHVyaW5nUGVyaW9kID0gKHN0YXJ0RGF0ZTogc3RyaW5nLCBlbmREYXRlPzogc3RyaW5nIHwgbnVsbCk6IHsgaXNBYnNlbnQ6IGJvb2xlYW47IHBlcmlvZDogQXZhaWxhYmlsaXR5UGVyaW9kIHwgbnVsbCB9ID0+IHtcclxuICAgIGlmICghc3RhcnREYXRlKSByZXR1cm4geyBpc0Fic2VudDogZmFsc2UsIHBlcmlvZDogbnVsbCB9XHJcblxyXG4gICAgY29uc3QgdHJpcFN0YXJ0ID0gcGFyc2VJU08oc3RhcnREYXRlKVxyXG4gICAgY29uc3QgdHJpcEVuZCA9IGVuZERhdGUgPyBwYXJzZUlTTyhlbmREYXRlKSA6IHRyaXBTdGFydFxyXG5cclxuICAgIC8vIENoZWNrIGFsbCBhYnNlbmNlIHBlcmlvZHNcclxuICAgIGNvbnN0IGFic2VuY2VQZXJpb2RzID0gcGVyaW9kcy5maWx0ZXIocCA9PiBwLnR5cGUgPT09ICdhZndlemlnJylcclxuICAgIFxyXG4gICAgZm9yIChjb25zdCBwZXJpb2Qgb2YgYWJzZW5jZVBlcmlvZHMpIHtcclxuICAgICAgY29uc3QgcGVyaW9kU3RhcnQgPSBwYXJzZUlTTyhwZXJpb2Quc3RhcnRfZGF0ZSlcclxuICAgICAgY29uc3QgcGVyaW9kRW5kID0gcGVyaW9kLmVuZF9kYXRlID8gcGFyc2VJU08ocGVyaW9kLmVuZF9kYXRlKSA6IG5ldyBEYXRlKCcyMDk5LTEyLTMxJykgLy8gT3BlbiBlbmQgPSBmYXIgZnV0dXJlXHJcbiAgICAgIFxyXG4gICAgICAvLyBDaGVjayBpZiB0cmlwIG92ZXJsYXBzIHdpdGggYWJzZW5jZSBwZXJpb2RcclxuICAgICAgaWYgKFxyXG4gICAgICAgIChpc1dpdGhpbkludGVydmFsKHRyaXBTdGFydCwgeyBzdGFydDogcGVyaW9kU3RhcnQsIGVuZDogcGVyaW9kRW5kIH0pIHx8XHJcbiAgICAgICAgIGlzV2l0aGluSW50ZXJ2YWwodHJpcEVuZCwgeyBzdGFydDogcGVyaW9kU3RhcnQsIGVuZDogcGVyaW9kRW5kIH0pIHx8XHJcbiAgICAgICAgIChpc0JlZm9yZSh0cmlwU3RhcnQsIHBlcmlvZFN0YXJ0KSAmJiBpc0FmdGVyKHRyaXBFbmQsIHBlcmlvZEVuZCkpKVxyXG4gICAgICApIHtcclxuICAgICAgICByZXR1cm4geyBpc0Fic2VudDogdHJ1ZSwgcGVyaW9kIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7IGlzQWJzZW50OiBmYWxzZSwgcGVyaW9kOiBudWxsIH1cclxuICB9XHJcblxyXG4gIC8vIEdldCBjdXJyZW50IGF2YWlsYWJpbGl0eSBzdGF0dXMgKGZvciBkaXNwbGF5IGluIGNhcmRzKVxyXG4gIGNvbnN0IGdldEN1cnJlbnRBdmFpbGFiaWxpdHlTdGF0dXMgPSAoKTogeyBzdGF0dXM6ICdiZXNjaGlrYmFhcicgfCAnYWZ3ZXppZycgfCAnb25iZWtlbmQnOyBuZXh0UGVyaW9kOiBBdmFpbGFiaWxpdHlQZXJpb2QgfCBudWxsIH0gPT4ge1xyXG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpXHJcbiAgICB0b2RheS5zZXRIb3VycygwLCAwLCAwLCAwKVxyXG5cclxuICAgIC8vIEZpbmQgcGVyaW9kcyB0aGF0IGFyZSBjdXJyZW50bHkgYWN0aXZlIG9yIHVwY29taW5nXHJcbiAgICBjb25zdCBhY3RpdmVPclVwY29taW5nID0gcGVyaW9kc1xyXG4gICAgICAuZmlsdGVyKHAgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBlcmlvZFN0YXJ0ID0gcGFyc2VJU08ocC5zdGFydF9kYXRlKVxyXG4gICAgICAgIGNvbnN0IHBlcmlvZEVuZCA9IHAuZW5kX2RhdGUgPyBwYXJzZUlTTyhwLmVuZF9kYXRlKSA6IG5ldyBEYXRlKCcyMDk5LTEyLTMxJylcclxuICAgICAgICByZXR1cm4gaXNBZnRlcihwZXJpb2RFbmQsIHRvZGF5KSB8fCBpc1dpdGhpbkludGVydmFsKHRvZGF5LCB7IHN0YXJ0OiBwZXJpb2RTdGFydCwgZW5kOiBwZXJpb2RFbmQgfSlcclxuICAgICAgfSlcclxuICAgICAgLnNvcnQoKGEsIGIpID0+IHBhcnNlSVNPKGEuc3RhcnRfZGF0ZSkuZ2V0VGltZSgpIC0gcGFyc2VJU08oYi5zdGFydF9kYXRlKS5nZXRUaW1lKCkpXHJcblxyXG4gICAgaWYgKGFjdGl2ZU9yVXBjb21pbmcubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiB7IHN0YXR1czogJ29uYmVrZW5kJywgbmV4dFBlcmlvZDogbnVsbCB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgY3VycmVudGx5IGluIGEgcGVyaW9kXHJcbiAgICBjb25zdCBjdXJyZW50UGVyaW9kID0gYWN0aXZlT3JVcGNvbWluZy5maW5kKHAgPT4ge1xyXG4gICAgICBjb25zdCBwZXJpb2RTdGFydCA9IHBhcnNlSVNPKHAuc3RhcnRfZGF0ZSlcclxuICAgICAgY29uc3QgcGVyaW9kRW5kID0gcC5lbmRfZGF0ZSA/IHBhcnNlSVNPKHAuZW5kX2RhdGUpIDogbmV3IERhdGUoJzIwOTktMTItMzEnKVxyXG4gICAgICByZXR1cm4gaXNXaXRoaW5JbnRlcnZhbCh0b2RheSwgeyBzdGFydDogcGVyaW9kU3RhcnQsIGVuZDogcGVyaW9kRW5kIH0pXHJcbiAgICB9KVxyXG5cclxuICAgIGlmIChjdXJyZW50UGVyaW9kKSB7XHJcbiAgICAgIHJldHVybiB7IHN0YXR1czogY3VycmVudFBlcmlvZC50eXBlLCBuZXh0UGVyaW9kOiBjdXJyZW50UGVyaW9kIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBOb3QgaW4gYW55IHBlcmlvZCwgcmV0dXJuIHRoZSBuZXh0IHVwY29taW5nIHBlcmlvZFxyXG4gICAgY29uc3QgbmV4dFBlcmlvZCA9IGFjdGl2ZU9yVXBjb21pbmdbMF1cclxuICAgIHJldHVybiB7IHN0YXR1czogJ29uYmVrZW5kJywgbmV4dFBlcmlvZCB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcGVyaW9kcyxcclxuICAgIGxvYWRpbmcsXHJcbiAgICBlcnJvcixcclxuICAgIGFkZFBlcmlvZCxcclxuICAgIHVwZGF0ZVBlcmlvZCxcclxuICAgIGRlbGV0ZVBlcmlvZCxcclxuICAgIGlzQWJzZW50RHVyaW5nUGVyaW9kLFxyXG4gICAgZ2V0Q3VycmVudEF2YWlsYWJpbGl0eVN0YXR1cyxcclxuICAgIHJlZnJlc2g6IGZldGNoUGVyaW9kc1xyXG4gIH1cclxufVxyXG5cclxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0Iiwic3VwYWJhc2UiLCJwYXJzZUlTTyIsImlzV2l0aGluSW50ZXJ2YWwiLCJpc0FmdGVyIiwiaXNCZWZvcmUiLCJ1c2VBbGxBZmxvc3NlckF2YWlsYWJpbGl0eSIsImFsbFBlcmlvZHMiLCJzZXRBbGxQZXJpb2RzIiwibG9hZGluZyIsInNldExvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwiZmV0Y2hBbGxQZXJpb2RzIiwiZGF0YSIsImZldGNoRXJyb3IiLCJmcm9tIiwic2VsZWN0Iiwib3JkZXIiLCJhc2NlbmRpbmciLCJlcnIiLCJjb25zb2xlIiwibWVzc2FnZSIsImdldEF2YWlsYWJpbGl0eVN0YXR1cyIsImNyZXdJZCIsInRvZGF5IiwiRGF0ZSIsInNldEhvdXJzIiwiYWZsb3NzZXJQZXJpb2RzIiwiZmlsdGVyIiwicCIsImNyZXdfaWQiLCJsZW5ndGgiLCJzdGF0dXMiLCJuZXh0UGVyaW9kIiwiYWN0aXZlT3JVcGNvbWluZyIsInBlcmlvZFN0YXJ0Iiwic3RhcnRfZGF0ZSIsInBlcmlvZEVuZCIsImVuZF9kYXRlIiwic3RhcnQiLCJlbmQiLCJzb3J0IiwiYSIsImIiLCJnZXRUaW1lIiwiY3VycmVudFBlcmlvZCIsImZpbmQiLCJ0eXBlIiwicmVmcmVzaCIsInVzZUFmbG9zc2VyQXZhaWxhYmlsaXR5IiwicGVyaW9kcyIsInNldFBlcmlvZHMiLCJmZXRjaFBlcmlvZHMiLCJlcSIsImNvZGUiLCJpbmNsdWRlcyIsIndhcm4iLCJhZGRQZXJpb2QiLCJwZXJpb2QiLCJpbnNlcnRFcnJvciIsImluc2VydCIsInNpbmdsZSIsInVwZGF0ZVBlcmlvZCIsImlkIiwidXBkYXRlcyIsInVwZGF0ZUVycm9yIiwidXBkYXRlIiwiZGVsZXRlUGVyaW9kIiwiZGVsZXRlRXJyb3IiLCJkZWxldGUiLCJpc0Fic2VudER1cmluZ1BlcmlvZCIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJpc0Fic2VudCIsInRyaXBTdGFydCIsInRyaXBFbmQiLCJhYnNlbmNlUGVyaW9kcyIsImdldEN1cnJlbnRBdmFpbGFiaWxpdHlTdGF0dXMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/use-aflosser-availability.ts\n"));

/***/ })

});